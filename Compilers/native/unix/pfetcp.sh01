---- Cut Here and unpack ----
#!/bin/sh
# shar:	Shell Archiver  (v1.22)
#
#                                                                          
#                                                                          
#
#	Run the following text with /bin/sh to create:
#	  Readme.efc
#	  mine.c
#	  fcntl.fo
#	  sopen.h
#	  server.fo
#	  client.fo
#	  xdr.fo
#	  serverx.fo
#	  clientx.fo
#	  xdr-test.fo
#
if test -r s2_seq_.tmp
then echo "Must unpack archives in sequence!"
     next=`cat s2_seq_.tmp`; echo "Please unpack part $next next"
     exit 1; fi
echo "x - extracting Readme.efc (Text)"
sed 's/^X//' << 'SHAR_EOF' > Readme.efc &&
X
X	Documentation for Low-Level I/O, TCP/IP I/O and XDR V1.0 for PFE.
X
X
X	The low level I/O functions OPEN, OPEN-CREATE, CLOSE, READ, WRITE and
X	LSEEK	are implemented in the file 'mine.c'.  If TCP/IP sockets
X	are also wanted, then the macro OPTIONS in the Makefile must
X	include -DTCP, this will add the words SOPEN, LISTEN, and SOCKET-ACCEPT.
X	The Forth interface to these is also in 'mine.c'.
X
X
X	If you want to compile these into your version of PFE Forth, then
X	you need to change the OPTS line in the Makefile to one of the following,
X
X	For just low level I/O		          -- no changes.
X
X	For low level I/O and TCP/IP sockets      -- add -DTCP to OPTS, e.g.,
X
XOPTS = -DTCP
X
X        For low level I/O, TCP/IP sockets and XDR  -- add -DTCP and -DUSE_XDR
Xto OPTS, e.g.,
X
XOPTS = -DTCP -DUSE_XDR
X
X
X	Next merge the file 'mine.c' with your current version of 'yours.c'.
X
X	Then build Forth as usual.
X
X
X
X
X
X	The glossary for the additional words.
X
X
X	OPEN ( str_addr count flag_int -- handle )
X
X	This word implements the system function open().
X	Opens the named file according to the INTEGER value of the
X	mode.  The flag value is usually defined in fcntl.h according
X	to the following (the values given here are typical, but not
X	necessarily universal).
X
X
X     0		O_RDONLY            open for reading only
X
X     1		O_WRONLY            open for writing only
X
X     2		O_RDWR              open for reading and writing
X
X     4		O_NDELAY            do not block on open
X
X     010	O_APPEND            append on each write
X
X     00400	O_CREAT             create file if it does not exist
X
X     01000	O_TRUNC             truncate size to 0
X
X     02000	O_EXCL              error if create and file exists
X
X
X	These values are defined in the file 'fcntl.fo'.
X
X
X	On return OPEN leaves the integer file descriptor on the
X	stack.  This value is negative if the open failed.
X
X
X
X	OPEN-CREATE ( str_addr count flag_int mode_int -- handle )
X
X	Does the same as OPEN with the flag set to O_CREAT, but provides
X	for an additional parameter to set the file permissions. Using
X        O_CREAT as part of the flag value is harmlessly redundant.
X
X
X
X
X
X	CLOSE ( handle -- status )
X
X	This word implements the system function close().
X	Closes a file referenced by the file descriptor.  The
X	status flag is zero if successful, and -1 if it failed.
X
X
X
X	WRITE ( addr nbytes handle -- status )
X
X	This word implements the system function write().
X	Writes to a file referenced by the file descriptor, 'handle'.
X	The start of the data to write is at 'addr' and there are
X	'nbytes' bytes to write.  On return 'status' is the number
X	of bytes successfuly written, or a -1 on failure.
X
X
X	READ ( addr nbytes handle -- status )
X
X	This word implements the system function read().
X	Reads from a file referenced by the file descriptor, 'handle'.
X	The start of the data to destination is at 'addr' and there are
X	'nbytes' bytes to read.  On return 'status' is the number
X	of bytes successfuly read.  If the status value is zero, then
X	end-of-file has been reached.  If the status is negative, then
X	an error occurred.
X
X
X
X        LSEEK ( offset whence handle -- status )
X
X	This word implements the system function lseek().
X	Sets the file pointer to 'offset' bytes according to the value
X	of 'whence' according to:
X
X
X          If whence is L_SET, the pointer is set to offset bytes.
X
X          If whence is L_INCR, the pointer is set to its current
X          location plus offset.
X
X          If whence is L_XTND, the pointer is set to the size of
X          the file plus offset.
X
X	The typical (but not universal) values of the whence constants
X	are,
X
X        0   L_SET             ( also known as   SEEK_SET )
X        1   L_INCR            ( also known as   SEEK_CUR )
X        2   L_XTND            ( also known as   SEEK_END )
X
X
X	These values are also defined in 'fnctl.fo'
X
X
X	LSEEK returns the pointer location in bytes from the beginning
X	of the file if it succeeds.  On a failure the status value is -1
X	(in which case the file pointer is unchanged).  NOTE: offset and
X	status are 'off_t' data types, it is presumed that this data type
X	will fit into a single cell.
X
X
X	The following words are part of the TCP/IP interface
X
X	
X
X	SOPEN ( str_addr count socket type -- handle )
X
X	This word encapsulates calls to several system functions in
X	order to set up a TCP/IP connection as either a client or
X	a server.  It was written so that opening a TCP/IP socket is
X	just about as simple as opening a file.
X
X
X	As a client 'str_addr' and 'count' represent the counted
X	string that has the name of the server that the client wishes
X	to contact.  'socket' is the TCP/IP socket that the server
X	is using.  For clients, 'type' is just the number 0.
X
X	As a server 'str_addr' and 'count' are 0 values.  The value
X	of 'socket' is the TCP/IP socket number that this server will
X	use to service requests.  For servers, 'type' is the number 1.
X
X
X	In either case, the returned value on the stack is -1 if an
X	error occurred.  If the stack value is > 0, then it is used
X	exactly like a file handle for READ, WRITE and CLOSE.
X
X
X
X
X	LISTEN ( backlog socket -- status )
X
X	The server process needs to let the operating system know that
X	it is willing to accept connections to its socket, and the
X	queue limit for incoming connections.  The word LISTEN does
X	this.  The value of 'socket' is the value returned by a
X	previous successful call to SOPEN.  The value of 'backlog'
X	is the queue limit (a value of 5 is usually used, other values
X	may not be supported by your system).  On return a 0 status
X	indicates success, a -1 indicates an error.  CLIENT PROCESSES
X	DO NOT USE THIS WORD.
X
X
X
X	SOCKET-ACCEPT ( sockaddr len socket -- nsock )
X
X	For servers, this where the process actually waits until
X	a connection is present.  SOCKET-ACCEPT is called after
X	LISTEN.  The value of 'socket' is the value returned by a
X	previous successful call to SOPEN.  'sockaddr' is the address
X	of the data space for information on the connecting entity, it
X	is filled in by SOCKET-ADDR.  The user generally won't need to
X	be concerned with its internals.  CHECK WITH YOUR SYSTEM MANUALS
X	ON THE SIZE OF THIS REGION, typically it is 16 bytes, the size of
X	the region is the parameter 'len'.  On return the value 'nsock' is
X	negative if SOCKET-ACCEPT failed, if it is positive, then this value
X	is used as a file descriptor for use in READ, WRITE and CLOSE for
X	this instance of the connection.   CLIENT PROCESSES DO NOT USE THIS WORD.
X
X
X
X
X        XDR
X
X        The XDR (eXternal Data Representation) library provides the
X        ability to write to files or sockets that can be properly
X        read by machines with different data formats.  XDR provides
X        for more than differences in the "endian-ness" of two machines,
X        it allows for differences in floating point formats and word sizes
X        as well.
X
X        To write using XDR, some data is converted from the native
X        representation to XDR, then the XDR data is written as binary data.
X
X             Native format Data  --> XDR-ENCODE --> Write encoded data
X
X
X        The reading process reads the binary data and then uses an XDR
X        conversion routine to convert to the local representation.
X
X             Read encoded data --> XDR-DECODE --> Native format Data
X
X
X
X	The XDR glossary
X
X
X        XDR-BUFFER-INIT ( buffer_addr size flag --  )
X
X        Before using XDR a translation buffer must be associated with the
X        internal XDR data structures.  The parameter 'size' is the number
X        of bytes that this buffer has, it should be at least as large as
X        any data structure to be read/written.  The parameter 'flag' is
X        XDR_DECODE if READ operations are to be done or XDR_ENCODE if
X        write operations are to be performed.  In the current version of
X        the XDR interface, there can be one ENCODE and/or one DECODE XDR
X        buffer in use by any given process.
X
X	XDR-REWIND ( -- )
X
X        Rewinds the XDR read buffer so that it can be reused.  If this is
X	not used, subsequent data is appended to what is already in the buffer.
X        This is only used on the read buffer.
X
X
X        The other words follow the convention:
X
X        XDR->TYPE
X
X        An XDR DECODE word.  After performing a read into the buffer,
X        these words can be used to convert the data to TYPE and push its
X        value to the stack.
X
X
X        TYPE->XDR
X
X        An XDR ENCODE word.  These words will convert data of the given TYPE
X        to XDR format in the data buffer.  Subsequently the data buffer can
X        be written out.
X
X       TYPE          data type                     stack diagram
X                                                encode          decode
X        L             long int                  ( n -- )        ( -- n )
X        UL            unsigned long int         ( u -- )        ( -- u )
X        F             (float) double          ( -- , f: x -- )  ( -- , f: -- x)
X        STR           Forth counted strings      see note below on stacks
X
X
X
X
X
X        THE WORDS BELOW HERE PROVIDE FOR CONVERSIONS TO NON-FORTH DATA TYPES.
X        THEY ARE NECESSARY IN ORDER TO BE ABLE TO COMMUNICATE WITH XDR DATA
X        STREAMS THAT DO NO ORIGINATE FROM A FORTH PROCESS.  FROM THE
X        APPLICATION LEVEL THEY ALL WORK WITH NORMAL FORTH DATA TYPES, BUT THEY
X        TREAT THAT DATA AS IF IT WERE ANOTHER TYPE FOR ENCODING OR DECODING.
X
X
X
X        TYPE          data type                     stack diagram
X                                                encode          decode
X        C             char                      ( c -- )        ( -- c )
X        I             int                       ( n -- )        ( -- n )
X        UI            unsigned int              ( u -- )        ( -- u )
X        SI            short int                 ( n -- )        ( -- n )
X        SF            (short) float             ( -- , f: x -- )  ( -- , f: -- x)
X        CSTR          C string                   see STR note below
X
X
X
X        This list does NOT provide for all of the XDR defined data types,
X        just the most basic ones are provided in this version of the interface.
X
X
X
X        Special note on STR operations
X
X
X        STR->XDR ( addr count -- count' )
X
X        This word will convert a Forth counted string to XDR format in the
X        data buffer.  The XDR data format INCLUDES THE BYTE COUNT, so that
X        the count return parameter includes this additional space.  Use
X        count' to control the subsequent write of the data buffer.  The data
X        actually need not be a string, a variable length byte array is actually
X        used here.
X
X
X        CSTR->XDR ( addr count -- count' )
X
X        The word CSTR->XDR works nearly identically to STR->XDR except it encodes
X        the string as if it were a C (NULL terminated) string of characters
X        instead of a counted string (it internally provides the NULL, the
X        application can use it as a normal Forth string).
X
X
X
X
X        XDR->STR ( addr count -- addr count' )
X
X        After performing a read into the buffer, XDR->STR is used to convert
X        the data to a Forth counted string.  The 'addr' is the destination
X        for the string and 'count' is the count of the number of characters.
X        The data actually need not be a string, a variable length byte array
X        is actually used here.
X
X        Typically XDR-UI will be used to determine what the count actually
X        is before calling XDR->STR, for examlple (error checking omitted
X        for clarity),
X
X        FH @ BUFFER BYTES_PER_XDR_UNIT READ       \ read the byte count
X
X        \ read the character data into the buffer after the count
X        \ note the use of XDR->UI to determine how many bytes to read
X        \ (XDR->UI - BYTES_PER_XDR_UNIT).
X        \ For XDR counted strings, the byte count includes the space for
X        \ the byte count itself.
X
X        FH @ BUFFER BYTES_PER_XDR_UNIT + XDR->UI BYTES_PER_XDR_UNIT - READ
X
X        PAD SWAP XDR->STR      \ convert the data to a Forth string in PAD
X
X
X        XDR->CSTR ( addr count -- addr count' )
X
X        The word XDR->CSTR works identically to XDR->STR except it expects
X        the XDR data stream to represent a C (NULL teriminated) string of
X        characters.  This word returns a normal Forth counted string to the
X        application.  When reading C strings, the byte count DOES NOT include
X        an entry for the byte count or for the terminating NULL, so to perform
X        the read after determining the byte count use something like,
X
X
X        FH @ BUFFER BYTES_PER_XDR_UNIT READ       \ read the byte count
X
X
X        \ the number of bytes to read is XDR->UI + 1
X
X        FH @ BUFFER BYTES_PER_XDR_UNIT + XDR->UI 1+ READ
X
X        PAD SWAP XDR->CSTR
X
X
X==============================================================================
X
X
X
X Everett (Skip) Carter        Phone:  408-656-3318 FAX: 408-656-2712
X Naval Postgraduate School    INTERNET: skip@taygeta.oc.nps.navy.mil
X Dept. of Oceanography, Code OC/CR  UUCP:     ...!uunet!taygeta!skip
X Monterey, CA. 93943
X                  WWW: http://taygeta.oc.nps.navy.mil/skips_home.html
X
X
SHAR_EOF
chmod 0644 Readme.efc || echo "restore of Readme.efc fails"
echo "x - extracting mine.c (Text)"
sed 's/^X//' << 'SHAR_EOF' > mine.c &&
X/*
X * This file is part of the portable Forth environment written in ANSI C.
X * Copyright (C) 1994  Dirk Uwe Zoller
X *
X * This library is free software; you can redistribute it and/or
X * modify it under the terms of the GNU Library General Public
X * License as published by the Free Software Foundation; either
X * version 2 of the License, or (at your option) any later version.
X *
X * This library is distributed in the hope that it will be useful,
X * but WITHOUT ANY WARRANTY; without even the implied warranty of
X * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
X * See the GNU Library General Public License for more details.
X *
X * You should have received a copy of the GNU Library General Public
X * License along with this library; if not, write to the Free
X * Software Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
X *
X * This file is version 0.9.9 of 05-Nov-94
X * Check for the latest version of this package via anonymous ftp at
X *	roxi.rz.fht-mannheim.de:/pub/languages/forth/pfe-VERSION.tar.gz
X * or	sunsite.unc.edu:/pub/languages/forth/pfe-VERSION.tar.gz
X * or	ftp.cygnus.com:/pub/forth/pfe-VERSION.tar.gz
X *
X * Please direct any comments via internet to
X *	duz@roxi.rz.fht-mannheim.de.
X * Thank You.
X */
X/*
X * yours.c ---	This file is the place to add any primitives you might wish.
X * (duz 24Feb94)
X
X   rcsid: @(#)yours.c	1.3 17:39:15 11/17/94   EFC
X
X */
X
X#include "forth.h"
X#include "support.h"
X
Xextern char* getenv(char* name);
X
XCode (user_added_primitive)
X{
X  outs ("\nThis is a sample primitive."
X	" See src/yours.c for it's definition.\n");
X}
X
XCode (GetEnv)
X{
X  sp[1] = (Cell)getenv( (char *)sp [1] );
X  if ( sp[1] )
X     sp[0] = strlen( (char *)sp[1] );
X  else
X     sp[0] = 0;
X}
X
X
X#ifdef TCP
X
X/* sopen.c	         tcp_open(), udp_open() and resolve_name()
X
X	does all the dirty work in opening a socket on a (possibly) remote
X	system.
X
X
X	tcp_open()           For TCP connections
X
X	three input parameters:
X		hostname	-- the name (or inet addr) of the remote end
X		                       of the socket
X		port		-- the remote port socket number
X	                           if >= 0, use port# of service
X                                   if < 0,  bind a local reserved port
X                                   if > 0,  this is the port# (host byte order)
X				            of server
X		service         -- the service to connect to, can be NULL
X                                   if port > 0
X		kind		-- = 0 for clients, = 1 for servers
X		                     clients call connect()
X				     servers call bind()
X
X	returns:
X		< 0		if an error
X		fd ( > 0)	the file discriptor for a successful open
X
X
X
X       udp_open()             For UDP connections
X
X         host          name of other system to communicate with
X	 port          if >= 0, use port# of service
X                       if > 0,  this is the port# (host byte order) of server
X         service       name of service being requested, can be NULL iff port > 0
X	 dontconn      if == 0, call connect(), else don't
X
X
X	returns:
X		< 0		if an error
X		fd ( > 0)	the file discriptor for a successful open
X
X
X
X
X           This code is partly based upon code in:
X
X
X           W. Richard Stevens, 1990; Unix Network Programming,
X           Prentice-Hall, Englewood Cliffs, N.J., 772 pages
X
X
X*/
X
Xstatic char rcsid[] = "@(#)sopen.c	1.6 17:17:29 2/15/93   EFC";
X
X#include <stdio.h>
X#include <ctype.h>
X#include <sys/types.h>
X#include <sys/socket.h>
X#include <netinet/in.h>
X#include <errno.h>
X#include <netdb.h>
X
X
X#include "sopen.h"
X
X
X#define CLIENT		0
X#define SERVER		1
X
X/* define SILENT to be either 0 or 1 */
X
X#define SILENT          0
X
Xextern int errno, h_errno;
X
X
Xstruct sockaddr_in sinhim = { AF_INET };
X
Xstruct sockaddr_in       udp_srv_addr;
Xstruct sockaddr_in       udp_cli_addr;
X
X
X#ifdef NO_PROTO
Xint tcp_open(hostname,port,service,kind)
Xchar *hostname, *service;
Xint port, kind;
X#else
Xint tcp_open(char* hostname, int port,char* service, int kind)
X#endif
X{
X	struct hostent *hp;
X	struct servent *sp;
X	int resvport;
X	int fd = 0;
X
X        bzero( (char *)&sinhim, sizeof(sinhim));
X        sinhim.sin_family = AF_INET;
X
X        if ( service != NULL )
X        {
X             if ( (sp = getservbyname( service, "tcp" )) == NULL )
X             {
X#if  (SILENT == 0)
X                        perror( "tcp_open: unknown service");
X#endif
X                        return -1;
X             }
X
X
X             if ( port > 0 )
X                    sinhim.sin_port = htons( port );  /* callers value */
X             else
X                    sinhim.sin_port = sp->s_port;     /* services value */
X
X        }
X        else
X        {
X             if ( port <= 0 )
X             {
X#if (SILENT == 0)
X                   perror( "tcp_open: must specify either service or port" );
X#endif
X                   return -2;
X             }
X             sinhim.sin_port = htons( port );
X        }
X
X
X	if (hostname != NULL)
X	{
X		if ( resolve_name( hostname, &hp, SILENT ) )
X			return -3;
X
X	     bcopy ( hp->h_addr, &sinhim.sin_addr, sizeof (sinhim.sin_addr) );
X
X             /* some systems need to do it this way, not sure what ones though */
X     /*
X	     bcopy (&(hp->h_addr), &sinhim.sin_addr,sizeof( sinhim.sin_addr) );
X     */
X
X	}
X
X
X
X	if (port >= 0 )
X	{
X	    if ( (fd = socket( AF_INET, SOCK_STREAM, 0)) < 0)
X	    {
X#if (SILENT == 0)
X		perror("tcp_open: socket");
X#endif
X		return -4;
X	    }
X         }
X         else if ( port < 0 )
X         {
X              resvport = IPPORT_RESERVED - 1;
X              if ( (fd = rresvport(&resvport)) < 0 )
X              {
X#if (SILENT == 0)
X                  perror("tcp_open: can't get a reserved TCP port" );
X#endif
X                  return -7;
X              }
X         }
X
X
X
X	if (kind == CLIENT)
X	{
X		if (connect(fd, &sinhim, sizeof(sinhim)) < 0)
X		{
X#if (SILENT == 0)
X			perror("tcp_open: connect");
X#endif
X			return -5;
X		}
X	}
X	else 	/* assume kind == SERVER */
X	{
X		if ( bind(fd, &sinhim, sizeof(sinhim) ) < 0)
X		{
X#if (SILENT == 0 )
X			perror("tcp_open: bind");
X#endif
X			return -6;
X		}
X
X
X	}
X
X
X	return fd;
X}
X
X
X
X#ifdef NO_PROTO
Xint udp_open(hostname, port, service, dontconn)
Xchar *hostname;
Xint port;
Xchar *service;
Xint dontconn;
X#else
Xint udp_open(char *hostname, int port, char* service, int dontconn)
X#endif
X{
X       int fd;
X       unsigned long inaddr;
X       struct servent *sp;
X       struct hostent *hp;
X
X        bzero( (char *)&udp_srv_addr, sizeof(udp_srv_addr));
X        udp_srv_addr.sin_family = AF_INET;
X
X
X        if ( service != NULL )
X        {
X             if ( (sp = getservbyname( service, "udp" )) == NULL )
X             {
X#if  (SILENT == 0)
X                        perror( "udp_open: unknown service");
X#endif
X                        return -1;
X             }
X
X
X             if ( port > 0 )
X                    udp_srv_addr.sin_port = htons( port );  /* callers value */
X             else
X                    udp_srv_addr.sin_port = sp->s_port;     /* services value */
X
X        }
X        else
X        {
X             if ( port <= 0 )
X             {
X#if (SILENT == 0)
X                   perror( "udp_open: must specify either service or port" );
X#endif
X                   return -2;
X             }
X             udp_srv_addr.sin_port = htons( port );
X        }
X
X
X	if (hostname != NULL)
X	{
X		if ( resolve_name( hostname, &hp, SILENT ) )
X			return -3;
X
X	     bcopy ( hp->h_addr, &udp_srv_addr.sin_addr, sizeof (udp_srv_addr.sin_addr) );
X
X             /* some systems need to do it this way, not sure what ones though */
X     /*
X	     bcopy (&(hp->h_addr), &udp_srv_addr.sin_addr,sizeof( udp_srv_addr.sin_addr) );
X     */
X
X	}
X
X
X
X       if ( port < 0 )
X       {
X#if (SILENT == 0)
X	 perror( "udp_open: reserved ports not implemented yet." );
X#endif
X	 return -7;
X        }
X
X
X        if ( (fd = socket(AF_INET, SOCK_DGRAM, 0)) < 0)
X        {
X#if (SILENT == 0)
X                 perror("udp_open: can't create UDP socket" );
X#endif
X                 return -4;
X        }
X
X
X       if ( hostname != NULL )     /* presumably this means that this is a client */
X       {
X	 /* bind any local address */
X	 bzero( (char *)&udp_cli_addr, sizeof(udp_cli_addr));
X	 udp_cli_addr.sin_family = AF_INET;
X	 udp_cli_addr.sin_addr.s_addr = htonl( INADDR_ANY );
X	 udp_cli_addr.sin_port = htons( 0 );
X
X
X
X       if ( bind( fd, (struct sockaddr *)&udp_cli_addr, sizeof(udp_cli_addr)) < 0)
X       {
X	          close( fd );
X#if (SILENT == 0)
X	          perror( "udp_open: bind error" );
X#endif
X		  return -6;
X       }
X
X       }
X       else                /* this must be a server */
X       {
X
X	 /* bind server address */
X
X       if ( bind( fd, (struct sockaddr *)&udp_srv_addr, sizeof(udp_srv_addr)) < 0)
X       {
X	          close( fd );
X#if (SILENT == 0)
X	          perror( "udp_open: bind error" );
X#endif
X		  return -8;
X       }
X
X
X       }
X
X
X       /* This is usually used by most callers since the peer
X          usually won't change.  By calling connect() the caller can use send()
X          and recv(), otherwise sendto() and recvfrom() are necessary.
X       */
X
X       if ( dontconn == 0 )
X       {
X	   if ( connect(fd, &udp_srv_addr, sizeof( udp_srv_addr )) < 0 )
X	   {
X#if (SILENT == 0 )
X	                perror( "udp_open: connect error" );
X#endif
X			return -5;
X	    }
X
X       }
X
X       return( fd );
X
X
X}
X
X
X
X
X#ifdef NO_PROTO
Xint resolve_name(hname, ph, silent)
Xchar* hname;
Xstruct hostent **ph;
Xint silent;
X#else
Xint resolve_name(char* hname, struct hostent **ph, int silent)
X#endif
X{
X    long addr;
X
X        if (isdigit(hname[0]))
X        {
X            addr = inet_addr(hname);
X            *ph = gethostbyaddr(&addr, 4, AF_INET);
X        }
X        else
X            *ph = gethostbyname(hname);
X
X        if (*ph == (struct hostent *)NULL)
X        {
X
X	  if ( silent == 0 )
X	    {
X#ifdef BSD42
X            fprintf(stderr,"host %s not found\n", hname);
X#else
X            switch (h_errno) {
X                case HOST_NOT_FOUND: fprintf(stderr,"host %s not found\n", hname);
X                                     break;
X                case TRY_AGAIN: fprintf(stderr,"Try again later\n");
X                                break;
X                case NO_RECOVERY: fprintf(stderr,"No recovery possible\n");
X                                  break;
X                case NO_ADDRESS: fprintf(stderr,"No IP address\n");
X                                 break;
X                default: fprintf(stderr,"Unknown error: %d\n", h_errno);
X                         break;
X            }
X#endif
X	  }
X
X            return 1;
X        }
X
X        (*ph)->h_addr[ (*ph)->h_length ] = NULL;
X
X        return 0;
X}
X
X#undef CLIENT
X#undef SERVER
X
X#endif
X
X/* filehdl.m4       Code for open, close, write, read  which access the
X                    low level system I/O
X
X	This file also implements interfaces to the following for TCP/IP
X	I/O, if the token TCP_IP is defined
X
X
X		LISTEN, ACCEPT (defined as SOCKET-ACCEPT to avoid
X		a confict with Forth's ACCEPT) and my TCP/IP socket
X		open routine SOPEN
X
X
X                      (c) Copyright 1994, Everett F. Carter Jr.
X                      Permission is granted by the author to use
X		      this software for any application provided this
X		      copyright notice is preserved.
X
X
X*/
X
Xstatic char rcsid1[] = "@(#)filehdl.m4	1.4 14:18:37 9/30/94   EFC";
X
X
X
X
X#include <stdio.h>
X#include <ctype.h>
X#include <errno.h>
X
X#include <sys/types.h>
X#include <sys/socket.h>
X#include <netinet/in.h>
X#include <netdb.h>
X#include <fcntl.h>
X
Xchar name[256];
X
X/* Usage:	s" fname" int_mode open, returns fh on success -1 on failure */
XCode (Open)
X{
X  char *fn = (char *)sp [2];    /* c-addr, name */
X  uCell u = sp [1];             /* length of name */
X  Cell fam = sp [0];            /* file access mode */
X  int fid;
X
X  if ( u > 0 )
X    memcpy (name, fn, u);
X  name[u] = '\0';
X
X  fid = open( name, fam);
X  sp += 2;
X  sp[0] = (Cell)fid;
X}
X
XCode (Open_Create)
X{
X
X  char *fn = (char *)sp [3];    /* c-addr, name */
X  uCell u = sp [2];             /* length of name */
X  Cell flags = sp[1];
X  Cell fam = sp [0];            /* file access mode */
X  int fid;
X
X  if ( u > 0 )
X    memcpy (name, fn, u);
X  name[u] = '\0';
X
X  fid = open( name, flags | O_CREAT, fam);
X  sp += 3;
X  sp[0] = (Cell)fid;
X
X}
X
X
XCode(Close)
X{
X	sp[0] = (Cell)close( sp[0] );
X}
X
XCode(Write)
X{
X        char *c_addr = (char *)sp[2];
X        uCell u = sp[1];
X        Cell  fid = sp[0];
X
X	sp += 2;
X	sp[0] = (Cell)write( fid, c_addr, u );
X}
X
X
XCode(Read)
X{
X        char *c_addr = (char *)sp[2];
X        uCell u = sp[1];
X        Cell  fid = sp[0];
X
X	sp += 2;
X	sp[0] = (Cell)read( fid, c_addr, u );
X
X}
X
X
X#ifdef __SC__
Xtypedef long off_t;
X#endif
X
XCode(Lseek)
X{
X        off_t offset;
X        int   fh, whence;
X        
X	whence = sp[1];
X        offset = (off_t) sp[2];         /* NOTE: ASSUMES off_t FITS IN ONE CELL!! */
X	fh = sp[0];
X
X	sp += 2;
X	sp[0] = (off_t)lseek( fh, offset, whence );
X
X}
X
X#ifdef TCP
X
XCode(Sopen)
X{
X  Cell kind = sp[0];
X  Cell port = sp[1];
X  char *fn = (char *)sp [3];    /* c-addr, name */
X  uCell u = sp [2];             /* length of name */
X
X
X  if ( u > 0 )
X    memcpy (name, fn, u);
X  name[u] = '\0';
X
X  sp += 3;
X
X
X	if ( u > 0 )
X	sp[0] = (Cell)tcp_open( name, port, (char *)NULL, kind );
X	else
X	sp[0] = (Cell)tcp_open( (char *)NULL, port, (char *)NULL, kind );
X}
X
X
XCode(Listen)
X{
X	int backlog, fh;
X
X	backlog = sp[1];
X	fh   = sp[0];
X
X	sp += 1;
X	sp[0] = (Cell)listen( fh, backlog );
X}
X
XCode(Socket_Accept)
X{
X	int fh, alen;
X	struct sockaddr *addr;
X
X	alen = sp[1];
X	addr  = (struct sockaddr *)sp[2];
X	fh   = sp[0];
X
X	sp += 2;
X	sp[0] = (Cell)accept( fh, addr, &alen );
X
X	/* S[-1] = alen; */
X}
X
X
X#endif
X
X
X#ifdef USE_XDR
X
X/* xdr.m4         Code to interface with XDR
X
X
X
X                      (c) Copyright 1994, Everett F. Carter Jr.
X                      Permission is granted by the author to use
X                      this software for any application provided this
X                      copyright notice is preserved.
X
X*/
X
Xstatic char rcsid_xdr[] = "@(#)xdr.m4	1.2 15:28:32 9/29/94   EFC";
X
X#include <fcntl.h>
X#include <rpc/rpc.h>
X
X#ifdef CRAY
X#define char_type   signed char
X#else
X#define char_type   char
X#endif
X
Xstatic XDR xdrs[2];
X
X/* initialize the XDR buffer and associate it with the specified buffer */
XCode(XDR_Buffer_Init)
X{
X	u_int size;
X	char *addr;
X	enum xdr_op op;
X	int idx;
X
X	op = sp[0];
X	size = sp[1];
X	addr  = (char *)sp[2];
X
X	sp += 3;
X
X	if ( op == XDR_ENCODE )
X		idx = 0;
X	else
X		idx = 1;
X
X	xdrmem_create( &xdrs[idx], addr, size, op );
X
X
X}
X
XCode(XDR_Rewind)      /* rewind XDR buffer for READERS ONLY */
X{
X	xdr_setpos( &xdrs[1], 0 );
X
X}
X
X
X/* Conversions between XDR and ThisForth native data types */
X
XCode(XDR2L)      /* convert from XDR to LONG INT */
X{
X	long int i;
X
X	xdr_long( &xdrs[1], &i );
X	xdr_setpos( &xdrs[1], 0 );
X
X	*--sp = (Cell)i;
X
X}
X
X
XCode(L2XDR)      /* convert from INT to XDR */
X{
X	long int i;
X
X	i = sp[0];
X	sp++;
X
X	xdr_setpos( &xdrs[0], 0 );
X	xdr_long( &xdrs[0], &i );
X
X}
X
X
XCode(XDR2UL)      /* convert from XDR to UNSIGNED LONG INT */
X{
X	unsigned long int i;
X
X	xdr_u_long( &xdrs[1], &i );
X	xdr_setpos( &xdrs[1], 0 );
X
X	*--sp = (Cell)i;
X
X}
X
X
XCode(UL2XDR)      /* convert from UNSIGNED LONG INT to XDR */
X{
X	unsigned long int i;
X
X	i = (unsigned long int)sp[0];
X	sp++;
X
X	xdr_setpos( &xdrs[0], 0 );
X	xdr_u_long( &xdrs[0], &i );
X
X}
X
XCode(XDR2F)      /* convert from XDR to DOUBLE FLOAT */
X{
X	double x;
X
X	xdr_double( &xdrs[1], &x );
X	xdr_setpos( &xdrs[1], 0 );
X
X	*--fp = x;
X
X}
X
XCode(F2XDR)      /* convert from DOUBLE FLOAT to XDR */
X{
X	double x;
X
X	x = fp[0];
X	fp++;
X
X	xdr_setpos( &xdrs[0], 0 );
X	xdr_double( &xdrs[0], &x );
X
X}
X
XCode(XDR2STR)      /* convert from XDR to Forth string */
X{                         
X	char *spp;
X	u_int sizep, maxsize;
X
X	sizep = maxsize = sp[0] + sizeof( u_int );
X	spp  = (char *)sp[1];
X
X	xdr_bytes( &xdrs[1], &spp, &sizep, maxsize );
X	xdr_setpos( &xdrs[1], 0 );
X
X	sp[0] = sizep - sizeof( u_int );
X}
X
X
XCode(STR2XDR)      /* convert from Forth string to XDR */
X{
X	char *spp;
X	u_int sizep, maxsize;
X
X	sizep = maxsize = sp[0] + sizeof( u_int );
X	spp  = (char *)sp[1];
X
X	xdr_setpos( &xdrs[0], 0 );
X	xdr_bytes( &xdrs[0], &spp, &sizep, maxsize );
X
X	sp++;
X	sp[0] = sizep;
X
X}
X
X
X/* conversions between XDR and non-ThisForth data types, converted to/from
X   corresponding ThisForth data types */
X
XCode(XDR2C)      /* convert from XDR to CHAR */
X{
X	char c;
X
X	xdr_char( &xdrs[1], &c );
X	xdr_setpos( &xdrs[1], 0 );
X
X	*--sp = (Cell)c;
X
X}
X
XCode(C2XDR)      /* convert from CHAR to XDR */
X{
X	char c;
X
X	c = (char)sp[0];
X	sp++;
X
X	xdr_setpos( &xdrs[0], 0 );
X	xdr_char( &xdrs[0], &c );
X
X}
X
XCode(XDR2I)      /* convert from XDR to INT */
X{
X	int i;
X
X	xdr_int( &xdrs[1], &i );
X	xdr_setpos( &xdrs[1], 0 );
X
X	*--sp = (Cell)i;
X
X}
X
XCode(I2XDR)      /* convert from INT to XDR */
X{
X	int i;
X
X	i = (int)sp[0];
X	sp++;
X
X	xdr_setpos( &xdrs[0], 0 );
X	xdr_int( &xdrs[0], &i );
X
X}
X
XCode(XDR2UI)      /* convert from XDR to UNSIGNED INT */
X{
X	unsigned int i;
X
X	xdr_u_int( &xdrs[1], &i );
X	xdr_setpos( &xdrs[1], 0 );
X
X	*--sp = (Cell)i;
X
X}
X
XCode(UI2XDR)      /* convert from UNSIGNED INT to XDR */
X{
X	unsigned int i;
X
X	i = (unsigned int)sp[0];
X	sp++;
X
X	xdr_setpos( &xdrs[0], 0 );
X	xdr_u_int( &xdrs[0], &i );
X
X}
X
XCode(XDR2SI)      /* convert from XDR to SHORT INT */
X{
X	short int i;
X
X	xdr_short( &xdrs[1], &i );
X	xdr_setpos( &xdrs[1], 0 );
X
X	*--sp = (Cell)i;
X
X}
X
XCode(SI2XDR)      /* convert from SHORT INT to XDR */
X{
X	short int i;
X
X	i = (short int)sp[0];
X	sp++;
X
X	xdr_setpos( &xdrs[0], 0 );
X	xdr_short( &xdrs[0], &i );
X
X}
X
XCode(XDR2SF)      /* convert from XDR to SINGLE FLOAT */
X{
X	float x;
X
X	xdr_float( &xdrs[1], &x );
X	xdr_setpos( &xdrs[1], 0 );
X
X	*--fp = x;
X
X}
X
X
XCode(SF2XDR)      /* convert from SINGLE FLOAT to XDR */
X{
X	float x;
X
X	x = fp[0];
X	fp++;
X
X	xdr_setpos( &xdrs[0], 0 );
X	xdr_float( &xdrs[0], &x );
X
X}
X
X
XCode(XDR2CSTR)      /* convert from XDR to C string */
X{                         
X	char *spp;
X	u_int maxsize;
X
X
X	maxsize = sp[0] + sizeof( u_int );
X        spp = name;
X
X        /* note: presumes that name is big enough */
X	xdr_string( &xdrs[1], &spp, maxsize + 1 );
X	xdr_setpos( &xdrs[1], 0 );
X
X	maxsize = strlen( name );
X
X
X	/* convert NUL-terminated string to Forth string */
X        memcpy ( (char *)sp[1], name, maxsize);
X
X	sp[0] = maxsize;         /* return actual count */
X}
X
XCode(CSTR2XDR)      /* convert from C string to XDR */
X{
X        char *spp;
X	u_int maxsize;
X	maxsize = sp[0];
X
X        spp = name;
X
X	/* Make NUL-terminated string, presumes name is big enough */
X        memcpy( name, (char *)sp[1], maxsize );
X        name[ maxsize ] = '\0';
X
X	xdr_setpos( &xdrs[0], 0 );
X	xdr_string( &xdrs[0], &spp, maxsize + 1 );
X
X	++sp;
X	sp[0] = strlen( name ) + sizeof( u_int ) + 1;
X}
X
X#endif
X
X
XLISTWORDS (your) =
X{
X  CO ("USER-ADDED-PRIMITIVE", user_added_primitive),
X  CO ("GETENV", GetEnv),
X  CO ("OPEN", Open),
X  CO ("OPEN-CREATE", Open_Create),
X  CO ("CLOSE", Close),
X  CO ("WRITE", Write),
X  CO ("READ", Read),
X  CO ("LSEEK", Lseek),
X#ifdef TCP
X  CO ("SOPEN", Sopen),
X  CO ("LISTEN", Listen),
X  CO ("SOCKET-ACCEPT", Socket_Accept),
X#endif
X#ifdef USE_XDR
X  CO ("XDR-BUFFER-INIT", XDR_Buffer_Init),
X  CO ("XDR-REWIND", XDR_Rewind),
X  CO ("XDR->L",    XDR2L),
X  CO ("L->XDR",    L2XDR),
X  CO ("XDR->UL",   XDR2UL),
X  CO ("UL->XDR",   UL2XDR),
X  CO ("XDR->F",    XDR2F),
X  CO ("F->XDR",    F2XDR),
X  CO ("XDR->STR",  XDR2STR),
X  CO ("STR->XDR",  STR2XDR),
X  CO ("XDR->C",    XDR2C),
X  CO ("C->XDR",    C2XDR),
X  CO ("XDR->I",    XDR2I),
X  CO ("I->XDR",    I2XDR),
X  CO ("XDR->UI",   XDR2UI),
X  CO ("UI->XDR",   UI2XDR),
X  CO ("XDR->SI",   XDR2SI),
X  CO ("SI->XDR",   SI2XDR),
X  CO ("XDR->SF",   XDR2SF),
X  CO ("SF->XDR",   SF2XDR),
X  CO ("XDR->CSTR", XDR2CSTR),
X  CO ("CSTR->XDR", CSTR2XDR),
X#endif
X};
XCOUNTWORDS (your, "Your kernel extensions");
SHAR_EOF
chmod 0444 mine.c || echo "restore of mine.c fails"
echo "x - extracting fcntl.fo (Text)"
sed 's/^X//' << 'SHAR_EOF' > fcntl.fo &&
X( FCNTL.FO V1.0         The constants used for the low level file I/O words )
X
X( WARNING: These values are what is used on the MIPS Workstation,
X           they may have to be modified for other platforms )
X
X
X( constants used by OPEN )
X
X   0 CONSTANT O_RDONLY       \ open for reading only
X   1 CONSTANT O_WRONLY       \ open for writing only
X   2 CONSTANT O_RDWR         \ open for reading and writing
X   4 CONSTANT O_NDELAY       \ do not block on open
X   8 CONSTANT O_APPEND       \ append on each write
X 256 CONSTANT O_CREAT        \ create file if it does not exist
X 512 CONSTANT O_TRUNC        \ truncate size to 0
X1024 CONSTANT O_EXCL         \ error if create and file exists
X
X
X( constants used by LSEEK )
X
X   0 CONSTANT L_SET          \ absolute offset, set file pointer directly
X   1 CONSTANT L_INCR         \ relative offset, increment file pointer
X   2 CONSTANT L_XTND         \ relative to end of file,
X			     \ ( set file pointer to specified distance beyond EOF )
X
X( common alternative names to the above 3 )
X
X   L_SET  CONSTANT SEEK_SET
X   L_INCR CONSTANT SEEK_CUR
X   L_XTND CONSTANT SEEK_END
X
X
SHAR_EOF
chmod 0644 fcntl.fo || echo "restore of fcntl.fo fails"
echo "x - extracting sopen.h (Text)"
sed 's/^X//' << 'SHAR_EOF' > sopen.h &&
X/* sopen.h         prototypes for TCP and UDP socket open calls
X
X           This code is partly based upon code in:
X
X
X           W. Richard Stevens, 1990; Unix Network Programming,
X           Prentice-Hall, Englewood Cliffs, N.J., 772 pages
X
X
Xrcsid: @(#)sopen.h	1.1 00:36:18 2/8/94   EFC
X
X*/
X
X#ifndef SOPEN_H_
X#define SOPEN_H_ 1.1
X
X#include <sys/types.h>
X#include <sys/socket.h>
X#include <netinet/in.h>
X
X
Xextern struct sockaddr_in       udp_srv_addr;
Xextern struct sockaddr_in       udp_cli_addr;
X
X#ifdef __cplusplus
Xextern "C" {
X#endif
X
X#ifdef NO_PROTO
Xint tcp_open();
Xint udp_open();
Xint resolve_name();
X#else
Xint tcp_open(char* hostname, int port, char* service, int kind);
Xint udp_open(char *hostname, int port, char* service, int dontconn);
Xint resolve_name(char* hname, struct hostent **ph, int silent);
X#endif
X
X#ifdef __cplusplus
X}
X#endif
X
X#endif
SHAR_EOF
chmod 0444 sopen.h || echo "restore of sopen.h fails"
echo "x - extracting server.fo (Text)"
sed 's/^X//' << 'SHAR_EOF' > server.fo &&
X( Example server code,
X                  just accept some data and echo it back with the
X		  sign changed
X
X                      Copyright 1994, Everett F. Carter Jr.
X                      Permission is granted by the author to use
X		      this software for any application provided this
X		      copyright notice is preserved.
X
X
X
X	example usage:    3145 server
X
X)
X
X\        @(#)server.fo	1.3 12:18:54 11/17/94   EFC
X
XVARIABLE sock
XVARIABLE local
XVARIABLE from  16 ALLOT           \ MAKE SURE THIS IS BIG ENOUGH FOR YOUR SYSTEM !!
X                                  \ (see documentation on SOCKET-ACCEPT)
X
XVARIABLE data
X
XVARIABLE verbose         0 verbose !     \ turn this on if you want server
X                                         \ write to standard output
X
X: server ( port -- )
X
X       0 0 ROT 1 sopen
X
X       DUP sock !
X       
X       0< ABORT" unable to open socket as server "
X
X      
X       5 sock @  listen
X
X       0< ABORT" listen failed "
X
X       verbose @ IF
X       			." sock = "  sock @ . CR
X		 THEN
X
X       ( now we wait for the client to connect )
X       from 16 sock @ socket-accept
X
X       DUP local !
X
X       0< ABORT" accept failed "
X
X
X       verbose @ IF  
X       			." local = "  local @ . CR
X		 THEN
X
X
X      sock @ close DROP   ( not going to listen for more connections )
X
X
X
X      ( send a welcome message to the client )
X      s" Welcome to Internetworking with Forth !"
X      DUP data !
X      data 1 CELLS local @ write DROP    ( first write the string length )
X      local @ write                      ( now write the string )
X
X      verbose @ IF
X      			." (wrote " . ." bytes of message) " CR
X                ELSE
X                        DROP
X		THEN
X
X
X      ( read the number of points the remote is going to send )
X      data 1 CELLS local @ read
X
X      verbose @ IF
X      			." (read " . ." bytes)   value: "  data ? CR
X                ELSE
X                        DROP
X		THEN
X
X
X      ( read the data from the remote, change it sign and send it back )
X      data @ 0 DO
X
X      			data 1 CELLS local @ read
X			verbose @ IF
X      				." (read " . ." bytes)   value: "  data ? CR
X                                  ELSE
X                                     DROP
X			          THEN
X
X      			data @ -1 * data !
X
X      			data 1 CELLS local @ write
X
X			verbose @ IF
X      				    ." (wrote " . ." bytes) " CR
X                                  ELSE
X                                    DROP
X			          THEN
X		LOOP
X
X
X
X	local @ close  DROP
X
X
X	( This demonstration code, just services one request
X          and then exits )
X
X;
X
SHAR_EOF
chmod 0444 server.fo || echo "restore of server.fo fails"
echo "x - extracting client.fo (Text)"
sed 's/^X//' << 'SHAR_EOF' > client.fo &&
X( Example client code, just get message from the server
X                       then write some data to the server and
X                       get its response.
X
X                      Copyright 1994, Everett F. Carter Jr.
X                      Permission is granted by the author to use
X		      this software for any application provided this
X		      copyright notice is preserved.
X
X
X
X	s" taygeta.oc.nps.navy.mil" 3145 client
X
X)
X
X\        @(#)client.fo	1.3 12:18:39 11/17/94   EFC
X
XVARIABLE sock
X
XVARIABLE data
X5 CONSTANT numdat
X
X: client ( port -- )
X
X
X       0 sopen
X
X       DUP sock !
X       
X       0< ABORT" unable to open socket as client"
X
X      ( read the welcome message from the server )
X      data 1 CELLS sock @ read   DROP
X
X      PAD data @ sock @ read     DROP
X
X      PAD data @ TYPE CR         ( echo it to the screen )
X
X
X
X     ( now just send some data back and forth )
X            
X      numdat data !
X
X
X       ( tell the server how much data we are going to send )
X       data 1 CELLS sock @ write
X       
X      ." (wrote " . ." bytes) " CR
X
X
X      ( now send the data, one at a time, and print the returned data )
X      numdat 0 DO
X           I 1+ data !
X           data 1 CELLS sock @ write
X
X           ." (wrote " . ." bytes) " I 1+ . CR
X
X	   data 1 cells sock @ read
X
X           ." (read " . ." bytes)   value: "  data ?  CR
X
X      LOOP
X
X      sock @ close   DROP
X
X;
X
X
X
X
SHAR_EOF
chmod 0444 client.fo || echo "restore of client.fo fails"
echo "x - extracting xdr.fo (Text)"
sed 's/^X//' << 'SHAR_EOF' > xdr.fo &&
X( XDR.FO V1.0         The constants for XDR )
X
X( WARNING: These values are what is used on the MIPS Workstation,
X           they may have to be modified for other platforms )
X
X
X
X0 CONSTANT XDR_ENCODE
X1 CONSTANT XDR_DECODE
X2 CONSTANT XDR_FREE
X
X4 CONSTANT BYTES_PER_XDR_UNIT
X
SHAR_EOF
chmod 0644 xdr.fo || echo "restore of xdr.fo fails"
echo "x - extracting serverx.fo (Text)"
sed 's/^X//' << 'SHAR_EOF' > serverx.fo &&
X( Example server code,
X                  just accept some data and echo it back with the
X		  sign changed
X
X                  Uses XDR
X
X                      Copyright 1994, Everett F. Carter Jr.
X                      Permission is granted by the author to use
X		      this software for any application provided this
X		      copyright notice is preserved.
X
X
X
X	example usage:
X
X	3146 serverx
X
X)
X
X\        @(#)serverx.fo	1.3 12:19:01 11/17/94   EFC
X
XVARIABLE sock
XVARIABLE local
XVARIABLE from  16 ALLOT         \ MAKE SURE THIS IS BIG ENOUGH FOR YOUR SYSTEM !!
X                                \ (see documentation on SOCKET-ACCEPT)
X
XVARIABLE data
X
XVARIABLE verbose         0 verbose !     \ turn this on if you want server
X                                         \ write to standard output
X
X128 CONSTANT bufsize
XCREATE tx_buffer bufsize ALLOT
XCREATE rc_buffer bufsize ALLOT
X
X: float-test ( socket -- )
X
X        ( get a floating point value and echo it back after negation )
X
X        rc_buffer BYTES_PER_XDR_UNIT 2 PICK read
X        XDR->F
X
X	verbose @ IF
X      			." (read " . ." bytes)   value: "  FDUP F. CR
X                  ELSE
X                        DROP
X		  THEN
X
X        FNEGATE
X
X        F->XDR
X        tx_buffer BYTES_PER_XDR_UNIT ROT write
X
X	verbose @ IF
X      			." (wrote " . ." bytes) " CR
X                  ELSE
X                        DROP
X                  THEN
X
X;
X
X: serverx ( port -- )
X
X       0 0 rot 1 sopen
X
X       DUP sock !
X       
X       0< ABORT" unable to open socket as server "
X
X
X       ( set up the XDR buffers, one for receiving and one for transmitting )
X
X       rc_buffer bufsize XDR_DECODE XDR-BUFFER-INIT
X       tx_buffer bufsize XDR_ENCODE XDR-BUFFER-INIT
X      
X       5 sock @ listen
X
X       0< ABORT" listen failed "
X
X       verbose @ IF
X       			." sock = "  sock @ . CR
X		 THEN
X
X       ( now we wait for the client to connect )
X       from 16 sock @ socket-accept
X
X       DUP local !
X
X       0< ABORT" accept failed "
X
X
X       verbose @ IF  
X       			." local = "  local @ . CR
X		 THEN
X
X
X      sock @ close DROP   ( not going to listen for more connections )
X
X
X
X      ( send a welcome message to the client )
X      s" Welcome to Internetworking with Forth !" STR->XDR     \ encode the string
X
X      tx_buffer SWAP local @ write        ( write the string )
X
X      verbose @ IF
X      			." (wrote " . ." bytes of message) " CR
X                ELSE
X                        DROP
X		THEN
X
X
X      ( read the number of points the remote is going to send )
X      rc_buffer BYTES_PER_XDR_UNIT local @ read
X
X      XDR->I data !
X      
X      verbose @ IF
X      			." (read " . ." bytes)   value: "  data ? CR
X                ELSE
X                        DROP
X		THEN
X
X
X      ( read the data from the remote, change it sign and send it back )
X      data @ 0 DO
X
X      			rc_buffer BYTES_PER_XDR_UNIT local @ read
X                        XDR->I data !
X
X			verbose @ IF
X      				." (read " . ." bytes)   value: "  data ? CR
X                                  ELSE
X                                     DROP
X			          THEN
X
X      			data @ -1 * I->XDR
X
X      			tx_buffer BYTES_PER_XDR_UNIT local @ write
X
X			verbose @ IF
X      				    ." (wrote " . ." bytes) " CR
X                                  ELSE
X                                    DROP
X			          THEN
X		LOOP
X
X
X	local @ float-test     \ get and echo back some floating point data
X
X
X
X	local @ close  DROP
X
X
X	( This demonstration code, just services one request
X          and then exits )
X
X;
X
SHAR_EOF
chmod 0444 serverx.fo || echo "restore of serverx.fo fails"
echo "x - extracting clientx.fo (Text)"
sed 's/^X//' << 'SHAR_EOF' > clientx.fo &&
X( Example client code, just get message from the server
X                       then write some data to the server and
X                       get its response.
X
X
X			Uses XDR
X
X
X                      Copyright 1994, Everett F. Carter Jr.
X                      Permission is granted by the author to use
X		      this software for any application provided this
X		      copyright notice is preserved.
X
X
X
X	example usage:
X
X
X	s" taygeta.oc.nps.navy.mil" 3146 clientx
X
X)
X
X\        @(#)clientx.fo	1.3 12:18:48 11/17/94   EFC
X
XVARIABLE sock
X
X5 CONSTANT numdat
X
X128 CONSTANT bufsize
XCREATE tx_buffer bufsize ALLOT
XCREATE rc_buffer bufsize ALLOT
X
X: Read-String ( fh -- )           \ read a counted string
X
X        rc_buffer BYTES_PER_XDR_UNIT 2 PICK read      \ read the byte count
X                                                \ this count INCLUDES the byte count
X        0< ABORT" read failure (1) "
X
X
X        \ read the character data into the buffer after the count
X        \ note the use of XDR->UI to determine how many bytes to read
X        \ (XDR->UI - BYTES_PER_XDR_UNIT).
X        \ For XDR counted strings, the byte count includes the space for
X        \ the byte count itself.
X
X        rc_buffer BYTES_PER_XDR_UNIT + XDR->UI BYTES_PER_XDR_UNIT - ROT read
X
X
X        DUP 0< ABORT" read failure (2) "
X
X        PAD SWAP XDR->STR      \ convert the data to a Forth string
X
X        TYPE
X
X;
X
X: float-test ( socket -- ) ( f: x -- )
X
X      ." sending floating point number " FDUP F.
X
X      F->XDR
X
X      tx_buffer BYTES_PER_XDR_UNIT 2 PICK write
X       
X      ." (wrote " . ." bytes) " CR
X
X      rc_buffer BYTES_PER_XDR_UNIT ROT read
X
X      ." (read " . ." bytes)   value: "  XDR->F F.  CR
X
X;
X
X: clientx ( addr count port -- )
X
X       0 sopen
X
X       DUP sock !
X       
X       0< ABORT" unable to open socket as client "
X
X       ( set up the XDR buffers, one for receiving and one for transmitting )
X
X       rc_buffer bufsize XDR_DECODE XDR-BUFFER-INIT
X       tx_buffer bufsize XDR_ENCODE XDR-BUFFER-INIT
X
X
X
X
X      ( read the welcome message from the server and echo it to the screen )
X      sock @ Read-String
X
X
X     ( now just send some data back and forth )
X            
X       ( tell the server how much data we are going to send )
X      numdat I->XDR
X
X      tx_buffer BYTES_PER_XDR_UNIT sock @ write
X       
X      ." (wrote " . ." bytes) " CR
X
X
X      ( now send the data, one at a time, and print the returned data )
X      numdat 0 DO
X
X           I 1+ I->XDR
X           tx_buffer BYTES_PER_XDR_UNIT sock @ write
X
X           ." (wrote " . ." bytes) " I 1+ . CR
X
X	   rc_buffer BYTES_PER_XDR_UNIT sock @ read
X
X           ." (read " . ." bytes)   value: "  XDR->I .  CR
X
X      LOOP
X
X      \ try sending and getting floating point data
X      sock @ 3.14159E0 float-test
X
X
X      sock @ close   DROP
X
X;
X
SHAR_EOF
chmod 0444 clientx.fo || echo "restore of clientx.fo fails"
echo "x - extracting xdr-test.fo (Text)"
sed 's/^X//' << 'SHAR_EOF' > xdr-test.fo &&
X( XDR test code   )
X(
X xrdr    reads a file using XDR and sends it to the screen
X xwrt    writes a file using XDR
X
X To use XDR with TCP/IP sockets, just replace the OPEN/OPEN-CREATE lines
X below with the appropriate SOPEN line. Nothing else needs to be changed.
X
X)
X 
XVARIABLE fh
X32 CONSTANT bufsize
XCREATE buffer bufsize ALLOT
X
X
X: Read-String ( fh -- )           \ read a counted string
X
X        DUP buffer BYTES_PER_XDR_UNIT read      \ read the byte count
X                                                \ this count INCLUDES the byte count
X	0< ABORT" read failure (1) "
X
X
X        \ read the character data into the buffer after the count
X        \ note the use of XDR->UI to determine how many bytes to read
X	\ (XDR->UI - BYTES_PER_XDR_UNIT).
X        \ For XDR counted strings, the byte count includes the space for
X        \ the byte count itself.
X
X        buffer BYTES_PER_XDR_UNIT + XDR->UI BYTES_PER_XDR_UNIT - read
X
X
X	DUP 0< ABORT" read failure (2) "
X
X
X        pad SWAP XDR->STR      \ convert the data to a Forth string
X
X        TYPE
X
X;
X
X: Read-CString ( fh -- )           \ read a counted string
X
X        DUP buffer BYTES_PER_XDR_UNIT read         \ read the byte count
X
X	0< ABORT" read failure (1) "
X
X
X        \ read the data, note that the byte count is incremented by one in
X        \ order to account for the terminating NULL which must be read.
X	\ So the number of bytes to read is XDR->UI + 1
X
X        buffer BYTES_PER_XDR_UNIT + XDR->UI 1+ read
X
X
X	DUP 0< ABORT" read failure (2) "
X
X        DUP . ." characters read, now converting " CR
X
X        pad SWAP XDR->CSTR      \ convert the data to a Forth string
X
X        TYPE
X
X;
X
X: xrdr ( str_addr count -- )
X
X         O_RDONLY open fh !
X
X	fh @ 0< ABORT" unable to open file "
X
X
X        buffer bufsize XDR_DECODE XDR-BUFFER-INIT
X
X        ( now read in integer, a float, a double float and another integer )
X        fh @ buffer BYTES_PER_XDR_UNIT read
X
X        0< ABORT" read failure "
X
X
X        XDR->I .          
X
X        fh @ buffer BYTES_PER_XDR_UNIT read
X
X        0< ABORT" read failure "
X
X
X        XDR->SF F.         
X
X        fh @ buffer BYTES_PER_XDR_UNIT read
X
X        0< ABORT" read failure "
X
X
X        XDR->F F.          
X
X
X        fh @ buffer BYTES_PER_XDR_UNIT read
X
X        0< ABORT" read failure "
X
X
X        XDR->I .           
X
X
X        \ now read a counted string
X	fh @ Read-String
X
X        CR
X
X	fh @ Read-CString
X
X        CR
X
X        fh @ buffer BYTES_PER_XDR_UNIT read
X
X        0< ABORT" read failure "
X
X
X        XDR->I .           
X
X        fh @ close DROP
X
X;
X
X
X: xwrt ( str_addr count -- )
X
X         O_WRONLY O_CREAT OR  438  open-create fh !      \ 438 = octal 666, rwrwrw
X
X	fh @ 0< ABORT" unable to open file "
X
X
X        buffer bufsize XDR_ENCODE XDR-BUFFER-INIT
X
X        ( now write integer, a float, a double float and another integer )
X	." Writing to the file:  1234 3.14159 2.71828 -5678 "
X
X	1234 I->XDR
X        fh @ buffer BYTES_PER_XDR_UNIT write
X
X        0< ABORT" write failure "
X
X	3.14159E SF->XDR
X        fh @ buffer BYTES_PER_XDR_UNIT write
X
X        0< ABORT" write failure "
X
X
X	2.71828E F->XDR
X
X        fh @ buffer BYTES_PER_XDR_UNIT write
X
X        0< ABORT" write failure "
X
X
X        -5678 I->XDR
X
X        fh @ buffer BYTES_PER_XDR_UNIT write
X
X        0< ABORT" write failure "
X
X        \ now write a counted string
X        s" XDR and Forth" STR->XDR
X     
X        fh @ buffer ROT write
X
X        CR
X        . ."  byte string (including count) 'XDR and Forth' written "
X
X
X	\ now write a counted string as a C string
X	s" This is a C string" CSTR->XDR
X        fh @ buffer ROT write
X
X         
X         CR
X
X        . ."  byte string (including count) 'This is a C string' written " CR
X
X
X	\ write one more integer for good measure
X        21845         ." Finally writing 21845 " CR
X	I->XDR
X
X        fh @ buffer BYTES_PER_XDR_UNIT write
X
X        0< ABORT" write failure "
X
X         fh @ close DROP
X
X;
X
X
SHAR_EOF
chmod 0644 xdr-test.fo || echo "restore of xdr-test.fo fails"
exit 0
