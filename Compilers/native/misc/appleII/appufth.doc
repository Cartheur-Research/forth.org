                      THE UNIFORTH SAMPLER     The  UNIFORTH Sampler is a subset of the  full  Professional UNIFORTH.   It  provides  a  full  assembler,  video  editor  and software  floating-point  arithmetic.   It supports the  FORTH-83 Standard  with few exceptions.   You will find the Sampler to  be the equivalent of several commercial systems selling for $200  or more.     We decided to release the Sampler into the public domain for several reasons.   First, distributing a version of UNIFORTH that is  useful,  inexpensive  and  reproducible is  a  cost-effective method  of advertising.   Second,  it gives you a chance to try a good FORTH system at no cost.   If you don't like it, you haven't spent a dime.   If you do like it,  we ask (but don't demand!)  a $25  donation,  most  of  which  will be  reinvested  in  product development  to  improve both the Sampler and  the  Professional.  Lastly,  the Sampler includes several novel features that we feel are  useful,   but  want  to  bring  before  the  community   for discussion.     You  are  encouraged to copy and distribute the  Sampler  to your friends and local bulletin boards.   You may use the Sampler as the underlying language for a commercial software product.  In return,  we hope that you will consider us when you need a  full-featured FORTH system or other options,  and that you will spread the word about UNIFORTH.     We  can  supply  you  with the latest disk  version  of  the Sampler  in your 5 1/4" or 8" (CP/M) format for $35,  or you  can obtain a copy from a friend or local bulletin board.  Consult the order form at the end for more details.     This  manual is a much-abbreviated edition of  the  UNIFORTH Manual Set.  (The complete set has over 500 pages, and comes in a custom  slipcase/binder.   Copies of the full set are $60.)  This manual  is  divided  into four  sections:   an  introduction  and advertisement  for the Professional;  a brief tutorial on  FORTH; some  of  the  system-specific  features  of  UNIFORTH;   and   a vocabulary list.     The  UNIFORTH  Sampler  is NOT a supported  product  and  is distributed without warranties of Merchantability and fitness for a  particular  purpose.    If  you  need  support,  purchase  the Professional UNIFORTH.1.1  Getting Started     The  Sampler is distributed on one disk.    You can use  the System  Utilities  Disk to make backup and  distribution  copies.  You will find on the disk the following files:     UNIFORTH.SYSTEM  The executable task image.      FORTH.FTH        The default file that is opened when UNIFORTH                       is executed.   It contains the SYSGEN utility                      and the low-resolution graphics utility.     UNIFORTH.DOC     This manual.     WORDS.DOC        The vocabulary word list.     README.1ST       If  present,  additional  information  that                       should be read before using the system.      All  of  the features of UNIFORTH are preconfigured  in  the task  image.   You  need  not "load" anything to have  a  working system.   UNIFORTH.SYSTEM requires a minimum of 48Kb user  space, and  requires an 80-column display and  ProDOS.   Therefore,  the system  should  be run only on the Apple //c or //e with  an  80-column card.     To  execute  UNIFORTH,  you must first make a ProDOS  system disk.   This  is done by copying PRODOS onto a freshly  formatted disk,  then copying UNIFORTH.SYSTEM and FORTH.FTH onto the  disk.  To  run UNIFORTH,  put the UNIFORTH system disk into the  default drive  and  turn on the computer or perform a forced  cold  start (open apple-CONTROL-RESET).      When  you execute UNIFORTH in this way,  you should get the Sampler startup screen.   If the screen is blank or your computer hangs up or you get message that no SYSTEM file was found,  check the  system disk;  you may have copied the files improperly.   If you get a message to the effect of a missing file and an  inquiry about  creating  it,  answer "N" and leave FORTH (with  the  word KILL)  at the earliest opportunity.   Then make sure FORTH.FTH is on the same disk as UNIFORTH.SYSTEM.     After  you get the "ok" prompt,  you're  into  FORTH.   Then follow  the  tutorial or an introductory text,  and learn  FORTH.       There  are three ways to exit UNIFORTH:   put a  new  system disk  in the default drive and do a forced cold start;  enter the word  KILL (which has the same effect as the forced cold  start); or enter BYE (which flushes and closes files before exiting).                           Chapter 2                           USING FORTH     The  first  concept  to  understand in using  FORTH  is  the entering  and  execution  of words  through  the  terminal.   The general rules are:     1.   FORTH does not interpret a line of user input until the           user  terminates the line by entering a carriage return           (<cr>).     2.   You  may  delete the previous character by  entering  a           backspace (ASCII 08) or delete (ASCII 127).   An  ASCII           "bell" character will be output if you try to backspace           past the beginning of the line.     3.   You may delete an entire line by entering a CTRL-U (the           CTRL and U keys depressed simultaneously).     4.   The user may interrupt printout at any time by entering           CTRL-S.    The  printout  is  resumed  when  CRTL-Q  is           pressed.  (Some systems permit any key for resumption.)     5.   You  can  abort  a task that is  actively  printing  by           pressing the ESCAPE key.After pressing the return key to terminate a line of input, FORTH will  go  through the line and execute every "word" in the  input line.  The definition of a FORTH word is very simple:                      <<<WORD DEFINITION>>>               A FORTH word is a sequence of up to               64  characters,  with  at least one               blank (space) on  each  side.   The               sequence  of characters may contain               any  character  in  the  ASCII  set               except      control     characters.               UNIFORTH  retains  only the   first               31 characters  and  the  length  of               the word;  any word longer than  31               characters is truncated.For example, entering the line          ok 3 4 + LIST <cr>will cause FORTH to execute the four "words"          3          (push the number 3 on the stack)          4          (push the number 4 on the stack)          +          (add them together to get 7)          LIST       (and then list block 7)Notice the spaces between the words on the input line.  You don't need to type spaces before the first word or after the last  one. The  words are executed in the order in which they were  entered. The actual execution of each word will be discussed later.     If  all goes well and FORTH successfully executes each  word in the input line,  then FORTH will respond with its prompt (ok). If  an error occurs,  the name of the word it was executing  when the error occurred will be repeated, followed by a question mark.2.1  The Stack     To  see  how  FORTH does such things as  manipulating  data, controlling  devices,  printing and accepting user's  input,  and managing  files,  you will have to understand the mechanism  that FORTH uses to keep track of the work in progress:  the STACK.     A stack (sometimes called last-in-first-out or LIFO  memory) is  a  device used largely in  compiler  writing,  microprocessor design,  and HP calculators.  A stack can best be compared to the tray holders commonly used in cafeterias:  the type with a spring at  the bottom to push up trays as they are used.   Only the tray most recently added is accessable;  it must be removed before thetrays below it are available.       To see how this relates to FORTH, we need to experiment from a terminal.   If you type a carriage return,  FORTH will  respond with          okto  indicate that it has completed your previous request (in this case,  you requested nothing) and is ready to do  more.   Suppose you type a number:          ok  5 <cr>          okFORTH  has apparently done nothing;   however,  it has taken your number  (5),  interpreted it as the numeric value 5 (rather  than some other word), and "pushed" it onto the stack (added a tray to the holder).     Suppose you type a series of numbers,  separated by at least one space so FORTH can tell them apart.   Basic FORTH only under-stands 16-bit integers,  i.e.   numbers between -32768 and  32767 with  no  decimal  points or other punctuation except  a  leading minus sign for negative numbers:          ok 4 1 2 7 -23 6 <cr>(We'll  tell  you  about other number types later.)  FORTH  still doesn't  seem to have done anything,  but the stack now  contains the original number 5,  plus 6 new numbers,  with the "top" value being the number 6.     Obviously something is missing:   a method of removing  data from the stack and doing something useful with it.   The simplest thing  that  can be done with the stack is to see what's  on  top (easiest to get at).   FORTH has a word,  "." (dot),  which takes the  number  on the top of the stack,  prints its  value  on  the terminal,  and  throws the number away.   (We will enclose  FORTH words in quotes whenever confusion is possible).   For an example of dot:          ok 8 .  <cr>          8          okwill take the number 8,  push it on the stack,  then print it and prompt for more input.  Another example,          ok 8 7 .  CR .  <cr>          7          8          ok will type the two top stack values on separate lines.   CR is our second learned FORTH word:  it just outputs a carriage return and line feed to the terminal.2.2  Stack Operators     So  far we can only get to the topmost stack value.   As  on the HP calculators,  there are words that allow us to  manipulate the stack to get at other values.   The table below lists some of the  most important operators.   For this and subsequent  tables, the topmost stack value is indicated by A,  the next stack  value by B,  and so on.   The table gives the word, its function, and a representation of the stack before and after the use of the word.     WORD          FUNCTION         BEFORE    AFTER     DUP        copies top of stack    B A     B A A     SWAP       reverses top two       B A     A B                numbers on the stack     DROP       destroys top of stack  B A     B     OVER       copies 2nd number and  B A     B A B                 pushes it on top     ROT        moves 3rd num to top   C B A   B A C     -ROT       moves top to 3rd num   C B A   A C B     The  usefulness  of these stack manipulation  words  becomes apparent  when  you  consider  the  following  problem:   suppose someone  else  has  put  a number on the stack and  you  wish  to calculate its square without knowing what it is.  You could type     ok  DUP * . <cr>     25     ok By inference,  the number on the stack was 5.  Of course, we used a  word  not defined yet to multiply the two  values.   So  let's digress and discuss arithmetic functions.2.3  Arithmetic Functions     All  arithmetic  functions act on the stack  with  a  method called  postfix or Reverse Polish Notation (RPN),  commonly  used with the HP calculators.  Rather than give extensive examples, we will  assume  that you have used an RPN calculator at some  time, and just give a table of the elementary functions.     WORD       FUNCTION                BEFORE   AFTER     ABS       absolute value of top       B A    B |A|               of stack     NEGATE    2's complement top          B A    B -A               of stack     +         add top stack values        B A    B+A     -         sub top stack values        B A    B-A     *         mul top stack values        B A    B*A      /         div top stack values        B A    B/A       MOD       remainder of division     C B A    C R               of B/A     MAX       top two numbers dropped,  C B A    C MAX(A,B)               larger one put back     MIN       top two numbers dropped,  C B A    C MIN(A,B)               smaller one put backAn  example of the use of some of these functions is to  evaluate the expression                       ABS [(5+4)/2 - 20]You would enter it with FORTH by          ok  5 4 + 2 / 20 - ABS . <cr>          16          okNote  that  the division truncates because we are  using  integer arithmetic.2.4  Logical Operators     The  logical  operators act upon all 16 of the  bits  in  an integer  and leave results which involve all those  bits.   There are  four basic operators,  three of which require two numbers on the stack and one which acts only on the top value:          NOT    one's complement of the top value.          AND    bitwise "AND" of the top two values.          OR     bitwise "OR" of the top two values.          XOR    bitwise exclusive OR of the top two values.     The use of these definitions is most easily seen by using  a base which is a power of two.  The most common of these are octal and  hexadecimal.   This way there is an easily decoded relation-ship  between  the value of a number and the state of  its  indi-vidual bits.  Type          OCTAL <cr>FORTH is now ready to handle base 8.   Typing HEX would give base 16,  and DECIMAL gives base 10.   Using base 8, an example of the logical operators is          ok 453 321 AND .  <cr>          1          okwhere  the only bit in common between the octal numbers  453  and 321 is the least significant bit.2.5  Relational Operators     Relational  operators  compare  stack  values  and  leave  a logical  truth flag;   ie.,  a number that is either zero or  one depending  on  the tested condition.   All  relational  operators destroy  the stack values they test and just leave the truth flag on  the  stack.   There  are  many  of  these  operators  because condition  testing is one of the most common functions  performed in FORTH.  The table below lists the major relational operators.     WORD                   FUNCTION       0=       If the top stack value equals zero, leaves a 1                (true);  otherwise, leaves a 0 (false).  Also                called NOT.       0<       True if stack value is less than 0, false                otherwise.       0>       True if stack value is greater than 0, false                otherwise.       <        True if the next lower stack value (B) is less                than the top stack value (A), false otherwise.       =        True if B is equal to A, false otherwise.       >        True if B is greater than A, false otherwise.     An example of the use of some of these relational  operators is to compare          ok 8 0= 9 10 < = .  <cr>          0          ok The  number 8 is compared to see if it is equal to zero.   It  is not, so this operation leaves a 0 on the stack in place of the 8. Then 9 is tested to see if it is less than 10.   This is true, so a 1 is pushed on the stack.  Then the results of the previous two operations  (0 and 1) are tested to see if they are  equal.   The result is 0, which is then printed.  The stack is now empty.2.6  Forth Memory Allocation     Before we go any further in examining FORTH, a little of the nuts  and  bolts  must be presented.   FORTH is  a  core-resident program that occupies approximately 24000 bytes of  memory.   Not all of the allocated memory is filled under normal use;  instead, it  is  partitioned  into subsections that can  expand  with  the increasing load.  The partitions are:I.   THE DICTIONARY.  Nearly all of FORTH resides in the diction-     ary.   The  dictionary starts at about address $2000 and  is      composed of three contiguous sections:     a.   Kernel.   Core  locations  $2000 through $4000  (bytes)           hold the FORTH kernel.   This is the assembly  language           program  that  contains  the 190 most  primitive  FORTH           definitions; somewhat ignorant but easily teachable.      b.   Basic FORTH.   This section is the SYSTEM  definitions,           some  200  elementary words that later definitions  can           draw on.     c.   Application  FORTH.   In this area are the  definitions           for any program or utility that you load after starting           your session.  This area grows upwards to higher memory           locations.II.  THE  DATA  STACK.   The data stack contains  such  items  as      arguments passed between routines, numbers typed in from the      terminal,  system word temporary storage,  etc.,  and is the       stack we previously talked about.   This stack is placed  in      page  zero  starting  at location $A0 and  "grows"  downward      towards lower memory locations.   The data stack is in  page      zero  for  the  most efficient use of  the  6502  addressing      modes,  but  the  size of the stack is necessarily  limited.       The  user is guaranteed 32 cells (or 64 bytes) of  space  on      the data stack; exceed this limit at your own risk.III. THE  RETURN STACK.   Less used by the  beginning  programmer      (for  good  reason!),  the return stack's primary use is  to      contain  addresses  of  the words to  be  executed  when  we      "return" from the word being currently executed.  Other uses      include  storage for loop parameters,  and numbers that  are      "in the way" on the data stack.   The return stack starts at      the  top  of  page  1  of  memory  and  grows  downward.   A      moderately experienced 6502 programmer will notice that this      is also the 6502 machine stack, so use it sparingly and with      careful attention to the protocol.IV.  THE BLOCK BUFFERS.  UNIFORTH is a disk-based system and uses      two  or  more  buffers to bring data to and from  the  disk.       Each buffer is nominally 1024 bytes long.     A diagram of how memory is allocated in core is shown below.     high limit     |---------------------------| $BF00                    |       user variables      |                    |---------------------------| $BE80                    |       block buffer 2      |                    |---------------------------| $BA7A                    |       block buffer 1      |                     |---------------------------| $B674                    |           TIB             |                    |---------------------------| $B574                ^   |                           |                ^   |                           |      memory    ^   |   .   .   .   .   .   .   |     addresses  ^   | ^                         |                ^   | ^    user application     |                ^   | ^       dictionary        |                    | ^                         |                    |---------------------------|                    |                           |                    |      "standard" FORTH     |                    |         dictionary        |                    |                           |                    |---------------------------|                    |                           |                    |        FORTH kernel       |                    |         dictionary        |                    |                           |                    |---------------------------| $2000                    |     ProDOS I/O buffers    |                    |     Video memory, etc.    |                    |---------------------------| $0200                    |     6502 return stack     |                    |---------------------------| $0100                    | Page 0 storage/data stack |                    |---------------------------| $0000 2.7  Pointer Values     FORTH  has  four  "pointers,"  most  of  which  are  usually transparent  to the user.   The two stack pointers  have  already been mentioned.   The data stack pointer can be referenced by the word  SP@,  which  indicates the address of the top of the  stack before  SP@ was used.   The return stack pointer's current  value can be obtained by the word RP@.     The dictionary pointer (DP) indicates the first free  memory address  for  the storage of new definitions.   Its value can  be obtained by DP @ and can be changed by ALLOT,  which uses the top stack  value  as the number of bytes by which  to  increment  the pointer.   Further  explanation of the dictionary pointer can  be found in the User's Guide.     The   interpreter  pointer  (IP)  is  an  internal  register containing  the address of the next FORTH "word" to be  executed. It  cannot  be accessed by the programmer  except  with  assembly language routines.   Further information concerning the IP can be found in the UNIFORTH Manual Set.2.8  Definitions     Now let's get back to our problem of squaring numbers.  What we discussed before leads into the next logical point:   it would be   convenient  to  take  a  series  of  stack  operations   and automatically call in the whole series when needed.  Consider the case of squaring a number, i.e., calculating A*A.     You can define a word to perform this function for you. Pick a name for your word,  for example,  SQUARE.  You can define this word by          ok : SQUARE DUP * ;  <cr>     The  first  thing  on the line is a word which is  just  the single  character  ":" (colon).   Following it (separated  by  at least one space) is the word name you are defining.   Next is the series of words you wish to have executed (DUP *).   Finally, the closing word is a semicolon,  which indicates that the definition of SQUARE is complete.   The word,  once defined, can now be used like any of the well-known words, i.e.          ok 5 SQUARE . <cr>          25          ok 3 4 + SQUARE 40 - . <cr>          9          ok     Before  proceeding,  you  should stop and consider  what  is happening  in  more detail.   The process of putting a series  of words  together  in  a so-called  "colon  definition"  is  called "compilation".   When  FORTH  is  processing the words  inside  a definition,  it  does almost all the work needed to perform  your function.   When the word is used, FORTH can very rapidly perform the function you have designed.     The  colon  starts  the compilation  process  by  using  the following  character  string  as  the "name"  of  what  is  being compiled.   The name is stored at the beginning of the definition in  the  "header section" as a count byte followed by  the  ASCII characters  of  the name.   The address of an  assembly  language routine  is next (the "code section") and then the information to be processed (the "parameter section"),  such as the addresses of the FORTH words to be included in your definition.   Finally, the semicolon turns off the compilation process and gets you back  to the "interactive execution" mode you started with.  If you forget the semicolon, any words you type after it will be thrown in with the colon definition and not executed immediately.     Remember  that the only restriction on names is that control characters  are  not allowed.   There is nothing sacred  about  a "number" such as "7".  If you want to be different you can define          :  7 5 ;  and obtain such bizarre results as          ok 7 3 + .  <cr>          8          ok     The next step in defining words is to realize that there  is no   distinction   between  "FORTH  words"  and   "your   words". Previously, you defined the word          :  SQUARE DUP * ;  Using  this word you can define a routine to get the fifth  power of numbers like this:          :  **5 DUP SQUARE SQUARE * ;       Now suppose you choose to redefine SQUARE.  You could choose to do this by typing          ok :  SQUARE 5 .  ;  <cr> SQUARE Redefined           ok 7 SQUARE <cr>          5          okNote the "Redefined" informative message that you get.   However, the  new  definition  of SQUARE will not affect its  use  in  the previously defined word, **5.          ok 2 **5 .  <cr>          32          okBut  if  **5 is now redefined,  the new definition of  SQUARE  is used.          ok :  **5 DUP SQUARE SQUARE * ;  <cr> **5 Redefined           ok 2 **5 .  <cr>          5 5 4          ok     The behavior is governed by these two rules:     1.   When  you  define  a word,  all words used  within  the           definition must have been previously defined.     2.   Later  changing a word you use within definitions  will           not  affect  words you have  already  defined  -- their           function  will  remain unchanged until you enter a  new           definition for the word.     Notice  that only the most recent dictionary  definition  of words used within a colon definition will be used.   For example, in   subsequent  use,   the  correct  definition  for  SQUARE  is inaccessible  because another definition for SQUARE  was  created later.   There  is  a  way of "forgetting" the later  version  of SQUARE.  The FORTH word FORGET, used like          ok FORGET SQUARE <cr>          okwill erase from the dictionary the most recent definition ofSQUARE and all definitions made after it.     We  have mentioned colon definitions.   You can also  define machine  language words with the word CODE,  and terminate  their definition with the word END-CODE,  in a similar manner as  colon and semicolon.  We will mention machine language routines in more detail in a subsequent chapter.     One  other item before we leave the subject of  definitions. Besides using RPN representation, FORTH is decidedly not FORTRAN-like   in  its  definitions.    Though  these  act  exactly  like subroutines, they differ in that most arguments are passed on the data   stack,   and  that  the  entire  definition   is   written horizontally.   While  you can write definitions with each called word  on a separate line,  it is not commonly done.   This can be confusing to the beginning programmer,  but think of it as if you were entering the line interactively.2.9  Constants and VariablesFORTH  has several words for reading from and writing to  memory. To  read  from memory,  an address must be specified.   Then  "@" (pronounced "fetch") takes that address,  reads the 16-bit  value starting at that address,  and places it on the stack.   The word C@ accomplishes a similar task, except that it retrieves only the byte stored at the address, places it in the low byte of a 16-bit location or cell which is then placed on the stack.                      <<<CELL DEFINITION>>>               A cell is a 16-bit memory location.               The low order byte is stored at the               first byte address;  the high order               byte   is   stored   at   the  next               consecutive byte address.The  procedure  of  reading (or fetching as it is  more  commonly called)  and  then printing is used  often.   Therefore,  a  word exists that combines both of these operations--the question  mark (?).  It fetches an integer from a given address and prints it.      Two words exist to write into a specific memory location. As for  reading,  the  exclamation point ("!",  pronounced  "store") stores a 16-bit value and C!   stores the low-order byte of a 16-bit  value from the top of the stack.   In both cases,  the  data value and the address are removed from the stack.  For example,                           16432 18500 !stores the values 16432 at address 18500.     Also in the context of definitions, you can define constants and variables to be used in your programs.  Numeric constants can be defined with the word CONSTANT.  For example,          31415 CONSTANT PI-TIMES-10000defines  the FORTH word PI-TIMES-10000.   Whenever you type  this word, the constant 31415 will be pushed on the stack.     Often  you find that it is awkward to have all your data  on the  stack at once.   You can store data in single  named  memory locations with the FORTH word VARIABLE.  For example,          VARIABLE Qdefines the word Q.   When you type Q, the address of the storage location corresponding to Q is pushed onto the stack.  You cannot preset  this storage location during the definition as you  could with  CONSTANT.   You can use Q in conjunction with @ and  !   to change  the  contents  during program  execution  (for  instance, updating a counter).   There is a special word called tick,  "'", which  allows  the  changing of the value of  a  CONSTANT.   Tick places the address of a word's code field on the stack.  To reach the parameter field (where the constant is stored),  you can  use the  word  >BODY.   Then,  you  can then change the  value  using "store".  For example,          31416 ' PI-TIMES-10000 >BODY !changes PI-TIMES-10000 from 31415 to 31416.2.10  Typing     One of the problems with FORTH as far as users are concerned is that there is no typing of variables.   That is, once you have defined  variable XXX,  the system doesn't know later whether XXX is an integer,  floating point number, or what.  The advantage of this  is  that  less  storage  space  and  compiler  overhead  is necessary,  and  as long as you are dealing with  characters  and integers, the inconvenience is small.     The  disadvantage  comes into play when FORTH  becomes  more complicated,  and  you  start implementing types such  as  double precision integer,  string variables,  etc.  Because of this lack of typing, you cannot perform mixed-mode arithmetic automatically using a precedence scheme such as in FORTRAN.     Therefore, when using FORTH, you must keep the type of every variable  and  stack  member in mind,  and  perform  the  correct operation on the numbers.  For example:        +      Add the two top 16-bit stack values, assuming they               are single precision integers, and leave a 16-bit               result.        D+     Add the four top 16-bit stack values, assuming               they are two double precision (32-bit) integers,               and leave a 32-bit result.        F+     Add the four top 16-bit stack values, assuming               they are two single precision (32-bit) floating               point values, and leave a 32-bit floating point               result.        P+     Add the top two ordered pairs of  integers.   That                is,  if the stack contains D C B A,  then after P+                executes, the stack will contain D+B  C+A.In  other  words,  some  of the work has been taken  out  of  the compiler  or language and placed on the  programmer's  shoulders. There  is  no  inherent  reason why  a  typed-FORTH  couldn't  be created;  there just has been no emphasis in this direction.2.11  Control Structures     Control   structures  allow  you  to  modify  program  flow, primarily by making decisions and causing various definitions  to execute within a colon definition.  2.11.1  Looping     Maintaining an iteration counter and causing a branch out of the  loop  when a preset value is reached is a  very  fundamental software feature.  FORTH provides the DO and LOOP words for this.     When making a loop,  you usually know the starting value and the number of repetitions desired.   When you sum these,  you get the total.   DO expects to find two parameters on the stack,  the total and the starting value:     [total] [start] DO [things to be done] LOOP     As an example, consider a definition to print out 5 numbers.  If we start with 1, then the total is 6, and our definition is:          :  PRINT_FIVE 6 1 DO .  LOOP ;  <cr>This definition expects to find 5 numbers on the stack.          ok 34 5 2 6 -3 PRINT_FIVE <cr>          -3 6 2 5 34          ok     Other  languages use the starting value and the ending value as the loop limits,  and switch the order of the  limits.   These variances are  matters of preference.     Often  it  is useful to have a word to access the  iteration counter, and FORTH provides several of them as indicated below.     WORD                    FUNCTION     I           Push the value of the iteration counter of                  the innermost loop onto the stack.     J           Push the value of the next outermost loop                  counter onto the stack (i.e.,2 nested                   loops).     I-          Subtract the value of the innermost counter                 from the value on the stack.     I+          Add the value of the innermost counter to                  the value on the stack.     Consider a loop to print the numbers from 1 to 10:          ok :  10_#'S 11 1 DO I .  LOOP ; <cr>When executed, 10_#'S will give          ok 10_#'S <cr>          1 2 3 4 5 6 7 8 9 10          ok     Since  DO  expects to find the iteration parameters  on  the stack at execution time,  you can wait until then to define them. A general, ascending order, number printing routine might be:          ok :  GEN_ASC_ORD DO I .  LOOP ; <cr>When executed, this word expects to find the DO parameters on the stack:          ok 11 1 GEN_ASC_ORD <cr>          1 2 3 4 5 6 7 8 9 10          ok     Since  one  normally thinks of these parameters  as  [start] [finish] rather than the order that DO prefers, and further since [finish] is often preferred over [finish+1], try this:          :  LIMITS 1+ SWAP ;  The  1+ adds 1 to [finish] and SWAP puts [start] and [finish]  in the correct order for a DO.   In other words,  you have created a "preprocessor"  for  DO-LOOPS.   This is rarely  done  with  most languages,  but  if  you  expect  to use this  a  few  times  the convenience pays off in FORTH.          ok :  GEN_#_PRINT LIMITS DO I .  LOOP ; <cr>In use, this gives:          ok 1 5 GEN_#_PRINT <cr>          1 2 3 4 5           ok2.11.2  Conditional branching     Conditionals traditionally allow some value to be tested and a  branch to occur based upon the test.   FORTH  allows  one- and two-sided conditional branches.     The  IF word and the THEN word are the simplest  cases.   IF will  cause  the  definitions  between it  and  THEN  to  execute provided  the top stack value (TOS) is logical true  (or  really, not  equal  to zero).   If the TOS is zero,  FORTH will  skip  to execute the words following the THEN word.  For example,          ok :  USE_IF IF 1 .  THEN 2 .  ;  <cr>When executed, this definition will give          ok 1 USE_IF <cr>          1 2          ok 0 USE_IF <cr>          2          okIF always removes the logical quantity it tests from the stack.     Another word,  ELSE, allows one of two branches to be taken. As an example:          ok :  USE_ELSE IF 1 .  ELSE 0 .  THEN ;  <cr>     If 0 is on the stack,  the ELSE-clause will be executed;  if a  number other than 0 is on the stack,  the TRUE-clause will  be executed, as in          ok 0 USE_ELSE <cr>          0          ok 4 USE_ELSE <cr>          1          okThe ELSE portion executes if TOS is false, or 0.  In either case, the  definition after THEN executes.   In the preceding  example, the compiler operator ";" will execute.   It will signal both the end of the definition at compile time, and perform house-cleaning at the end of the definition at execute time.2.11.3  Block structure branching     FORTH also provides a block structure which is essentially a loop without an iteration counter.  It is of the form:          BEGIN [good stuff] [flag] UNTIL     BEGIN  is  a  place holder and marks the  beginning  of  the block.   UNTIL tests for a true or false TOS, and if false trans-fers  back to the word following BEGIN.   If true,  the word fol-lowing UNTIL will execute.   UNTIL will remove its logical  quan-tity from the stack.2.12  And so Forth....     You  now have seen most of the basics of FORTH,  along  with some  examples.   The best way to learn more at this stage is  to sit at a terminal and practice!                            Chapter 3                   UNIQUE FEATURES OF UNIFORTHAs  mentioned  earlier,  the Sampler is a subset  of  our commercial FORTH.  Even so, it has many additions to the FORTH-83 standard.  This chapter will mention a few of those features.  We recommend  the  purchase  of  the UNIFORTH Manual  Set  for  more information.3.1  Files     UNIFORTH uses ProDOS tree-structured files.  In other words, you  can access files in any directory on any disk from inside of UNIFORTH.  The limitation is that the file pathname cannot exceed 64 characters.     All UNIFORTH source code filenames have an extension of .FTH for unique identification.     The following words give the basic file access functions:     CHANA,CHANB          There  are  two default "channels" for file  access  in           UNIFORTH,  selected by the words CHANA and CHANB.  When           first  invoking UNIFORTH,  CHANA is assumed.   After  a           channel has been selected, all file read/write commands           are  directed  to that channel.   If  you  now  specify           CHANB,  all  commands are directed to the file open  on           that channel.     OPEN <fname>          Open the file.   If the file doesn't exist, you will be           prompted for its creation.   If you decline to create a           new file, the previous file will be reopened.     CLOSE          Close  the file on the current channel.   No action  is           taken if a file is not currently open.     MAKE <fname>          You can explicitly create a file with this word.   MAKE           and  OPEN only create the ProDOS directory  entry;  the           file  has no length until you explicitly write data  to           it.      DELETE <fname>          Deletes the file.     FILESTATUS          Displays information about the currently open file.     Once opened, a file can be accessed in one of two ways:     (1)  As  a block-oriented (FORTH) file.   You read/write  to           the file using 1024-byte random-access blocks of  data.            Common words are BLOCK, BUFFER, UPDATE, LOAD, etc.     (2)  As a sequential, text-oriented file.  You read/write to           the file in bytes or lines,  where a line is terminated           with  a  user-defined end of line (EOL) character.     Block-oriented  files are the most straightforward.   All of the  FORTH-83  read/write/load words work on  block  files.   The limitations are that you will get an error message if you try  to access data beyond the end of the file,  and that you cannot load block  0  of any file.   You can also open and read binary  files such as UNIFORTH.COM with BLOCK, and dump their contents.     A blank file can be created,  or a current file extended  in length,  using  the word EXTEND.   It has the number of blocks to extend as its argument.   Each added block is blank-filled with a ";S" at the beginning.     You can move blocks from one file to another with a brace of words:     n1 n2 COPYATOB          Copy  block n1 of the file currently open on channel  A           into block n2 of channel B.     n1 n2 #blks MCOPY          Copy #blks starting at block n1 in channel A to channel           B, starting at block n2.     Text files are read byte-by-byte.   You should not use BLOCK on a text file, as there is no guarantee that the file will be an exact multiple of 1024 bytes in length (meaning you won't be able to access the last part of the file).  Instead, there is a set of words to perform the major read/write operations for you.     enable_mask eol_char NEWLINE          This word enables/disables ProDOS text file  mode.   If           enable_mask  is zero,  text file mode is disabled.   If           the mask is nonzero,  text file mode is enabled and the           eol_char  is ANDed with the mask to get  a  match.   In           other  words,  if  enable_mask=$7F and eol_char=$0D  (a           carriage return) then both $0D and $8D will be accepted           as EOL characters.  See the ProDOS Reference Manual for           further details.     RDBYTE char          Read one byte from the current file.  If the end of the           file  is  reached,  leave a true flag in place  of  the           character.     adr cnt refnum READ-BYTES nchar          Read  several  bytes  from a file into a  buffer  (like           EXPECT).   Leave on the stack the number of  characters           actually read, or 0 if an eof was detected.     adr cnt RDLINE nchar          Read a "line" from the file into a buffer.   The number           of  characters actually read (nchar) will be less  than           cnt if the EOL character is detected.     char WRBYTE          Write the character to the current file.     adr cnt refnum WRITE-BYTES nchar          Write  cnt  characters  to  the  file  pointed  to   by           "refnum".   nchar  is  the actual number of  characters           written,  and will be less than cnt only if the disk is           full.     adr cnt WRLINE          Write cnt characters to the current file.   Append  the           EOL character to terminate the line.     WREOF          Write an end-of-file mark on the current file.     d1 !FILE-POS           A   method  of  random-access  on  a  sequential  file.            Position  the  next  read/write to byte  d1  (d1  is  a           double-precision  integer) of the current file.   d1 is           an absolute position in the file.          @FILE-POS d1          Returns  the current file pointer (double integer bytes           from beginning of file).The "refnum" on some of these words is the ProDOS file  reference number.   It  is  returned  when you open a  file.   The  current channel's name is pointed to by variable FCB,  and the first cell of that name is the refnum.  The words REFNUM and PATHNAME return the addresses of the reference number and pathname of the current file, respectively.  For instance,          PATHNAME COUNT TYPEwill print the pathname of the current file.     You  can  also  load source code  from  a  text  file.   For example,  you might like to use some other text editor,  and feel restricted by the 16x64 format of a FORTH block.   You can create a text file and load the entire file:     TLOAD          Load  the  currently  open text file  starting  at  the           current file pointer.  Each line of text is interpreted           just  as if you had entered it from the  console.   You           must terminate the file with a ;S.Loading  from  a  text  file requires a  minimum  of  three  disk buffers, so check #BUFF before you attempt a load.     Two  more  words exist to help make file handling  a  little easier.       PREFIX /pathname          Set the ProDOS system prefix.  If PREFIX is followed by           a pathname, set the prefix to that pathname.  If PREFIX           is  entered by itself,  print the system prefix on  the           current output device.     TAG <fname>          Tag  the  file  with the current  date  and  time.  The           Sampler  does  not  currently have  a  real-time  clock           interface,  so  you may wish to update the  time  (with           !TIME) before using this word.     3.2  Vectored I/O     UNIFORTH  uses  an IOFLOW concept similar to that  found  in many CP/M systems to control the flow of input and output.  Up to eight output devices can be selected for simultaneous output, and any  one  of  eight input devices can be used  for  terminal-like input.      IOFLOW  is  a  system  variable,  with  its  low-order  byte controlling  input  and  its most  significant  byte  controlling output.  Each bit of each byte has a designation, as shown below.     A 32-byte table  is located at IOTABLE.   The bits in  IOFLOW select from these 16 addresses to execute the proper routine.  The bit definitions are:         bit#       IOTABLE+...    routine          0         0              terminal input          1         2              system input          2         4              auxiliary input routine          3         6              disk input routine          4         8              null device          5         10             user specified          6         12             user specified          7         14             user specified          8   