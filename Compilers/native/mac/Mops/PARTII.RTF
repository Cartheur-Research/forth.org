{\rtf1\mac\deff2 {\fonttbl{\f0\fswiss Chicago;}{\f2\froman New York;}{\f3\fswiss Geneva;}{\f4\fmodern Monaco;}{\f6\fdecor London;}{\f11\fnil Cairo;}{\f13\fnil Zapf Dingbats;}{\f14\fnil Bookman;}{\f15\fnil N Helvetica Narrow;}{\f16\fnil Palatino;}{\f18\fnil Zapf Chancery;}{\f20\froman Times;}{\f21\fswiss Helvetica;}{\f22\fmodern Courier;}{\f23\ftech Symbol;}{\f33\fnil Avant Garde;}{\f34\fnil New Century Schlbk;}{\f128\fnil Boston IIx;}{\f192\fnil Mangia;}{\f220\fnil MiniBoston IIx;}{\f221\fnil MicroBoston IIx;}{\f222\fnil Line & Lead;}{\f1024\fnil American Heritage;}{\f1025\fnil ClosedCaption2;}{\f1026\fnil XPGildedCD-IN;}{\f1133\fnil Century Cond;}{\f1148\fnil XPCompacta;}{\f1202\fnil XPOxfordText-Normal;}{\f1238\fnil XPCopperhead;}{\f1269\fnil Futena;}{\f1397\fnil XPCabotOpen;}{\f1639\fnil XPRadial;}{\f1792\fnil Lucida Bright;}{\f2000\fnil Garamond Narrow;}{\f2007\fnil Delphian;}{\f2017\fnil Lubalin Graph;}{\f2024\fnil Machine;}{\f2029\fnil Nadianne;}{\f2036\fnil Old English Text;}{\f2038\fnil Onyx;}{\f2040\fnil Oxford;}{\f2046\fnil Swing;}{\f2052\fnil Zeal;}{\f2091\fnil Cursive-Elegant;}{\f2096\fnil XPKaleph-Bold;}{\f2121\fnil Garamond;}{\f2247\fnil XPGildedCD;}{\f2385\fnil XPJasmine;}{\f2429\fnil XPSchooner;}{\f2435\fnil Fruit;}{\f2490\fnil DeltaSymbol;}{\f2503\fnil Technical;}{\f2515\fnil MT Extra;}{\f2686\fnil Caslon;}{\f2689\fnil Trade Condensed;}{\f2799\fnil XPTechno;}{\f2835\fnil XPFortunaCD;}{\f2999\fnil eWorld Tight;}{\f4950\fnil TTYFont;}{\f7715\fnil XPFortuna-XB;}{\f9840\fnil Espy Sans;}{\f9842\fnil Espy Sans Bold;}{\f10840\fnil Klang MT;}{\f10890\fnil Script MT Bold;}{\f10897\fnil Old English Text MT;}{\f10909\fnil New Berolina MT;}{\f10957\fnil Bodoni MT Ultra Bold;}{\f10967\fnil Arial MT Condensed Light;}{\f14811\fnil Helvetica Compressed;}{\f14974\fnil Helvetica Black;}{\f15011\fnil Gill Sans Condensed Bold;}{\f32525\fnil VT100;}}{\colortbl\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;}{\stylesheet{\s229\li2880\ri720\tldot\tx8280\tqr\tx8640 \f20 \sbasedon0\snext0 toc 5;}{\s230\fi-360\li1080\ri360\tqdec\tldot\tx4320 \f20\fs20 \sbasedon231\snext0 toc 4;}{\s231\fi-360\li720\ri360\tqdec\tldot\tx4320 \f20\fs20 \sbasedon232\snext0 toc 3;}{\s232\fi-360\li360\ri360\tqdec\tldot\tx4320 \f20\fs20 \sbasedon233\snext0 toc 2;}{\s233\fi-360\li360\ri360\sb720\keepn\tqdec\tx4320 \b\f20 \sbasedon0\snext0 toc 1;}{\s241 \f20 \sbasedon0\snext0 line number;}{\s242 \f20 \sbasedon0\snext0 page number;}{\s243\tqc\tx4320\tqr\tx8640 \f20 \sbasedon0\snext243 footer;}{\s244\brdrb\brsp80\brdrhair \tqc\tx4680\tqr\tx9360 \f20 \sbasedon0\snext244 header;}{\s245 \f20\fs18\up6 \sbasedon0\snext0 footnote reference;}{\s246 \f20\fs20 \sbasedon0\snext246 footnote text;}{\s250\li720 \f20\fs20\ul \sbasedon0\snext0 heading 6;}{\s251\qc\sb120 \b\f20 \sbasedon0\snext0 heading 5;}{\s252\sb240\keepn \f21\ul \sbasedon253\snext0 heading 4;}{\s253\sb240\keepn \b\f21 \sbasedon254\snext0 heading 3;}{\s254\qc\sb240\keepn \b\f21 \sbasedon255\snext0 heading 2;}{\s255\qr\sb720\sa1440\keepn \b\f21\fs48 \sbasedon0\snext0 heading 1;}{\f20 \sbasedon222\snext0 Normal;}{\s2\li720\sb120 \b\f22\fs20 \sbasedon0\snext2 examples;}{\s8\li720\sb120 \f22\fs20 \sbasedon2\snext8 examplenb;}{\s9\sl240\tx720\tx1440\tx2880\tx7200 \f22\fs20 \sbasedon2\snext9 example case stmt;}{\s13 \f22\fs20 \sbasedon8\snext13 program;}{\s17\qj\sb120 \f20 \sbasedon0\snext17 paragraph;}{\s18\fi-360\li360\ri6580\sb120\sbys \f20 \sbasedon0\snext18 method/word;}{\s19\qj\li2880\sb120\sbys \f20 \sbasedon17\snext19 description;}{\s20\fi-360\li720 \f20 \sbasedon0\snext20 bullet;}{\s21\qc\sb120\keepn \f20 \sbasedon17\snext21 figure graphic;}{\s22\sb240\keepn \b\f21 \sbasedon253\snext22 subhead (non TOC);}{\s23\qj\sb120 \f20 \sbasedon17\snext23 preamble;}}{\info{\title Part II-Mops general reference}{\author Craig Treleaven}{\*\verscomm Converted by John Robinson}}\margl1080\margr1080\margb1080\facingp\gutter720\widowctrl\ftnbj\fracwidth \sectd \pgnrestart\pgnlcrm\linemod0\linex0\cols1\endnhere\titlepg {\headerl \pard\plain \f20 \par }{\headerr \pard\plain \f20 \par }{\footerr \pard\plain \li200 \f20 {\f21 \par }}{\footerf \pard\plain \f20 \par }\pard\plain \qc \f20 {\b\fs96 Mops\par }\pard \qc {\b\i\fs28 Mike's Object-oriented Programming System\par }\pard \qc {\b\fs48 \par Version 2.6\par }\pard \qc\posy3601\dxfrtext180 {\b\fs96 Part II\par }\pard \qc\posy3601\dxfrtext180 {\b\fs48 General Reference\par }\pard\plain \s23\qj\sb120\posyb\dxfrtext180 \f20 Mops is an object-oriented programming system, derived from the Neon language developed by Charles Duff and sold by Kriya, Inc.  Kriya have discontinued support for Neon, and have released all the source code into the public domain, retaining only the ownership of the name Neon.\par \pard \s23\qj\sb120\posyb\dxfrtext180\tx3240 Mops implemented by:\tab Michael Hore\par Able assistance from:\tab Doug Hoffman\par \pard \s23\qj\posyb\dxfrtext180\tx3240 \tab Greg Haverkamp\par \tab Xan Gregg\par \pard \s23\qj\sb120\posyb\dxfrtext180\tx3240 Documentation updated:\tab Version 2.6, June 1995\par Documentation formatted by:\tab Craig Treleaven\par \pard\plain \s22\sb240\keepn \b\f21 \page Printing this document\par \pard\plain \s23\qj\sb120 \f20 This document is in Microsoft Word Version 5.1 format and uses the fonts Times, Courier, and Helvetica, only.  It is formatted using the Laserwriter 7 driver for US Letter paper, portrait orien\-tation, with fractional widths enabled.  If you want to print any other way, you will probably need to repaginate and regenerate the table of contents and table of predefined classes and meth\-ods.  See below.\par \pard \s23\qj\sb120 Almost every paragraph in this document is formatted using a Word style.  Formatting is consis\-tent throughout and can be reformatted in moments this way.  \par \pard\plain \s22\sb240\keepn \b\f21 Viewing on-line\par \pard\plain \s23\qj\sb120 \f20 Of course, you can read the whole manual on-screen.  Word\rquote s Find\'c9 command can help to locate items of interest.  One other technique is useful but not well known.  Use the Outline View and click the \ldblquote 2\rdblquote  in the ruler at the top of the screen.  Word will then show the chapters and the sub-headings within.  Whichever line is at the top of the window in outline view will become the line at the top of the window when you switch back to Normal View.  By scrolling in Outline View, you can quickly find the section of interest and position the window for reading in Normal View.  \par \pard\plain \s22\sb240\keepn \b\f21 Two-sided printing\par \pard\plain \s23\qj\sb120 \f20 As shipped, this document is formattted for 2-sided printing to save paper.  If you haven\rquote t printed two-sided documents with your printer before, you might want to practise with the first few pages before sending the whole thing.  On most printers, you need to use Word\rquote s option to print first the odd numbered pages (in the Print\'c9 dialog), reload the paper and then print the even numbered pages.  \par \pard\plain \s22\sb240\keepn \b\f21 Single-sided printing\par \pard\plain \s23\qj\sb120 \f20 If you don\rquote t want to bother with two-sided printing, use the Document dialog and make the Gutter margin zero.  If you adjust the Left and Right margins so the printable width is still 6.5 inches, the page breaks should stay in the same places.  Blank pages may pop out here and there as all Lessons start on an odd-numbered page.  \par \pard\plain \s22\sb240\keepn \b\f21 A4 Paper\par \pard\plain \s23\qj\sb120 \f20 If you select A4 paper in the Page Setup\'c9 dialog, the page breaks will change.  Regenerate the table of contents, as below.  As far as I can tell, the paragraph styles all do the right thing and ajust to the paper width.  Well, all except one:  the header on odd-numbered pages will extend a quarter inch into the margin because the tab stop is at 6.5 inches.  Redefine the Header style to set it to 6.25, if you feel the need.  \par \pard\plain \s22\sb240\keepn \b\f21 Table of Contents\par \pard\plain \s23\qj\sb120 \f20 Use the Table of Contents\'c9 dialog to col\-lect headings from level 1 to level 3 for the Table of Contents.  Figure captions have Heading 5 style, but I didn\rquote t see a reason to create a table of figures.  \par \pard\plain \f20 \sect \sectd \pgnrestart\pgnlcrm\linemod0\linex0\cols2\endnhere\titlepg {\headerl \pard\plain \s244\brdrb\brsp80\brdrhair \tqc\tx4680\tqr\tx9360 \f20 II-\chpgn  Mops General Reference\par }{\headerr \pard\plain \s244\brdrb\brsp80\brdrhair \tqc\tx4680\tqr\tx9360 \f20 \tab \tab Contents II-\chpgn \par }{\footerr \pard\plain \li200 \f20 {\f21 \par }}{\headerf \pard\plain \s244\qc\tqc\tx4680\tqr\tx9360 \f20 {\b\f21\fs36 \par Contents\par }}{\footerf \pard\plain \f20 \par }\pard\plain \s233\fi-360\li360\ri360\sb720\keepn\tqdec\tx4320 \b\f20 Mops and Quick Edit\tab 1\par \pard\plain \s232\fi-360\li360\ri360\tqdec\tldot\tx4320 \f20\fs20 The Mops Menu Bar\tab 1\par \pard\plain \s231\fi-360\li720\ri360\tqdec\tldot\tx4320 \f20\fs20 The Apple menu\tab 1\par The File menu\tab 1\par The Edit menu\tab 2\par The List menu\tab 2\par The Show menu\tab 2\par The Utilities menu\tab 3\par \pard\plain \s232\fi-360\li360\ri360\tqdec\tldot\tx4320 \f20\fs20 Communication with Quick Edit\tab 3\par \pard\plain \s233\fi-360\li360\ri360\sb720\keepn\tqdec\tx4320 \b\f20 Classes and objects\tab 5\par \pard\plain \s232\fi-360\li360\ri360\tqdec\tldot\tx4320 \f20\fs20 Planning your subclasses\tab 5\par The class hierarchy\tab 5\par Choosing between ivars and objects\tab 6\par When to use ivars\tab 6\par Defining a class\tab 6\par Ivars\tab 7\par \pard\plain \s231\fi-360\li720\ri360\tqdec\tldot\tx4320 \f20\fs20 Ivars as Toolbox data structures\tab 8\par How ivars are linked\tab 9\par Potential ivar errors\tab 10\par \pard\plain \s232\fi-360\li360\ri360\tqdec\tldot\tx4320 \f20\fs20 Methods\tab 10\par \pard\plain \s231\fi-360\li720\ri360\tqdec\tldot\tx4320 \f20\fs20 Special Mops words for primitive methods\tab 10\par ^BASE and ^ELEM\tab 10\par \pard\plain \s233\fi-360\li360\ri360\sb720\keepn\tqdec\tx4320 \b\f20 More about objects\tab 13\par \pard\plain \s232\fi-360\li360\ri360\tqdec\tldot\tx4320 \f20\fs20 Binding\tab 13\par \pard\plain \s231\fi-360\li720\ri360\tqdec\tldot\tx4320 \f20\fs20 Early binding\tab 13\par Late binding\tab 13\par Late binding and Toolbox calls\tab 14\par Early vs. late binding\tab 14\par When to use late binding\tab 15\par \pard\plain \s232\fi-360\li360\ri360\tqdec\tldot\tx4320 \f20\fs20 Dynamic (heap-based) objects\tab 16\par More ways of early binding\tab 17\par \pard\plain \s231\fi-360\li720\ri360\tqdec\tldot\tx4320 \f20\fs20 Object pointers\tab 17\par class_as>\tab 18\par \pard\plain \s232\fi-360\li360\ri360\tqdec\tldot\tx4320 \f20\fs20 Public and static ivars\tab 18\par \pard\plain \s233\fi-360\li360\ri360\sb720\keepn\tqdec\tx4320 \b\f20 Putting together a Mops application\tab 21\par \pard\plain \s232\fi-360\li360\ri360\tqdec\tldot\tx4320 \f20\fs20 Structure of a typical application\tab 21\par Bringing objects to life\tab 21\par Waiting for events\tab 21\par Apple events\tab 22\par Compiling your source\tab 23\par \pard\plain \s231\fi-360\li720\ri360\tqdec\tldot\tx4320 \f20\fs20 Switching between compiler and editor\tab 23\par Saving compiled programs\tab 24\par Other compiling tips\tab 24\par \pard\plain \s232\fi-360\li360\ri360\tqdec\tldot\tx4320 \f20\fs20 Debugging your code\tab 24\par \pard\plain \s231\fi-360\li720\ri360\tqdec\tldot\tx4320 \f20\fs20 Evaluating Mops error messages\tab 25\par System errors\tab 25\par \pard\plain \s232\fi-360\li360\ri360\tqdec\tldot\tx4320 \f20\fs20 Your application's icons\tab 26\par \pard\plain \s233\fi-360\li360\ri360\sb720\keepn\tqdec\tx4320 \b\f20 Memory Organization\tab 27\par \pard\plain \s232\fi-360\li360\ri360\tqdec\tldot\tx4320 \f20\fs20 The Mops Dictionary\tab 29\par The kernel or nucleus\tab 30\par The heap\tab 30\par Mops stacks\tab 30\par Addresses\emdash relocatable and absolute\tab 31\par Handles and pointers\tab 31\par \pard\plain \s233\fi-360\li360\ri360\sb720\keepn\tqdec\tx4320 \b\f20 Strings in Mops\tab 33\par \pard\plain \s232\fi-360\li360\ri360\tqdec\tldot\tx4320 \f20\fs20 String types\tab 33\par String literals and constants\tab 33\par Other string techniques\tab 34\par \pard\plain \s233\fi-360\li360\ri360\sb720\keepn\tqdec\tx4320 \b\f20 Calling the Toolbox\tab 35\par \pard\plain \s232\fi-360\li360\ri360\tqdec\tldot\tx4320 \f20\fs20 Toolbox data cells\tab 35\par Toolbox data types\tab 35\par Procedure and function calls\tab 35\par Accessing system variables and constants\tab 36\par \pard\plain \s233\fi-360\li360\ri360\sb720\keepn\tqdec\tx4320 \b\f20 Modules\tab 37\par \pard\plain \s232\fi-360\li360\ri360\tqdec\tldot\tx4320 \f20\fs20 Module guidelines\tab 37\par How to use modules\tab 37\par \pard\plain \s233\fi-360\li360\ri360\sb720\keepn\tqdec\tx4320 \b\f20 Miscellaneous Topics\tab 39\par \pard\plain \s232\fi-360\li360\ri360\tqdec\tldot\tx4320 \f20\fs20 ANSI standard\tab 39\par Local sections and temporary objects\tab 39\par Case statements\tab 40\par Recursion and forward referencing\tab 42\par Using resources in Mops\tab 42\par \pard\plain \s231\fi-360\li720\ri360\tqdec\tldot\tx4320 \f20\fs20 Toolbox resources\tab 42\par Defining and using resources\tab 43\par \pard\plain \s232\fi-360\li360\ri360\tqdec\tldot\tx4320 \f20\fs20 Clearing nested stacks\emdash Become\tab 43\par System vectors\tab 44\par Mops defining and compiling words\tab 45\par Error handling\tab 45\par Inline definitions\tab 47\par \pard\plain \s233\fi-360\li360\ri360\sb720\keepn\tqdec\tx4320 \b\f20 Utilitiy Modules\tab 49\par \pard\plain \s232\fi-360\li360\ri360\tqdec\tldot\tx4320 \f20\fs20 The Alert box\tab 49\par The Decompiler and Debugger\tab 49\par The Profiler\tab 50\par Run-time initialization\tab 51\par PowerPC assembler and disassembler\tab 51\par \pard\plain \s233\fi-360\li360\ri360\sb720\keepn\tqdec\tx4320 \b\f20 Technical Section\tab 53\par \pard\plain \s232\fi-360\li360\ri360\tqdec\tldot\tx4320 \f20\fs20 Mops run-time environment\tab 53\par Dictionary header format\tab 54\par Compilation and optimization\tab 54\par Object format\tab 55\par Dictionary size\tab 56\par CODE resources\tab 56\par \pard \s232\fi-360\li360\ri360\tqdec\tldot\tx4320 Relocatable address format\tab 57\par \pard\plain \f20 \sect \sectd \sbkodd\pgnrestart\linemod0\linex0\cols1\colsx0\endnhere\titlepg {\headerl \pard\plain \s244\brdrb\brsp80\brdrhair \tqc\tx4680\tqr\tx9360 \f20 II-\chpgn  Mops General Reference\par }{\headerr \pard\plain \s244\brdrb\brsp80\brdrhair \tqc\tx4680\tqr\tx9360 \f20 \tab \tab Chapter 1\emdash Mops and Quick Edit II-\chpgn \par }{\footerr \pard\plain \li200 \f20 {\f21 \par }}{\headerf \pard\plain \s244\qc\tqc\tx4680\tqr\tx9360 \f20 {\b\f21\fs36 \par }}\pard\plain \s255\qr\sb720\sa1440\keepn \b\f21\fs48 Mops and Quick Edit\par \pard\plain \s254\qc\sb240\keepn \b\f21 The Mops Menu Bar\par \pard\plain \s17\qj\sb120 \f20 Mops has a simple set of menus, yet the features built into them make writing code, compiling, and debug\-ging rather easy.  When you start Mops.dic, a specially designed Mops "front end" brings in the basic Mops menus\emdash Apple, File, Edit, Utilities, and Mops.\par \pard \s17\qj\sb120 To help you understand the functions of each menu selection, we'll describe the action of each menu item.  We'll also explain the built-in utilities, which can make you more productive in pro\-gram creation and debugging.  Also see Part II, Chapter 2 for more details on the op\-eration of an Editor.\par \pard\plain \s253\sb240\keepn \b\f21 The Apple menu\par \pard\plain \s18\fi-360\li360\ri6580\sb120\sbys \f20 About Mops\'c9\par \pard\plain \s19\qj\li2880\sb120\sbys \f20 Displays the Mops version number and the date that version was released.\par \pard\plain \s253\sb240\keepn \b\f21 The File menu\par \pard\plain \s18\fi-360\li360\ri6580\sb120\sbys \f20 Load\'c9\par \pard\plain \s19\qj\li2880\sb120\sbys \f20 Allows you to load text source files on top of the Mops dictionary currently in memory (the same as issuing the "//\~filename" com\-mand from the Mops prompt).  The standard file dialog box appears, from which you can select the file to load.  As the source file loads, it is compiled by Mops.  If your program requires the loading of several text files, the files must be loaded in the proper order (so that dependent words and classes are loaded after the words or classes they depend on).  The word NEED which we described in the Tutorial makes it easy to ensure everything is loaded in the right order.\par \pard\plain \s18\fi-360\li360\ri6580\sb120\sbys \f20 Save Dictionary\par \pard\plain \s19\qj\li2880\sb120\sbys \f20 Copies to a disk a compiled image of a program you have in mem\-ory.  It saves the image to a file with the same filename as is shown at the top of the Mops window.  For this reason, Save should be used with care.  If you have added code to Mops.dic and wish to save the image as a separate appli\-cation, then use the Save\~As\'c9 selection, below; otherwise, your Mops.dic file will contain your additions.\par \pard\plain \s18\fi-360\li360\ri6580\sb120\sbys \f20 Save Dictionary As\'c9\par \pard\plain \s19\qj\li2880\sb120\sbys \f20 Lets you copy to a disk a compiled image of a program you have in memory (you are prompted for a new filename, and you may save to a different disk, if you like).  For example, when Mops.dic was originally built, its compiled image was saved with this command.   To start a program saved in this manner, double-click the appro\-priate Mops document icon from the desk\-top, just as you start Mops.dic.  It is recommended that you save programs in this man\-ner only after their source code has been sufficiently debugged.  Until then, you'll want to take advantage of the interactivity of the Mops interpreter while de\-bugging source files by maintaining the code as source files and Loading them to test how well the pro\-gram runs.\par \pard\plain \s18\fi-360\li360\ri6580\sb120\sbys \f20 Quit    \par \pard\plain \s19\qj\li2880\sb120\sbys \f20 This is the equivalent of the Mops command, "bye."  All files are immediately closed, and you are returned to the desktop.\par \pard\plain \s253\sb240\keepn \b\f21 The Edit menu\par \pard\plain \s18\fi-360\li360\ri6580\sb120\sbys \f20 Cut, Copy, Paste, Clear and Select All\par \pard\plain \s19\qj\li2880\sb120\sbys \f20 These perform all the customary editing functions in the Mops window..\par \pard\plain \s253\sb240\keepn \b\f21 The List menu\par \pard\plain \s18\fi-360\li360\ri6580\sb120\sbys \f20 Words\par \pard\plain \s19\qj\li2880\sb120\sbys \f20 Presents a running list of all words in the current dictionary, start\-ing with the word most recently defined (i.e., highest in memory).  The name field of each dictionary entry is displayed along with the hex address of the name field.  To pause the list, press any key once.  To restart the list, press the Spacebar; to cancel the list dis\-play, press any key other than the Spacebar.\par \pard\plain \s18\fi-360\li360\ri6580\sb120\sbys \f20 Objects\'c9\par \pard\plain \s19\qj\li2880\sb120\sbys \f20 This is not yet implemented in Mops.  Eventually it will present a dialog box from which you select the class in memory whose objects you wish to see listed.\par \pard\plain \s18\fi-360\li360\ri6580\sb120\sbys \f20 Classes\'c9\par \pard\plain \s19\qj\li2880\sb120\sbys \f20 This is not yet implemented either.  It will present a list of all classes defined in the cur\-rent dictionary in memory.  The classes are arranged hierarchically so you can see the inheritance chains of all classes in the dictionary.\par \pard\plain \s253\sb240\keepn \b\f21 The Show menu\par \pard\plain \s18\fi-360\li360\ri6580\sb120\sbys \f20 HFS Paths\par \pard\plain \s19\qj\li2880\sb120\sbys \f20 Displays in the Mops window the current paths which will be searched when you open a file.\par \pard\plain \s18\fi-360\li360\ri6580\sb120\sbys \f20 Free Space \par \pard\plain \s19\qj\li2880\sb120\sbys \f20 Displays in the Mops window the amount of memory available for new dictionary entries, as well as the condition of the heap.  The Total heap figure is the current available heap if you do nothing to purge modules from it.  The Largest block figure represents the largest amount of heap available in a contiguous block if you purged all extraneous blocks from the heap.  A typical listing is shown below:\par \pard\plain \s8\li720\sb120 \f22\fs20 Room in dictionary:\tab \tab \tab 223926\line Distance to top of hibase range:\tab  61906\line Total heap (no purge):\tab \tab \tab 325888\line Largest block (purge):\tab \tab \tab 325990\par \pard\plain \s18\fi-360\li360\ri6580\sb120\sbys \f20 Show Module Status \par \pard\plain \s19\qj\li2880\sb120\sbys \f20 Lists all modules defined in the dictio\-nary in memory, and indi\-cates which one(s) are currently on the heap by printing their load addresses. Modules are locked while executing  to prevent their being removed from the heap at an inopportune time.  A typical listing is shown below:\par \pard\plain \s253\sb240\keepn \b\f21 The Utilities menu\par \pard\plain \s18\fi-360\li360\ri6580\sb120\sbys \f20 Echo During Load \par \pard\plain \s19\qj\li2880\sb120\sbys \f20 Displays every line of text from a source file as it is being loaded and compiled into Mops.  Use this feature in the early stages of program development to aid you in discovering exactly where your bugs are cropping up.  By following the load, line-by-line, you can see exactly where Mops runs into trouble and stops the load.  Once your code is sufficiently de\-bugged, you can turn off echo to speed up loading.  This selection is identical to the Mops command +echo.  If you select Echo During Load, a check mark appears next to the menu listing.  Selecting it again turns off the feature and removes the check mark.  You can pause an echoed load by hitting a key, while quiet loads do not pause to permit type-ahead.\par \pard\plain \s18\fi-360\li360\ri6580\sb120\sbys \f20 Clear Stack\par \pard\plain \s19\qj\li2880\sb120\sbys \f20 Clears the stack.  This command is also available in Quick Edit.\par \pard\plain \s18\fi-360\li360\ri6580\sb120\sbys \f20 Clear Window\par \pard\plain \s19\qj\li2880\sb120\sbys \f20 Clears all text from the Mops window.  This command is also available in Quick Edit.\par \pard\plain \s18\fi-360\li360\ri6580\sb120\sbys \f20 Install\par \pard\plain \s19\qj\li2880\sb120\sbys \f20 The use of Install has been described in the Tutorial.\par \pard\plain \s18\fi-360\li360\ri6580\sb120\sbys \f20 Purge Modules\par \pard\plain \s19\qj\li2880\sb120\sbys \f20 Clears the heap of all modules loaded by your program.\par \pard\plain \s254\qc\sb240\keepn \b\f21 Communication with Quick Edit\par \pard\plain \s17\qj\sb120 \f20 Mops and Quick Edit send Apple events to each other, with a number of benefits.\par \pard \s17\qj\sb120 Of course to use these features, both Mops and QE must be running.  If this isn't so, or if you're running an earlier system which doesn't support Apple events, these commands will be ignored.\par \pard\plain \s20\fi-360\li720 \f20 \bullet \tab If an error occurs during loading a file, Mops sends QE an Apple event asking it to open the source file at the error line.\par \pard \s20\fi-360\li720 \bullet \tab The Mops command "edit someFile" will ask QE to open the given file.\par \pard \s20\fi-360\li720 \bullet \tab The Mops command "openSource someWord" will ask QE to open the source file con\-taining the definition of someWord.  If there's a log file, QE will put the cursor to the start of the definition.  If there isn't, QE will search to the first occurrence of "someWord" in the file (which will probably be at the start of the definition anyway, or maybe in a com\-ment just before).\par \pard\plain \s17\qj\sb120 \f20 In QE, there is now a "Mops" menu with a number of commands:\par \pard\plain \s20\fi-360\li720 \f20 \bullet \tab Load\par \bullet \tab Save and load\par \bullet \tab Save and reload (saves the file, then asks Mops to execute "rl")\par \bullet \tab Clear Stack (command-0).  Also now available in Mops as command-0.\par \pard \s20\fi-360\li720 \bullet \tab Open Source (command-1).  You highlight a word, "someWord" say, then choose this command, and QE asks Mops to execute "OpenSource someWord" as described above.\par \bullet \tab Clear Window (command-2).  Clears the Mops window.  Also available in Mops as command-2.\par \bullet \tab Defined? (command-3).  You highlight a word, then choose this command.  Mops will display a message indicating if the word is defined or not.\par \pard \s20\fi-360\li720 \bullet \tab Forget (command-4).  You highlight a word, then choose this command.  Mops will for\-get down to this word.\par \pard\plain \s255\qr\sb720\sa1440\keepn \b\f21\fs48 \sect \sectd \sbkodd\linemod0\linex0\cols1\colsx0\endnhere\titlepg {\headerl \pard\plain \s244\brdrb\brsp80\brdrhair \tqc\tx4680\tqr\tx9360 \f20 II-\chpgn  Mops General Reference\par }{\headerr \pard\plain \s244\brdrb\brsp80\brdrhair \tqc\tx4680\tqr\tx9360 \f20 \tab \tab Chapter 2\emdash Classes and objects II-\chpgn \par }{\footerr \pard\plain \li200 \f20 {\f21 \par }}\pard\plain \s255\qr\sb720\sa1440\keepn \b\f21\fs48 Classes and objects\par \pard\plain \s17\qj\sb120 \f20 Building a Mops program is largely a process of defining classes of objects\emdash classes which are the "framework" and objects which are the "movers and doers".  In this chapter, we provide you with details of the in\-ner workings of classes and their components, with special emphasis on instance variables and methods.  We'll also discuss several Mops words that may be particularly useful in building your own class defini\-tions.  You won't need to know everything in this chapter to be successful at building classes, but you should at least survey the information.  It may come in handy later, as your programming skills grow.\par \pard\plain \s254\qc\sb240\keepn \b\f21 Planning your subclasses\par \pard\plain \s17\qj\sb120 \f20 Mops comes with many predefined classes\emdash building blocks, which have been designed to be as general as possible.  Your application will probably require more specific behavior than the pre\-defined classes are ca\-pable of, in which case you will want to define one or more of your own subclasses of existing classes.  Your program's unique operations and flavor will be the result of the behaviors you define in your sub\-classes.\par \pard\plain \s254\qc\sb240\keepn \b\f21 The class hierarchy\par \pard\plain \s17\qj\sb120 \f20 Determining the relationship between a new class and existing ones is an important step in designing a Mops program.  The relationship should be guided by the way in which the new class is to rely on instance vari\-ables and methods of classes already defined.\par \pard \s17\qj\sb120 A subclass can add new instance variables to those of its superclass, but it can never redefine the original ones.  Therefore, a new class should be defined as a subclass of another {\ul only} if the instance variables of the superclass are needed for objects of the new subclass.  If you find that an object of a subclass is not using many of the superclass's ivars, then the subclass should prob\-ably be a subclass of a different class.  \par \pard \s17\qj\sb120 Methods, on the other hand, can be redefined in subclasses without hesitation.  It is practical to carry through the methods of the superclass that apply to the subclass, and then redefine or add new ones where needed to give the subclass its unique properties.  Of course, the more methods a subclass inherits, the more compact the code will be.\par \pard \s17\qj\sb120 Multiple inheritance can be a powerful technique if used judiciously.  If overdone it can cause unnecessary complexity, but used wisely it can simplify things considerably.  Let's say a class MyClass has three superclasses, sup1, sup2 and sup3.  In an object of MyClass, the ivars corre\-sponding to sup1 will come first, then those of sup2, then those of sup3.  In typical Forth laid-back manner, we don't check for any clashes in method names in the superclasses.  When we look up a method name in MyClass, we look at the methods declared in MyClass itself first, then in sup1, then in sup2, then in sup3.  If, say, that particular method name had been declared in both sup2 and sup3, the one in sup2 will be used, and the one in sup3 will never be accessible within MyClass.\par \pard \s17\qj\sb120 If more than one of MyClass and any of the superclasses is indexed, we do a check that the speci\-fied indexed widths are the same.  We give an error if this condition isn't met.\par \pard \s17\qj\sb120 Of course this isn't the only possible approach we could have taken to multiple inheritance.  For example we could have had the ivar regions overlay rather than concatenate.  We could do this as an option later, if anyone wants it.\par \pard \s17\qj\sb120 For a good example of the use of multiple inheritance to simplify code, look at the class Ordered-Col in file Struct, and its associated classes.\par \pard\plain \s254\qc\sb240\keepn \b\f21 Choosing between ivars and objects\par \pard\plain \s17\qj\sb120 \f20 In addition to designing the class inheritance of your application, you will have to decide what should be an instance variable and what should be a public object.  Because an instance variable is invisible to objects other than its owning object, any communication between an ivar and other objects must be passed explicitly through the ivar's owning object.  If you find yourself creating numerous "passthrough" methods that are only there to provide access to a single instance vari\-able, you should reconsider your design.  It probably indicates that the instance variable should more appropriately be a public object.\par \pard \s17\qj\sb120 A good example of this kind of realization occurred when we wrote the grDemo source file.  In an earlier version, the three scroll bars were designed as instance variables of the window.  We found, however, that we were sending many messages to the scroll bars by way of the window object.  By changing our strategy and making the scroll bars public objects, the program now has more direct communication to the scroll bars with the added bonus of shortening the source for grDemo by approximately 30 percent.  Ideally, then, your objects should do most of their com\-munication internally (i.e., sending messages to self, super, or ivars).  Keep to a minimum the number of messages that are to be sent between objects.  This minimizes inter-object coupling, makes objects more independent, and makes your application more maintainable.  \par \pard\plain \s254\qc\sb240\keepn \b\f21 When to use ivars\par \pard\plain \s17\qj\sb120 \f20 But there are times when it makes sense to define instance variables, as we originally tried in grDemo.  For example, whenever you find that one object communicates frequently with only one other object, it is likely that one of those objects should be an instance variable of the other.  The same holds true when you find it necessary to create objects in pairs (or other multiples)\emdash instead of creating two similar objects, consider creating a third object that consists of two instance variables.  If the window in grDemo had been intended as a general-purpose class instead of a one-time application, it would have made sense to keep the scroll bars as ivars, because it would be easier to add the entire window to later applications.  \par \pard \s17\qj\sb120 Much of the work that goes into writing a Mops program should be devoted to designing object boundaries.  A well-planned application will be  much more understandable at the source code level.  By clearly defining class functions, a better sense of structure will prevail.  This, after all, is what object-oriented programming is all about, and you will probably need to work with objects for awhile before you really fine-tune your ability to create an optimal design.  The best design is one in which inter-object communication is minimal and well-defined, reflecting clearly the structure of the problem being solved.\par \pard\plain \s254\qc\sb240\keepn \b\f21 Defining a class\par \pard\plain \s17\qj\sb120 \f20 Now, let's take a closer look at the mechanics of building a new class.  A class definition has the following skeletal structure:\par \pard\plain \s8\li720\sb120 \f22\fs20 {\f21 :class   ClassName   super\{ super1 ... superN \}  [ n  indexed ]  [ large ]\line \tab [   instance variable names  ] \line \tab [  method definitions ] \line  ;class}\par \pard\plain \s17\qj\sb120 \f20 In the above example, the brackets indicate optional sections of a class definition.  If you build a class with one superclass that omits all of the optional sections, it will behave in exactly the same manner as its superclass, because you will not have added any ivars or methods to make the new class any different.  {\ul ClassName} is the name that you assign to the new class.  {\ul super1} etc. are the names of existing classes that are to be the basic models for the new class.   The word {\ul indexed}, when pre\-ceded by a number, defines the width in bytes of each indexed instance variable cell for the new class.   An indexed width of 0 indicates that the class is not indexed; if this number is non-zero, the class will require that a number, indicating the number of elements, be on the stack when the class is instantiated (i.e., when you create an object of that class).  Thus,  the line of Mops code, 3 Array A1, builds an {\ul indexed} {\ul object}, called A1, of class Array that has 3 indexed elements.\par \pard \s17\qj\sb120 If you include the word LARGE in your class definition, you are saying that this is an indexed class, and its objects may have more than 32k indexed elements.  Indexing operations on LARGE classes will use 32-bit arithmetic, which will slow accesses very slightly (on 68000-based machines only\emdash Plus, Classic, SE).  No bounds checking is done, since the CHK machine instruction, which we use for bounds checking, uses only 16-bit index values.  For these reasons, don't use LARGE unless you really have to.\par Note that you can declare as LARGE a subclass of an indexed class which isn't LARGE.  But this isn't really a good idea.  Any methods inherited from the superclass won't know that the class is LARGE, so if they try to access the indexed area they won't do it properly.  For example, they will execute a CHK instruction, checking the low 16 bits of the index against the low 16 bits of the limit!  This for sure won't be what you want.  So in this kind of situation, you had better know what you're doing, and only inherit methods which don't access the indexed area.\par \pard\plain \s254\qc\sb240\keepn \b\f21 Ivars\par \pard\plain \s17\qj\sb120 \f20 Next in a class definition come the instance variable declarations, which are simply statements of the form:\par \pard\plain \s8\li720\sb120 \f22\fs20 {\f21 [ # of elements ]  ClassName  ivarName\par }\pard\plain \s17\qj\sb120 \f20 ClassName here is the class that defines the characteristics of the ivar.  Each ivar declaration statement cre\-ates an entry in the private {\ul instance} {\ul variable} {\ul dictionary} of the class currently being defined (See Figure 2-1).   The entry for each ivar contains fields for the header, data, and a pointer to the class specified by the ivar's ClassName.   An instance variable definition is really just a {\ul template} for the private data of the object.  When an object is created, the object's data area is assembled (i.e., memory space is reserved) according to the specifications in the template.\par \pard\plain \s21\qc\sb120\keepn \f20 {{\pict\macpict\picw316\pich326 04b7000000000146013c1101a10064000c574f5244000000000146013c01000a000000000146013c0a0000000000000000340000001a001c008738340036001a005b00873834005a001a0091008738a10096000c0100000001000000000000002c000c00150948656c7665746963610300150d000c2e0004000000002b324b096e616d652f6c696e6ba00097340090001a00b50087383400b4001a00eb008738a10096000c0100000001000000000000002b015a096e616d652f6c696e6ba000973400ea001a010f00873834010e001a0145008738a10096000c0100000001000000000000002801000032096e616d652f6c696e6ba00097a10096000c010000000100000000000000040128002e00270f497661722064696374696f6e617279a0009734006300e0007f013b3834007e00e0009a013b3834009900e000b5013b38a10096000c0100000001000000000000002bce02064f626a656374a00097a10096000c01000000010000000000000004002b0944056976617230a00097a10096000c0100000001000000000000002a1b056976617231a00097a10096000c0100000001000000000000002a1b056976617232a000973400cf001a00eb008738a10096000c0100000001000000000000002800c4003a065e636c617373a00097340075001a0091008738a10096000c01000000010000000000000028006a0037065e636c617373a00097340129001a0145008738a10096000c0100000001000000000000002b03b4065e636c617373a000970affffffffffffffff74001a00640002006c000d006800020064000d006c000d00680002220068000d1300a10096000c0100000001000000000000000401280010003c05436c617373a000970a000000000000000034003900e00064013b38a10096000c010000000100000000000000040028008600300b64617461206f6666736574a000973400a700c5013800c63822013700c5ba002200dc007f3400a10096000c0100000001000000000000002b02590b64617461206f6666736574a00097a10096000c0100000001000000000000002a5a0b64617461206f6666736574a00097a10096000c01000000010000000000000028004900f1094d6f707320696e666fa0009734005200e00064011238a10096000c01000000010000000000000028005e00e6065e636c617373a0009722005b00b72d0022005b00b600b30affffffffffffffff74001a000a008600120091000e0086000a009100120091000e008623db0022000e00a000002200820080370074001a007100d4007900e0007100e0007900d7007100d4007100e022008100b71ef322009e0080210022004800a1005674001a00430086004b00910047008600430091004b00910047008622004700a0f1002200dc00b300b174001a008800d5009000e0008c00e0009000d5008800d5008c00e022008c00b322002200fd008020002200fd00a100aa74001a00a3008600ab009100a7008600a3009100ab009100a700862200a700a0f10074001a00be000200c6000d00c2000200be000d00c6000d00c200022200c2000d130074001a011800020120000d011c00020118000d0120000d011c000222011c000d140074001a00a300d500ab00e000a700e000ab00d500a300d500a700e02200a700d5f000ff}}\par \pard\plain \s251\qc\sb120 \b\f20 Figure 2-1\emdash Instance Variables and Objects\par \pard\plain \s17\qj\sb120 \f20 Notice that the "object" in the above diagram has some "Mops info" at the start\emdash as we men\-tioned in Lesson 5 of the Tutorial, Mops objects have 8 bytes of extra information at the start.  Part of this extra information is a pointer to the class of the object, as we show in the diagram.  (We 'll give the full details of this extra information in the technical section later.)\par \pard \s17\qj\sb120 Then comes the first ivar, so this is the start of the actual data area of the object.\par \pard \s17\qj\sb120 Instance variables are also objects.  The main difference (other than the private/public distinc\-tion) is that they can be declared as part of a "record", and in this case their "Mops information" is omitted, as we discussed in Lesson 5.\par \pard \s17\qj\sb120 In a practical example, a Toolbox Rectangle is stored as 4 consecutive 2-byte integers (the x and y coordinates for the TopLeft and BottomRight corners).  To pass these parameters to the Mac Toolbox, it is most convenient to map this structure with 4 Int ivars (each 2 bytes wide), using the record \{...\} syntax, knowing that the 2 bytes of data for each Int will be adjacent to one another.\par \pard\plain \s22\sb240\keepn \b\f21 {\f23 \'de }For Advanced Mops Programmers:\par \pard\plain \s20\fi-360\li720 \f20 \tab Indexed ivars also have, in addition to the Mops info, a 6-byte indexed header.  The data in the indexed header consists of the number of indexed elements and the length (in bytes) of each element.  This data is used for {\ul range} {\ul checking}.\par \pard\plain \s253\sb240\keepn \b\f21 Ivars as Toolbox data structures\par \pard\plain \s17\qj\sb120 \f20 As you may have noticed in the sample applications in the tutorial, instance variables are very often used as  representations of the data structures that the Macintosh Toolbox expects to see when Toolbox calls are made.  In essence, the list of ivars creates a mapping between the data fields in an object and a structure that the Toolbox recognizes.  The Toolbox structure might only be a subset of the entire body of data in the ob\-ject, as it is in the case of class Window.\par In defining a new class that calls a Toolbox routine, you will often need to map the layout of the class's data structure to mirror a Toolbox data structure (Toolbox data structures are listed at the end of each section of {\ul Inside Macintosh}).  To map the data such that the Toolbox will be able to use it properly,  define all of the Integer or Char fields as Int ivars, and all Long (32-bit) or Pointer fields as Var ivars, and remember to use record \{...\} around the whole group of ivars.\par \pard \s17\qj\sb120 If there is a section of the data record that you will not need named access to (e.g., data that never changes in the course of a program, but must be in the object's data structure for the Toolbox call), you can save ivar dictionary space by using the BYTES pseudo-class to allocate a string of bytes with a single name.  For in\-stance, the following ivar declaration:\par \pard\plain \s8\li720\sb120 \f22\fs20 var\tab v1 \line 20\tab bytes\tab junk\line var\tab v2\par \pard\plain \s17\qj\sb120 \f20 builds a data area that has two 4-byte Vars, v1 and v2, with 20 bytes of data, called junk, between them.  The Toolbox will use this area, but the object will never need to access it directly.  This is more space-effi\-cient than assigning individual names to a lot of little fields\emdash names that will never be used because the data placed there never is used by Mops.  BYTES actually builds an ivar entry of class Object and then reserves a data length equal to the number that you declare.  This means that, if necessary, you can get its address with the addr: method.  But don't send it a length: message, since this will always return zero (the length of an Object).  Note also that BYTES is {\i not} an indexed data type like bArray\emdash it creates one named field, not an ar\-ray of bytes.\par \pard\plain \s253\sb240\keepn \b\f21 How ivars are linked\par \pard\plain \s17\qj\sb120 \f20 Figure 2-2 shows the format of an instance variable dictionary entry.  It bears some similarity to a stan\-dard Mops dictionary entry, except that the ivar name is converted to a hashed value (a compacted form au\-tomatically derived from a complex math algorithm).  All of the ivar entries for a given class form a linked list back to the root of the ivar chain (see the left column of Figure 2-1).  This root is the pseudo-ivar, SUPER (SELF and SUPER exist as instance variables in class META\emdash the superclass of the all-encom\-passing class OBJECT).  The {\ul message} {\ul compiler} detects references to these two special ivars, and begins the method search in a place appropriate for each.  Therefore, when a new class is being defined, the ^class field of SUPER is patched (directed) to the new class's superclass, and that of SELF to the new class itself.   In this way, the search for a given method automatically begins in the proper place for SELF and SUPER references. \par \pard\plain \s21\qc\sb120\keepn \f20 {{\pict\macpict\picw325\pich174 029b0000000000ae01451101a10064000c574f52440000000000ae014501000a0000000000ae01450a00000000000000003400170027003300dc38a10096000c0100000001000000000000002c000c00150948656c7665746963610300150d000c2e0004000000002b4328146861736865642069766172206e616d6520283429a000973400320027004e00dc38a10096000c010000000100000000000000280043003f196c696e6b20746f2070726576696f7573206976617220283429a0009734004d0027006900dc38a10096000c0100000001000000000000002b041b1370747220746f2069766172277320636c617373a00097a10096000c01000000010000000000000028005d00a70420283429a000973400680027008500dc38a10096000c01000000010000000000000028007900381c6f66667365742077697468696e206f776e696e67206f626a20283229a00097340084002700a500dc38a10096000c01000000010000000000000028009500371923206f6620696e646578656420656c656d656e747320283229a00097a10096000c0100000001000000000000000401280009004115497661722044696374696f6e61727920456e747279a00097a10096000c030000000100000000000000040028005200160138a00097a10096000c03000000010000000000000028003700160134a00097a10096000c03000000010000000000000028001c00170130a00097a10096000c03000000010000000000000028006d000f023132a00097a10096000c0300000001000000000000002a1c023134a00097a10096000c0300000001000000000000002a20023136a0009722004000db24000affffffffffffffff64fff800f40010010cff380028220040010000cf64004e012c00660144ff92002822005a00db5200ff}}\par \pard\plain \s251\qc\sb120 \b\f20 Figure 2-2\emdash Instance Variable Fields{\ul \par }\pard\plain \s253\sb240\keepn \b\f21 Potential ivar errors\par \pard\plain \s17\qj\sb120 \f20 There is an {\ul extremely} small possibility that you could get an ivar redefinition error when loading a new class, even if the names of the two ivars in question are different.  Because the names of the ivars are hashed, two different names could conceivably generate the same hash value.  This situation should be extremely rare, since we use a 4-byte hash value.  But if it arises, try a differ\-ent name for one of the ivars.\par \pard\plain \s254\qc\sb240\keepn \b\f21 Methods\par \pard\plain \s17\qj\sb120 \f20 After all of the instance variables are declared, you must write the methods for the new class.  A method definition takes the form (here brackets denote optional sections):\par \pard\plain \s8\li720\sb120 \f22\fs20 {\f21 :m  SELECTOR:  [ \{ named args \\ local vars -- results \} ] \line \tab [ method code ]    ;m\par }\pard\plain \s17\qj\sb120 \f20 A valid selector name (any alphanumerics ending in a colon) must follow the :m (separated by at least one space).  The selector becomes the name of  the new method in the dictionary.  A class's method has access to all public objects, to all instance variables of its own class and all of its superclasses up the chain, and to SELF and SUPER.  A method can use any previous methods already defined in the current class, and can recurse by simply using the name of the method being defined with SELF as the receiver.  Be sure to use SUPER rather than SELF as the mess\-age receiver in a redefined method if you want to call the original method in the superclass. \par \pard\plain \s253\sb240\keepn \b\f21 Special Mops words for primitive methods\par \pard\plain \s17\qj\sb120 \f20 You will find that the methods that you write for classes at the ends of long superclass chains consist pri\-marily of messages to ivars or Self, instead of a lot of Mops words or primitive opera\-tions.  You can see an example of this in the predefined class, Ordered-Col (see Basic Data Structures in Part III), which has several superclasses.  \par \pard \s17\qj\sb120 But you may find it necessary from time to time\emdash especially after you've gained some experi\-ence defining simpler classes\emdash to define a new class that uses primitive methods involving direct access to the class's data area.  An example of this kind of object is class Var in the Struct source file, which manipulates its data di\-rectly.  Several Mops words described below will come in handy for writing primitive methods like this.  \par \pard\plain \s253\sb240\keepn \b\f21 ^BASE and ^ELEM\par \pard\plain \s17\qj\sb120 \f20 You can use ^BASE (pointer to the base address of the current object) from within any method to place the {\ul base} {\ul address} of the current object onto the stack.  ^BASE copies the machine register A2, which always contains the address of the currently executing object.  Note that ^BASE leaves the same address as the phrase Addr: self, or that left by using the name of the object in another word or method.  This address points to the data field of the object, which also happens to be the beginning of its named ivar data area.\par \pard \s17\qj\sb120 Primitive methods generally have to get the base address of the data area, and then perform some kind of fetch or store operation at that address.  The get: method for class LongWord, for instance, could have been defined in the following manner:\par \pard\plain \s8\li720\sb120 \f22\fs20 :m GET:  ^base @  ;m\par \pard\plain \s17\qj\sb120 \f20 which fetches the longword (32 bits wide) at the object's data area.  For a LongWord this is the entire data area, de\-fined as a single ivar: 4 Bytes Data.   The actual definition of get: in class LongWord is somewhat different, since it compiles inline code for speed.\par Because a primitive method will often be the code that gets executed after a long chain of nested messages, it pays to make it as efficient as possible.  Mops has very fast code operations for its most often used primitive methods.  \par \pard \s17\qj\sb120 Indexed classes, for example,  have an extensive set of primitives for their most often-used operations.  LIMIT returns the maximum number of cells allocated to an indexed object.  After the phrase  3 array  a1 (creating an indexed object, a1, of class array, with 3 data cells),  execut\-ing LIMIT within one of A1's methods would produce 3 on the stack.  ^ELEM (pronounced "pointer-to-element") expects an index on the stack to begin with, and leaves on the stack the address of the corresponding indexed element;  it will invoke an error routine if the class is not indexed.  (Incidentally, ^ELEM performs {\ul range} {\ul checking} to make sure the index on the stack is within the range of the index.)  Another fast primitive, IDXBASE, leaves a pointer to the 0th (i.e., the first element) element of an indexed object or ivar  (equivalent to 0 ^ELEM).  \par \pard \s17\qj\sb120 Other optimized primitives you should be aware of are those that access 1, 2, and 4-byte arrays.  Instead of using ^ELEM, it is faster to use ^ELEM1 for 1-byte elements, ^ELEM2 for 2-byte elements, or ^ELEM4 for 4-byte elements.  \par \pard \s17\qj\sb120 Finally, the message width: self will leave the width of an object's indexed elements on the stack.\par \pard\plain \s255\qr\sb720\sa1440\keepn \b\f21\fs48 \sect \sectd \sbkodd\linemod0\linex0\cols1\colsx0\endnhere\titlepg {\headerl \pard\plain \s244\brdrb\brsp80\brdrhair \tqc\tx4680\tqr\tx9360 \f20 II-\chpgn  Mops General Reference\par }{\headerr \pard\plain \s244\brdrb\brsp80\brdrhair \tqc\tx4680\tqr\tx9360 \f20 \tab \tab Chapter 3\emdash More about objects II-\chpgn \par }{\footerr \pard\plain \li200 \f20 {\f21 \par }}\pard\plain \s255\qr\sb720\sa1440\keepn \b\f21\fs48 More about objects\par \pard\plain \s254\qc\sb240\keepn \b\f21 Binding\par \pard\plain \s17\qj\sb120 \f20 As you know, there are two principal states that the Mops system can be in.  When you first start Mops, the system is waiting for your input, ready to {\ul interpret} whatever you enter at the keyboard or from a load file on the disk.  This is known as {\ul run} {\ul state} or {\ul interpret} {\ul state}, and when it is active,  Mops immediately executes whatever word names you enter into the input stream.  On the other hand, you may wish to create colon definitions or methods that compile code to be executed later.  After the Mops interpreter sees a colon (or :m) and before it sees the next semicolon (or ;m),  Mops will be in {\ul compile} {\ul state}, and rather than immedi\-ately execute the words that it sees, Mops will compile code to call those words into the dictionary.  A colon definition is thus a list of calls to other words that will be executed at a later time, when the name of the word is seen in the input stream and the system is in interpret state.\par \pard \s17\qj\sb120 When Mops sees the name of a word and is in interpret state, it attempts to find a string matching the name string of the desired word in the Mops dictionary.  A very fast search word, called FIND, does this in the Mops system.  When you send a message to an object, such as:\par \pard\plain \s8\li720\sb120 \f22\fs20 get: myint\par \pard\plain \s17\qj\sb120 \f20 the first thing that happens is that the selector, Get:, is converted into a unique 32-bit code known as a hash value.  Then the object name, myint, must be looked up in the Mops dictionary and executed to determine the address of its data.  The class of the object myInt is determined, and from that is derived the address in the Mops dictionary of the method that was defined last for that class.  This process is known as the {\ul binding} of a compiled method, and is necessary to determine what code will be processed for that particular mes\-sage.  Note that two different searches must occur before the method can be resolved: the object must be found as a word in the Mops dictionary, and then the compiled method must be found as an entry in the methods dic\-tionary for the object's class.\par \pard\plain \s253\sb240\keepn \b\f21 Early binding\par \pard\plain \s17\qj\sb120 \f20 If we were to enter the above message when Mops was in compile state, the search of both the object and the compiled method would occur at compile time\emdash during the compilation of what\-ever word or method was being defined.  This information would already have been determined by the time that the new defini\-tion was actually executed.  This is the default manner in which Mops compiles messages, and is known as {\ul early} {\ul binding}.   Because most of the work of search\-ing is done at compile time, the execution of the mes\-sage can be very efficient, because it was bound to the actual address of the compiled method in the dictio\-nary. \par \pard\plain \s253\sb240\keepn \b\f21 Late binding\par \pard\plain \s17\qj\sb120 \f20 There are occasions, however, when it is very desirable not to bind the compiled method address when the message is being compiled.  Consider, for instance, a situation in which you have a collection of objects that you need to print on the screen.  You might have rectangles, strings, bitmapped images, and other objects, all in the same collection.  Each of the objects already knows how to print itself by means of a compiled method for Print: that exists somewhere in its inheritance chain.  Your program could be much simpler, however, if it didn't have to explicitly concern itself with the class of a particular object at compile time, but could just send the Print: method to the object and have normal method resolution occur at runtime.  This would allow you could store the addresses of the various objects that need to be printed in an array or list without concern for the class of each one. \par \pard \s17\qj\sb120 The technique just described is known as {\ul late} {\ul binding}, and is used by Smalltalk and other object-oriented languages as the only style of method resolution.  While very powerful and elegant, late binding traditionally has serious performance disadvantages that make most of these languages poor candidates for production of commercial applications.  Because Mops provides {\ul both} late and early binding, you can tailor your applica\-tion for speed or generality where needed.  Even late-bound Mops messages are quite fast, thanks to a highly optimized search primitive.  Late binding makes the various objects in your application highly inde\-pendent of each other, leading to much easier program maintenance.  And late binding can greatly simplify the control structure of your code, because much conditional processing can be handled via class differ\-ences. \par \pard\plain \s253\sb240\keepn \b\f21 Late binding and Toolbox calls\par \pard\plain \s17\qj\sb120 \f20 Mops itself uses late binding within many of its Toolbox class methods.  For example, when the fEvent ob\-ject (a default even object that is predefined in Mops) receives a MouseDown event from the Toolbox, meaning that the user has clicked the mouse button, fEvent hands the process\-ing of the Click over to the window (or menu bar) that was involved.  If the Toolbox tells fEvent that a click was received in the Con\-tent region of a window,  fEvent sends a Content: message to the window involved.  This event must be processed differently according to whether the win\-dow has controls, editable text, graphics, and so on.  In a conventional C or Pascal program, a large switch/case statement would be required that would handle clicks for different types of windows.  In Mops, the differential processing is handled automatically by late binding of the Content: method, because the correct processing will occur for the class of  the actual window involved.  The programmer is then free to define new subclasses of Window with their own Content: methods, and fEvent can still do exactly the same thing.\par \pard\plain \s253\sb240\keepn \b\f21 Early vs. late binding\par \pard\plain \s17\qj\sb120 \f20 You can cause late binding to occur in a particular message with a very simple modification of your source:\par \pard\plain \s8\li720\sb120 \f22\fs20 get:  myint           \\ early binding\line get: [ myint ]        \\ late binding\par \pard\plain \s17\qj\sb120 \f20 In the first example, Mops would determine at compile time the class of the object myInt, and in the second example this resolution would happen at run time.   If myInt is truly an object, using late binding would be a useless waste of time, because the class of myInt could not possibly change.  However, the brackets can en\-close any code sequence that generates an address of a valid object at runtime.  This can be a single Mops word, a sequence of words, messages to other objects,  or anything else.  Some examples:\par \pard\plain \s13 \f22\fs20 \par (A)\tab get: [ dup ]   \tab \\ message receiver is the object whose address \par \tab \tab \tab \tab \\ was duplicated on the data stack.\par \par (B)\tab get: [ i at: myArray ]\tab \\ receiver is the object whose address is\par \tab \tab \tab \tab \tab \\ at element i in myArray.\par \par (C)\tab 0 value  theObject\tab \\ create a Value to hold an object address\par    \tab myInt -> theObject\tab \\ place the address of myInt in theObject \par     \tab get:  [ theObject ]\tab \\ receiver is myInt via theObject\par \par (D)\tab get:  [  ] \tab \tab \tab \\ receiver is object whose addr is top\par \tab \tab \tab \tab \tab \\ of stack\par \pard\plain \s17\qj\sb120 \f20 Since the normal use of brackets in Forth is to turn compilation off and on, this particular inter\-pretation of brackets only applies immediately after a selector, and the regular Forth interpreta\-tion applies otherwise.\par \pard \s17\qj\sb120 To help avoid (or maybe to add to) confusion, we have added two more ways to specify a late bind:\par \pard\plain \s8\li720\sb120 \f22\fs20 method: **\line method: []\par \pard\plain \s17\qj\sb120 \f20 to bind to whatever is on the top of the stack at run time.  {\f4\fs18 method: []}  is really the same as   {\f4\fs18 method: [ ]}   with a space between the brackets.  It is the same syntax as used in JForth with ODE, for the Amiga.\par \pard \s17\qj\sb120 There are situations where you may want to do a late bind in a loop, but where you know that the binding will actually be the same each time around.  We have provided a means by which you can do the binding before entering the loop, and then use the resulting method address in the loop with almost the same speed as early binding.  The syntax is\par \pard\plain \s8\li720\sb120 \f22\fs20 BIND_WITH ( ^obj --<selector> ^obj-modified  cfa )\par \pard\plain \s17\qj\sb120 \f20 If saveCfa and ^obj-mod are values or locals, the usage of this word is:\par \pard\plain \s8\li720\sb120 \f22\fs20 (get object's address)  bind_with someSelector:\line -> saveCfa   -> ^obj-mod\line (in the loop)  ^obj-mod  saveCfa  ex-method\par \pard\plain \s17\qj\sb120 \f20 The use of the modified object address is a bit obscure, and is related to multiple inheritance.  The method you actually end up binding to may be in one of the superclasses, and the ivars for that superclass may not actually start at the beginning of the object.  The modified object address gives the start of the ivars for the superclass, which is the address the method needs to execute.  Anyway, if you just follow the above code, you shouldn't go wrong.\par \pard \s17\qj\sb120 BIND_WITH can do a lot to remove the performance disadvantage of using late binding.  See the file Struct for some more examples, in the (Col) class.\par \pard \s17\qj\sb120 Another thing you will notice in that class is the usefulness of late binding to Self.  This is par\-ticularly so with multiple inheritance.  (Col) knows it will be implementing subclasses multiply inherited with some kind of array, but it doesn't need to worry about what kind of array.  It can simply send messages such as AT: to Self, late-bound, and the right kind of array access will be done.  We have even provided an extra syntax to make this operation look neater, e.g.\par \pard\plain \s8\li720\sb120 \f22\fs20 at: [self]\par \pard\plain \s17\qj\sb120 \f20 Thus the following are all equivalent:\par \pard\plain \s8\li720\sb120 \f22\fs20 aMethod: [self]\line aMethod: [ self ]\line self  aMethod: **\line ^base aMethod: **\par \pard\plain \s17\qj\sb120 \f20 You can take your pick.  But in the case of late binding to Self, I think the first one looks the best.\par \pard\plain \s253\sb240\keepn \b\f21 When to use late binding\par \pard\plain \s17\qj\sb120 \f20 You should be able to see that this is a very general and powerful technique.  As you become more skilled in building object-based applications, you will find yourself using the power of late binding more and more.  The following are some situations in which late binding is particularly useful:\par \pard\plain \s252\sb240\keepn \f21\ul 1.  Forward referencing\par \pard\plain \s17\qj\sb120 \f20 You may find it convenient to create code that sends messages to an object that won't be defined until later in the source code.  For instance, two classes may need to send messages to each other, meaning that one of them will have to be referenced before it is defined.  Cases like this can be easily solved by defining a Value that will hold the actual address of an object at runtime, and compiling late-bound messages using the Value rather than an object, as in example C above.   You could also define a Vect which returns the address of an object when you call it.  Because these usages are so common, Mops allows you to omit the brack\-ets when using a Value or Vect as the receiver of  a message, since in this situation only late binding would make sense.  Thus, if we have\par \pard\plain \s8\li720\sb120 \f22\fs20 0 value  ObjAddr\par \pard\plain \s17\qj\sb120 \f20 the code\par \pard\plain \s8\li720\sb120 \f22\fs20 get: [ ObjAddr ]\par \pard\plain \s17\qj\sb120 \f20 may be written\par \pard\plain \s8\li720\sb120 \f22\fs20 get:  ObjAddr\par \pard\plain \s17\qj\sb120 \f20 with exactly the same meaning.  Mops automatically compiles a late-bound reference whenever a Value or Vect is used in this manner.\par \pard\plain \s252\sb240\keepn \f21\ul 2. Passing objects as arguments\par \pard\plain \s17\qj\sb120 \f20 Frequently, you will find it useful to pass an object as an argument to a Mops word or method.  For instance, the following word computes the difference in the areas enclosed by two rectan\-gles:\par \pard\plain \s8\li720\sb120 \f22\fs20 : ?netArea   \{ rect1 rect2 -- netArea \}\line \tab size: rect1  *  size: rect2  *  -  ;\par \pard\plain \s17\qj\sb120 \f20 In this example, two named input parameters, rect1 and rect2 are the addresses of objects rect1 and rect2, and are used as receivers of size: messages.  This definition compiles exactly the same kind of late-bound reference as if a Value were used.   The size: method is looked up and exe\-cuted at runtime, yielding the dimensions of the rectangle.  The area calculation proceeds easily with that information.\par \pard\plain \s252\sb240\keepn \f21\ul 3. Dynamic objects\par \pard\plain \s17\qj\sb120 \f20 These will be discussed in the next section.\par \pard\plain \s252\sb240\keepn \f21\ul 4. Algorithmic determination of message receivers\par \pard\plain \s17\qj\sb120 \f20 Because you can use any code sequence that results in an object address between brackets, you can algo\-rithmically determine which object will be the receiver of a given message.  This allows you to traverse a list of objects, sending the same message to each one; it also permits sending a message to an object whose ad\-dress came from another source, such as a Toolbox call.  It might be that the routine itself that generates the object address must be dynamically changed at run\-time, in which case you could use a Vect as message re\-ceiver.  This will compile a late-bound reference in which the Vect is executed first, which in turn executes the Mops word whose xt it holds;  this places an object address on the stack that will be the actual receiver of the late-bound message.  By changing the contents of the Vect, you can substitute a new algorithm to generate the object address.\par \pard\plain \s254\qc\sb240\keepn \b\f21 Dynamic (heap-based) objects\par \pard\plain \s17\qj\sb120 \f20 Many applications need to create objects dynamically rather than build them into the dictionary at compile time.  For instance, an application that handles multiple windows cannot know in advance how many win\-dows will be open at any one time.  It would be clumsy to have to prede\-fine a number of windows in the dictionary called Window1, Window2, and so on.  The best approach in this situation is to create a list of window objects that can expand and contract dynamically.  To avoid wasting storage, it is most appropriate to create the window objects on the heap when they are needed, and return the heap to the system when a window is closed.  \par \pard \s17\qj\sb120 Heap-based objects are actually based on a subclass of Handle, called ObjHandle. In this class we provide methods for creating and accessing heap objects.  A heap object can be created thus:\par \pard\plain \s8\li720\sb120 \f22\fs20 ObjHandle  anObjHdl\line ' someClass  newObj: anObjHdl\par \pard\plain \s17\qj\sb120 \f20 Then, to access the object, the method   {\f4\fs18 obj: anObjHdl}   returns a pointer to the object, and also locks the handle so that the object won't be unceremoniously moved while we are doing things with it.  Remember to   {\f4\fs18 unlock: anObjHdl}{\f22  } when finished.  So, using the above example, you can access the object thus:\par \pard\plain \s8\li720\sb120 \f22\fs20 mssg1: [ get: anObjHdl ]\line \tab ...\line \tab unlock: anObjHdl\par \pard\plain \s17\qj\sb120 \f20 When you are completely finished with the object, send  {\f4\fs18 release:\~anObjHdl}.  This will auto\-matically cause a late-bound Release: to be sent to the object itself, before its storage is released, in case it has some heap storage of its own.\par \pard \s17\qj\sb120 If you know that a dynamic object has one particular class, you can avoid the time penalty of late binding to it, as we'll now see.\par \pard\plain \s254\qc\sb240\keepn \b\f21 More ways of early binding\par \pard\plain \s253\sb240\keepn \b\f21 Object pointers\par \pard\plain \s17\qj\sb120 \f20 The idea of an object pointer is to provide a convenient way of early binding to an object whose identity is determined at run time (for example, a heap-based object), but whose class we know at compile time.  In cases like this we would like the efficiency of early binding to the object.\par \pard \s17\qj\sb120 With an objPtr, the class is associated with the pointer at compile time, then whenever an object address is stored in the pointer there is a check that the class of the object matches.  Then after that, sending a method to the pointer actually sends it to the object the pointer points to, with early binding (since we know the class at compile time).  An object pointer is a "low-level" entity, rather like a Value.  The syntax for object pointers is:\par \pard\plain \s8\li720\sb120 \f22\fs20 objPtr  anObjPtr   class_is  theClass\line \tab \tab ...\line ( get obj addr to the stack )  -> anObjPtr\line \tab \tab ...\line aMethod: anObjPtr\par \pard\plain \s17\qj\sb120 \f20 Occasionally, the desired class for an object pointer may not be defined at the time the object pointer needs to be defined.  In this case, use the syntax\par \pard\plain \s8\li720\sb120 \f22\fs20 objPtr  anObjPtr\par \pard\plain \s17\qj\sb120 \f20 then after the class is defined:\par \pard\plain \s8\li720\sb120 \f22\fs20 ' anObjPtr  set_to_class  theClass\par \pard\plain \s17\qj\sb120 \f20 This, of course, must precede any code which sends a message to anObjPtr.  See the file Dialog+ for some examples\emdash there I had to implement methods manipulating a chain of pointers to objects of the same class as was being defined.  For this purpose I put the set_to_class line straight after the :class line, but before the ivars and methods.  This is quite allowable.\par \pard \s17\qj\sb120 Note that the address you store in an objPtr must be an {\b object} address.  If you use ' (tick) or ['] on an object in the dictionary, you will get the cfa of the object, which isn't the same.  As we saw earlier, an object has a pointer to its class at the start (it has some other information there as well).  To get the object address, which is the address of its first ivar, you just use the name of the object without any selector.  Alternatively, if you already have the cfa of the object, use the word >OBJ to convert it to the object address.  So, either of the following will work:\par \pard\plain \s8\li720\sb120 \f22\fs20 anObj  -> anObjPtr\line ' anObj  >obj  -> anObjPtr\par \pard \s8\li720\sb120 \par \pard\plain \s253\sb240\keepn \b\f21 class_as>\par \pard\plain \s17\qj\sb120 \f20 There's a way to force an early bind to an object, without having to set up an objPtr.  The disadvantage is that it's less secure.  With earlier versions of Mops you could say\par \pard\plain \s8\li720\sb120 \f22\fs20 ( obj addr on stack )  aMethod: theClass\par \pard\plain \s17\qj\sb120 \f20 with the object's class being used as the "object" to which the method is sent.  This syntax was available in Neon, but was undocumented (!).  It was, and still is, available in Mops.  It can be dangerous if you don't know what you're doing, since there can't be any check on the real class of the object (since it's not known at compile time), and there isn't even a check that what's on the stack is a legal address.  If it isn't the address of an object of that particular class, an immediate crash is probably the best you can hope for.  But if you know what you're doing this syntax can be very handy.\par \pard \s17\qj\sb120 The only difficulty I have had with it is that in reading code it isn't glaringly obvious that you're not sending a normal message to an object.  If your class names aren't well chosen, it might appear that the thing following the selector is an object name, not a class name, which would give that code quite a different meaning.  (Of course I'm not talking to you, since you always name your classes in such an unambiguous manner that they just couldn't be anything but classes.) \par \pard \s17\qj\sb120 Anyway for those who do sometimes give their classes less than ideal names, with version 2.6 we have a new syntax for the above operation:\par \pard\plain \s8\li720\sb120 \f22\fs20 <obj addr on stack>  msg: class_as> someClass\par \pard\plain \s17\qj\sb120 \f20 The old way will still work - I don't plan to delete it and maybe break existing code - but the new way reads less ambiguously (and compiles exactly the same code).\par \pard\plain \s254\qc\sb240\keepn \b\f21 Public and static ivars\par \pard\plain \s17\qj\sb120 \f20 From version 2.5.1, we have provided some extra features relating to ivars.  Most simple programs won't need these features, but more experienced Mops users may well find them very useful.  (If you're new to Mops, you might want to skip this section.)\par \pard \s17\qj\sb120 Static (or class) ivars belong to the class rather than to an object.  They're rather like globals except that they don't clutter the global namespace.\par \pard \s17\qj\sb120 The syntax for accessing them is just the same as for normal ivars.\par They're declared like this:\par \pard\plain \s8\li720\sb120 \f22\fs20 class myClass super\{ mySuper \}\par \tab var\tab oneVar\par static\par \{\tab var\tab someVar\par \tab int\tab someInt\par \}\par \tab var anotherVar\par \pard\plain \s17\qj\sb120 \f20 \par \pard \s17\qj\sb120 In this example, someVar and someInt are static, oneVar and anotherVar are normal ivars.  In the methods of myClass, whenever you access someVar, you are accessing the SAME ivar, no matter what object you are in, and similarly for someInt.\par \pard \s17\qj\sb120 Public ivars can be accessed from outside the class.  They're declared this way:\par \pard\plain \s8\li720\sb120 \f22\fs20 class myClass super\{ mySuper \}\par public\par \tab var\tab aVar\par \tab int\tab anInt\par end_public\par \tab var anotherVar\par \tab int\tab anotherInt\par \pard\plain \s17\qj\sb120 \f20 \par They're accessed from outside the class via this syntax:\par \pard\plain \s8\li720\sb120 \f22\fs20    msg: ivar> anIvar IN someObject\par \pard\plain \s17\qj\sb120 \f20 (where someObject is an object of myClass, of course.)\par \pard \s17\qj\sb120 I've considered adding this feature to Mops for some time,doing this for some time, with mixed feelings, but eventually decided it was worth it in some situations where otherwise I'd need to define dozens of pass-through methods.  It may not be brilliantly elegant, but it's very practical.  \par \pard \s17\qj\sb120 This is really an extension of the public/private distinction which we already have for methods.  The default is for ivars to be private, and ivars to be public.  You can now use PUBLIC or PRIVATE anywhere in the ivar list or method declarations of a class to change this default.  You can use END_PUBLIC or END_PRIVATE to restore the default.\par \pard \s17\qj\sb120 If you combine these two new features, you can get a "public static" ivar.  To access this from outside the class, you can't use the above syntax since there's no object to refer to.  So the syntax is:\par \pard\plain \s8\li720\sb120 \f22\fs20 \tab msg: ivar> aStaticIvar IN_CLASS myClass\par \pard\plain \s17\qj\sb120 \f20 \par \pard\plain \s255\qr\sb720\sa1440\keepn \b\f21\fs48 \sect \sectd \sbkodd\linemod0\linex0\cols1\colsx0\endnhere\titlepg {\headerl \pard\plain \s244\brdrb\brsp80\brdrhair \tqc\tx4680\tqr\tx9360 \f20 II-\chpgn  Mops General Reference\par }{\headerr \pard\plain \s244\brdrb\brsp80\brdrhair \tqc\tx4680\tqr\tx9360 \f20 \tab \tab Chapter 4\emdash Putting together a Mops application II-\chpgn \par }{\footerr \pard\plain \li200 \f20 {\f21 \par }}\pard\plain \s255\qr\sb720\sa1440\keepn \b\f21\fs48 Putting together a Mops application\par \pard\plain \s17\qj\sb120 \f20 Once you have a blueprint for the class hierarchy of a program, you're ready to structure the pro\-gram, actu\-ally write the source code, and then assemble the pieces into a self-running Macintosh application.  In this chapter, we provide the details for the following steps:\par \pard\plain \s20\fi-360\li720 \f20 \bullet \tab Structuring the program for keyboard and/or mouse input;\par \bullet \tab Creating readable source code files;\par \bullet \tab Compiling your code and predefined classes with load files;\par \bullet \tab Debugging the program;\par \bullet \tab Installing the program as a standalone application.\par \pard\plain \s254\qc\sb240\keepn \b\f21 Structure of a typical application\par \pard\plain \s17\qj\sb120 \f20 In most Mops programs for the Macintosh, a handful of classes will be the primary, high-level building blocks for your application.  Into these blocks go the specific processing that make your program unique.\par \pard \s17\qj\sb120 {\ul Windows} tend to contain the major sections or "mini-applications" within your code.  They will contain a number of {\ul Views}, each of which will handle its own area of the window.  The views will probably have a number of subclasses to handle the different kinds of items in the window.  {\ul Controls} are one such subclass of View, and usually determine control paths within a given part of the application, or can be used to provide a more convenient mechanism for setting options.  Much of the important code in your application will probably be called via the DRAW: and CLICK: methods of these various View classes.\par \pard \s17\qj\sb120 {\ul Menus} give the user a means to choose another part of the application or to alter an option setting.\par And {\ul Dialogs} are special-purpose windows that focus the user's attention on a specific choice or set of choices.  \par \pard\plain \s254\qc\sb240\keepn \b\f21 Bringing objects to life\par \pard\plain \s17\qj\sb120 \f20 All of the above classes create objects that are recognized by both Mops and the Toolbox.  When your application starts up, it generally must send New: or GetNew: messages to all of these dual role objects (Mops and Toolbox objects that are needed immediately.  Such messages cause the objects to make them\-selves known to the Toolbox, and to allocate any heap data that the Toolbox needs to keep track of the objects' states.  Then the application will begin listening to events\emdash thereby becoming sensitive to the user's keyboard and mouse input.  \par \pard\plain \s254\qc\sb240\keepn \b\f21 Waiting for events\par \pard\plain \s17\qj\sb120 \f20 Mac applications, rather than simply starting at the beginning and working through to the end, are {\ul event driven}.  That is, they basically sit waiting for the user to ask for something to be done, by clicking, typing a key, selecting a menu or whatever.  When something has to be done, the program is notified via an event.  The program acts on the event, and then waits again.  The wait\-ing loop is called, naturally enough, the {\ul event loop}.  Mops simplifies this for you by providing a word, EventLoop, which executes this loop.  The definition isn't very complex:\par \pard\plain \s8\li720\sb120 \f22\fs20 : EVENTLOOP\line \tab BEGIN\line \tab \tab next: fevent\line \tab AGAIN ;\par \pard\plain \s17\qj\sb120 \f20 FEvent is our one-off object of class Event.  The next: method makes the system call WaitNextEvent, which returns to the program when an event is ready.  The next: method then executes the appropriate action handler which Mops has set up for this kind of event.  This will usually lead to a message being sent to some object in your program.\par \pard \s17\qj\sb120 The grDemo source file (explained in the Tutorial) provides a simple example of an event-driven Mac application, and is worth examining rather closely for the manner in which the program and user communicate with each other.{\b\ul \par }\pard\plain \s254\qc\sb240\keepn \b\f21 Apple events\par \pard\plain \s17\qj\sb120 \f20 Mops is "System 7 friendly".  Among other things, this means that it recognises Apple events, which are described in Inside Macintosh, volume VI.  Mops handles the "core" Apple events: OpenApplication, OpenDocuments, PrintDocuments and QuitApplication.  These have to be available in the nucleus, so that the nucleus can be properly System 7 friendly.  We have pro\-vided handlers for these Apple events, as required by Apple, and also four corresponding vectors so that your application can customize things.\par \pard \s17\qj\sb120 The handlers do some setting up, call the appropriate vector, then do some winding up.  These handlers are :PROC routines\emdash they get called from the system, and return to the system.\par \pard \s17\qj\sb120 When an Apple event handler is called from the system, there are three parameters on the stack:\par \pard\plain \s8\li720\sb120 \f22\fs20 ( ^AE ^AEReply RefCon -- )\par \pard\plain \s17\qj\sb120 \f20 ^AE is a pointer to the Apple event itself.  ^AEReply is a pointer to an Apple event that can be used for a reply from the handler.  RefCon is a longword that has been associated with this par\-ticular Apple event by the caller\emdash this can be used for anything.  The Mops Apple event handlers first call the word AEhandler, which does the setup housekeeping.  It pops these parameters into the values  fAE, AEReply and AERefCon.  It then redirects AbortVec and QuitVec, first saving the old values.  This is because within a :PROC routine we mustn't Quit or Abort.  If either of these is called during the execution of the Apple event handler, a Mops error number is put in the value (ERR#), and the handler winds itself up and returns to the system.  Back in the Mops event handling code, which originally called the system to handle the Apple event, we bring up a Mops error in the usual way.\par \pard \s17\qj\sb120 After calling AEhandler, the Mops Apple event handlers call their particular vector to do what\-ever processing is necessary to handle this Apple event.  They then branch to some common windup code which takes some action depending on the result returned from the vector (see below), then restores the previous values of QuitVec and AbortVec and returns to the system.\par \pard \s17\qj\sb120 The Apple event vectors are OpenAppVec, OpenDocVec, PrintDocVec and QuitAppVec.  We will now describe the first three of these, and leave QuitAppVec for later, as it is the exception.\par \pard \s17\qj\sb120 These three vectors have the stack effect\par \pard\plain \s8\li720\sb120 \f22\fs20 ( -- code True  |  -- False )\par \pard\plain \s17\qj\sb120 \f20 If False is returned, the default handler windup is used, which performs the recommended system calls to check if we got all the parameters and return the appropriate error if not.  If True is returned, we assume that the event has been fully handled within the vector routine, and so we return straight to the caller - the code is the result code that gets passed back.  The default for these vectors assumes that the Mops development environment is running, and does the appro\-priate things.\par \pard \s17\qj\sb120 The current Mops setting for some of these vectors may be adequate for your application.  As set up in Mops, OpenAppVec simply returns False and does nothing else.\par \pard \s17\qj\sb120 OpenDocVec finds the number of files in the given list of files, and puts the number in the value #DocsToOpen.  It then handles each file in the given list of files by opening it using the default file object fFcb, then calling the vector Read1DocVec to read and close it.  If this is sufficient for your application, you will just have to redirect Read1DocVec appropriately, as we describe in the next paragraph.  As set up, Read1DocVec assumes the file is a Mops dictionary.\par \pard \s17\qj\sb120 Read1DocVec must point to a routine which will read the file designated by the file object fFcb, close it, and return a result on the stack.  True indicates the OpenDocVec loop can continue.  False means the loop must terminate.  You could return False, for example, on an error, or sim\-ply if your application can't accept more than one document open at a time.\par \pard \s17\qj\sb120 PrintDocVec is set to the same routine as OpenDocVec, since it doesn't make sense to try to print a Mops dictionary.  Your application really ought to do something different.\par \pard \s17\qj\sb120 QuitAppVec is the exception, in that it is NOT called from the QuitApplication Apple event handler.  This is because if you try to quit to the Finder from inside an Apple event handler, you'll crash!  You MUST return in the normal way from an Apple event handler, or the system won't be pleased with you at all.  So what our QuitApplication handler does is set a flag QuitApp? and return.  Then back in normal Mops execution, after handling an Apple event, we check if QuitApp? is True, and if so, we execute QuitAppVec.  This code is in the source file Event.  The current setting for QuitAppVec is simply to call BYE.  Your application will proba\-bly want to do something a bit more intelligent.\par \pard \s17\qj\sb120 Well, sorry about that terribly long-winded dissertation on Apple events.  They do represent a major new addition to Apple's system, and are decidedly non-trivial to handle and describe!  I have tried to make the relevant comments in the nucleus source code reasonably full.  This is in the file Nuc1.asm.\par \pard\plain \s254\qc\sb240\keepn \b\f21 Compiling your source\par \pard\plain \s17\qj\sb120 \f20 As you write portions of your program, you can load them into Mops (they compile while load\-ing) to let the compiler search the code for errors and to let you fully test how well the code exe\-cutes.  You won't neces\-sarily save the compiled program until a logical section is completed and debugged\emdash once you save a com\-piled chunk of code, you will no longer be able to edit what is saved.  Instead, while you're reworking a section, you should maintain your program as text files and load them into Mops each time you want to test the code.\par \pard \s17\qj\sb120 When you load a typical program, you will be doing so on top of Mops.dic (or MopsFP.dic), which contains a number of\emdash but not all of\emdash Mops's predefined classes already compiled.  It is important to understand how source files for your program and the optional predefined classes should be loaded onto Mops.dic.  When you loaded the grDemo in the Tutorial several prede\-fined classes were automatically loaded before loading in the grDemo code.  This was done by the NEED command at the start of the grDemo file.  The sequence of loading is important, but can easily be handled by NEED.\par \pard\plain \s253\sb240\keepn \b\f21 Switching between compiler and editor\par \pard\plain \s17\qj\sb120 \f20 When you compile a source file the first time, you may discover that an error crops up, at which point, the compiler displays a message directing you to the problem area and stops loading.  You'll then want to go back into the source file to remedy the problem.  This can be done as sim\-ply as switching windows to your editor.  If you're using Quick Edit, it will have already scrolled your source file to the right place.\par \pard \s17\qj\sb120 Your process of program building will take the following steps:\par \pard\plain \s20\fi-360\li720 \f20 \bullet \tab Using the editor, load an existing source file or create a blank page for new work.\par \pard \s20\fi-360\li720 \bullet \tab After entering a few definitions, you may want to test them.  Save your work in the editor (an easy step to forget!), switch to the Mops window and type L (for load), or choose Load... from the File menu, or type Command-L.  A dialog box will come up.  Select your source file, and it will load.  Alternatively you may type // followed by the name of your source file, if you don't want to have to reply to a dialog box.\par \bullet \tab After doing this once, you can reload the same file (having made changes or additions) by typing RL.  Mops remembers which source file you are using, via a special dictionary entry which is added automatically when a file begins loading.  When you type RL, Mops first does a FORGET back to that point in the dictionary, then loads the file.  If you just want to FORGET back to that point but not load the file, type FM (Forget to Mark).\par \pard \s20\fi-360\li720 \bullet \tab In the event that you made a mistake in your coding, Mops will report an error of some sort.  Switch to the editor window, edit your source file, save, switch back, and RL.\par \pard\plain \s17\qj\sb120 \f20 If you have been accustomed to working with a compiled language like C or Pascal, you might be somewhat startled by the immediacy of Mops while you are in the editor.  It can speed your development time tremen\-dously to be able to interact with the language as you write, and you should learn to do this often (sometimes it's easy to forget).  Frequently, in the time that would be taken to remember something while editing, you could have gotten an answer directly by using the full power of Mops's interpreter.\par \pard\plain \s253\sb240\keepn \b\f21 Saving compiled programs\par \pard\plain \s17\qj\sb120 \f20 You can Save an image of the dictionary at any point during compilation of your source (this is different from installing a finished application, as described later), by selecting Save as\'c9 from the File menu.  This creates a binary image on disk of that portion of the dictionary from the top of the nucleus up to the last word compiled.  Save your work often, because you can always use FORGET or FM to remove any part of the dictionary other than the nucleus.  It is good to do a Save just before loading any file that is in a questionable state or in the process of being debugged.  Then, if the machine crashes, you need only double-click on the saved image's icon to get right back to where you were. \par \pard \s17\qj\sb120 You can have several saved images on a disk, without causing any problem.\par \pard \s17\qj\sb120 Incidentally, Mops has a powerful {\ul file} {\ul stack} facility that allows you to nest loads up to six deep.  Thus, a file loaded by NEED can also NEED other files.  When this happens, Mops stacks the currently open file (i.e., tem\-porarily interrupt loading of one file) and begins loading the new file.  When the second file load is complete, the load of the original, stacked file resumes on the line following the NEED statement.\par \pard\plain \s253\sb240\keepn \b\f21 Other compiling tips\par \pard\plain \s17\qj\sb120 \f20 When loading a file that has never before been compiled, select Echo During Load from the Mops menu to cause each line of the file to be echoed to the screen as it is loaded.  If an error occurs while you're watching a file load, you'll have a much better idea of where the problem is.  \par \pard \s17\qj\sb120 For files that you know well,  disable Echo During Load for a much faster load, but you won't get as detailed messages if an error occurs during compilation.  You might then use WORDS to determine the last name loaded into the dictionary\emdash this should be the name of the word contain\-ing the error.   \par After an error, Mops prints the contents of the file stack\emdash the file at the top of the stack is this file containing the error.  You can pause an echoed load at any time by hitting the space bar.  You can then either continue (by pressing the space bar again), or abort the load (by pressing a different key).\par \pard\plain \s254\qc\sb240\keepn \b\f21 Debugging your code\par \pard\plain \s17\qj\sb120 \f20 You should begin debugging as soon as you have a small section of code that compiles success\-fully.  Start testing the lowest-level words or methods first, so that you can establish a firm base of code that you have confidence in.  Call these words interactively (i.e., from the Mops prompt), setting up reasonable parameters on the stack, and then using the .S stack dump to determine if the results are correct.  You can also use the Debugger utility to step through a definition instruc\-tion by instruction.  We will describe this utility shortly.\par \pard\plain \s253\sb240\keepn \b\f21 Evaluating Mops error messages\par \pard\plain \s17\qj\sb120 \f20 It's quite possible that in the early stages of program development, you'll generate a Mops error during exe\-cution or compilation of a word or method.  If this is the case, find the error in the Error Handling section of this manual, and try to determine the precise cause in your code.   \par \pard \s17\qj\sb120 Frequently, Mops might catch an error that is actually an indirect result of another problem which Mops did not catch.  For example, if your code accidentally overwrites the header of a previously defined array, upon execution, the error will point to the array, when, in actuality, the problem is with the errant code.  Another example would be a number accidentally left on the stack that doesn't interfere with execution until much later in the program.  In cases like these, you must work backwards, tracing the origins of each value on the stack, and seeing if it makes sense.  Eventually, you will find the word that is producing an incorrect result, and make a change in the source code accordingly.  It can be very helpful to place statements in your code that print out key data values.  \par \pard\plain \s253\sb240\keepn \b\f21 System errors\par \pard\plain \s17\qj\sb120 \f20 Sometimes, your code will produce an error that is caught by the Macintosh system before Mops becomes aware of it.  In these cases, unless you have Macsbug installed, you will get the "bomb box".  The most common system error codes are 2 (when the CPU tries to access an illegal address)  and 3 (when the CPU attempts to execute data as code).  You'll probably have to reset your Mac if you're not using Macsbug, but if you are using Macsbug (always a good idea when testing code) you may be able to resume by typing:\par \pard\plain \s8\li720\sb120 \f22\fs20 a5=currenta5\line g 1e4\par \pard\plain \s17\qj\sb120 \f20 Sometimes, however, enough "damage" will be done to the heap or 68000 register contents to necessitate a restart, even with Macsbug installed.  Therefore, be sure you save your source code files.  This will provide you with a safe record of the code that caused the errors.\par \pard \s17\qj\sb120 If you tried to execute a @ or W@ operation on an odd address, such as 2001, you would gener\-ate a System Error 2 (only on 68000 CPUs).  The 68000 processor has a set of instructions that are optimized for even addresses, and some Mops words use these instructions in their code.  Odd address errors can be caused directly in the manner described, but are more likely to result from a different problem that just happens to generate an odd number which then gets used as an address.\par Macs with 68030 or 68040 CPUs won't generate odd address errors, but will give a "bus error" if something is used as an address which is outside the range of legal addresses for that machine.  As with odd addresses, these are most likely to arise from some other problem which leads to something being used as an address which isn't really an address.  Note that we store an illegal address value, which is also odd, in nil handles and pointers.  Thus any attempt to use a nil han\-dle or pointer will give either an odd address error or a bus error depending on the CPU.\par \pard \s17\qj\sb120 Any fatal system error is best tracked down by first finding the precise location where the error occurs.  Do this by testing words interactively, and then reasoning out why the offender isn't working prop\-erly.\par \pard \s17\qj\sb120 A System Error 28 means that the system stack (the Mops data stack) has grown down into the top of the heap.  Because Toolbox routines use the system stack for their data storage, stack over\-flow can occur if a deeply nested Mops word calls a Toolbox routine that uses a lot of stack.  You can use the Install utility (described in the Tutorial) to adjust the proportions of heap avail\-able for the stack and the dynamic heap.\par \pard \s17\qj\sb120 Some errors may cause the machine to lock up, make strange sounds, or break up the video.  In these cases, the code has destroyed something essential to the operating system before either Mops or the Macintosh Operating System could detect it.  The only choice here is to reset the Mac and try to determine where the code is going wrong.  You might want to scatter ." messages through your code, which can print values and strings to keep you posted on where the code is executing at a given moment.  This will help you narrow down the location of a problem fairly quickly. \par \pard\plain \s254\qc\sb240\keepn \b\f21 Your application's icons\par \pard\plain \s17\qj\sb120 \f20 We have already described the use of the Install utility in the last Tutorial lesson.  Here we will discuss how to give your application and its documents their own icons.\par \pard \s17\qj\sb120 There is a complex interplay of resources within a Macintosh application that describe an appli\-cation and its icons to the Finder.  You may want to read 'Structure of a Macintosh Application' in Inside Macintosh before proceeding, especially if your application manipulates its own docu\-ment files.  We will describe here only the steps that relate to Mops and your application.\par \pard \s17\qj\sb120 When you first use Install to create your application, it has no icons.  You can use ResEdit, Icon Edit or various other utilities to create icons.  If you give them the expected resource IDs, you can paste them straight into your application using ResEdit.  The expected IDs are 128 for the application itself, and 129 to 132 for the various document types which your application uses.  Your icon editing utility will have a way of specifying the resource IDs of the icons.\par \pard \s17\qj\sb120 Assuming you have created a resource file using one of these utilities, and that you have given the icons the right IDs, do the following:\par \pard\plain \s20\fi-360\li720 \f20 1.\tab Start ResEdit, then open both your new application and your icon resource file.\par 2.\tab Select your icon file, and do Select All (Command-A), then Copy.\par 3.\tab Select your application.\par 4.\tab Do Paste, then Save.\par 5.\tab Quit ResEdit.\par \pard\plain \s17\qj\sb120 \f20 Your application may not appear with its new icon immediately, since the Finder keeps icon information in its own "desktop file".  If you close and then open the window containing your application, this may cause the Finder to recognize the new icon.\par \pard\plain \s255\qr\sb720\sa1440\keepn \b\f21\fs48 \sect \sectd \sbkodd\linemod0\linex0\cols1\colsx0\endnhere\titlepg {\headerl \pard\plain \s244\brdrb\brsp80\brdrhair \tqc\tx4680\tqr\tx9360 \f20 II-\chpgn  Mops General Reference\par }{\headerr \pard\plain \s244\brdrb\brsp80\brdrhair \tqc\tx4680\tqr\tx9360 \f20 \tab \tab Chapter 5\emdash Memory Organization II-\chpgn \par }{\footerr \pard\plain \li200 \f20 {\f21 \par }}\pard\plain \s255\qr\sb720\sa1440\keepn \b\f21\fs48 Memory Organization\par \pard\plain \s17\qj\sb120 \f20 We will now move on to some of Mops's more advanced capabilities.  Some of the ideas and terms we'll be describing are more fully explained in {\ul Inside} {\ul Macintosh}, and we'll direct you to the appropri\-ate IM sections when necessary.  Finally, if you wish to gain deeper understanding of the specialized com\-piling words that operate inside Mops (derived from the Forth language), we suggest you read one of several commercially available Forth texts listed in the references at the end of this chapter.\par \pard \s17\qj\sb120 Because of the way the Macintosh manages memory,  Mops has several distinct areas in which it stores data.  The following diagram gives a typical picture of the Mac's memory while a Mops program is running.  If you're new to Mac programming, don't worry about what everything in the diagram means at this stage\emdash we'll describe the main things you need to know as we go along.\par \pard\plain \s21\qc\sb120\keepn \f20 {{\pict\macpict\picw294\pich613\picscaled 06c20000000002b9014e1101a10064000c574f52440000000002b9014e01000a0000000002b9014e0a0000000000000000340000004602b800d9382002990046029900d820026c0046026c00d8a10096000c0100000001000000000000002c000c00150948656c7665746963610300150d000a2e0004000000002802ab00690e53797374656d20676c6f62616c73a00097a10096000c010000000100000000000000280285006e0b53797374656d2068656170a000972002340046023400d8a10096000c02000000010000000000000028024e00561c28706f737369626c79206f74686572206170706c69636174696f6e0d2b2a0c067a6f6e657329a000972002030046020300d8a10096000c01000000010000000000000028021d0066104d6f7073206b65726e656c20636f6465a000972001c2004601c200d8a10096000c0100000001000000000000002801e5006c0f4d6f70732064696374696f6e617279a000972001860046018600d8a10096000c0100000001000000000000002801a5004a1e537061636520666f722064696374696f6e61727920657870616e73696f6ea0009722017400030000220021004600002000230046002300d8a10096000c010000000100000000000000280014006612566964656f2c20736f756e642c206574632ea000972000580046005800d8a10096000c02000000010000000000000028003a00561c28706f737369626c79206f74686572206170706c69636174696f6e0d2b2a0c067a6f6e657329a000970affffffffffffffff74001a01b0008701bb008f01b0008b01bb008f01bb008701b0008b2201cc008b00ef2000700046007000d82000830046008300d82000a4004600a400d8a10096000c01000000010000000000000028006800740a4a756d70207461626c65a00097a10096000c01000000010000000000000028007c005c164170706c69636174696f6e20706172616d6574657273a00097a10096000c0100000001000000000000002b081b11517569636b4472617720676c6f62616c73a0009722008300dc1500a10096000c01000000010000000000000028008700f81243757272656e7441352028676c6f62616c29a000972200580040cd0074001a005800140063001c005800180063001c0063001400580018200063001800f8001874001a022900150234001d02340019022900150229001d023400192002290019014e00192202030101de0074001a01f800e7020300ef020300eb01f800e701f800ef020300eb2201f800eb00f82201cd0101de0074001a01cd00e701d800ef01cd00eb01d800ef01d800e701cd00eb2201d800eb0005a10096000c0100000001000000000000002801d10109024133a00097a10096000c0100000001000000000000002801eb00e30333324ba0009774001a01c300e801ce00f001ce00ec01c300e801c300f001ce00ec2201c300ec00e92201730101de0074001a017300e8017e00f0017300ec017e00f0017e00e8017300ec22017e00ec0012a10096000c0100000001000000000000002801780109024134a00097a10096000c0100000001000000000000002801a200e20536344b2d32a00097a10096000c020000000100000000000000280118000d054d6f70730d28012400020c6170706c69636174696f6e0d2b0c0c047a6f6e65a00097220234003fcd00a10096000c0100000001000000000000002b73340546726565202a0c0468656170a0009720014a0046014a00d820011d0046011d00d8a10096000c01000000010000000000000028013700650f41206c6f61646564206d6f64756c65a0009722014a0100de0074001a013f00e6014a00ee014a00ea013f00e6013f00ee014a00ea22013f00ea00f82201140100de0074001a011400e6011f00ee011400ea011f00ee011f00e6011400ea22011f00ea0005a10096000c0100000001000000000000002801190109024135a00097a10096000c01000000010000000000000028013200e30333324ba000972000b9004600b900d874001a00bc008700c7008f00c7008b00bc008700bc008f00c7008b2200b4008b0008a10096000c0100000001000000000000002800b2006e0c52657475726e20737461636ba000972000cc004600cc00d82000e0004600e000d874001a00e5008800f0009000f0008c00e5008800e5009000f0008c2200dd008c0008a10096000c0100000001000000000000002b05270a4461746120737461636ba000972200b90100de00a10096000c0100000001000000000000002800bd0109024137a000972200e00100de00a10096000c0100000001000000000000002a28024136a00097a10096000c0100000001000000000000002800fd00800546726565202a0c0468656170a00097ff}}\par \pard\plain \s251\qc\sb120 \b\f20 Figure 5-1\emdash Mops Memory map{\ul \par }\pard\plain \s254\qc\sb240\keepn \b\f21 The Mops Dictionary\par \pard\plain \s17\qj\sb120 \f20 Near the beginning of this manual we said a Mops program builds a dictionary of words.  Each word and its definition occupies a portion of the computer's memory.  A Mops defini\-tion consists of several parts, including information like whether a word is a value or a colon defini\-tion, the numbers or other data associated with the word, and machine instructions which carry out the operations specified for that word.  In Mops, the areas reserved for those parts of a defi\-nition are called {\ul fields}.\par \pard \s17\qj\sb120 Most Mops words have four fields that you should be aware of:\par \pard\plain \s8\li720\sb120 \f22\fs20 link field\line name field\line handler field\line code field\par \pard\plain \s17\qj\sb120 \f20 and they look like this in memory:\par \pard\plain \s21\qc\sb120\keepn \f20 {{\pict\macpict\picw157\pich242 021a0000000000f2009d1101a10064000c574f52440000000000f2009d01000a0000000000f2009d200039004700b90047200039009c00b9009c2200470047550022005b0047550022007a0047550022008900475500a10096000c0100000001000000000000002c000c00150948656c7665746963610300150d00092e0004000000002b54080a4c4f57204d454d4f5259a0009774001a000f006d001d0077000f0072001d0077001d006d000f0072070002000222002b007100f174001a00d3006d00e1007700e1007200d3006d00d3007700e100722200c40071000ea10096000c0100000001000000000000002ae60b48494748204d454d4f5259a00097a10096000c0100000001000000000000002c000800140554696d657303001428003e00570f2870726576696f757320776f726429a00097a10096000c0100000001000000000000000d000c2b0e2f044e616d65a00097a10096000c0100000001000000000000002800540068044c696e6ba00097a10096000c01000000010000000000000028008700620748616e646c6572a00097a10096000c0100000001000000000000002b061604436f6465a0009707000100012200ab00475500a10096000c0100000001000000000000000d00092800b8005d0b286e65787420776f726429a0009707000200022200470039f100230041230f00a10096000c0100000001000000000000000d000c28006a000206486561646572a00097ff}}\par \pard\plain \s251\qc\sb120 \b\f20 Figure 5-2\emdash Fields in a Dictionary Entry\par \pard\plain \s17\qj\sb120 \f20 The link, name and handler fields are usually grouped together as the header field.  The name field holds the actual name of the word.  Its length varies with the length of the name.\par \pard \s17\qj\sb120 The link field helps Mops programs compile quickly.  In the link field is the address of an earlier word in the dictionary.  This facilitates the search through the dictionary each time you type a previously defined word.  The search starts at the most recently defined word (the word nearest high memory).  If there is no match in the first word, the search looks to the link field for the address of the next word on which to attempt a match, and so on backward through the dictio\-nary.  The length of the name and parameter fields can change from definition to definition so there is not a fixed memory interval between words.\par \pard \s17\qj\sb120 The content of the handler field specifies whether the word is a colon definition,  a value, and so on.  The handler field usually contains a negative integer, unique for each word type.  When the word is compiled, the handler field is used to transfer control to the right part of the Mops com\-piler to compile words of this type.\par \pard \s17\qj\sb120 For normal colon definitions, the code field contains executable code\emdash the code that was com\-piled when the definition of that word was read by Mops.  If you later type the word name at the keyboard, Mops looks at the handler field, sees that it is a colon definition, and transfers control to the beginning of the code field.  Your compiled code is then executed.  At the end of the def\-inition, where you had put the semicolon, there is a machine language "return" (RTS) instruction.  This causes control to return to the Mops interpreter.\par \pard \s17\qj\sb120 If, instead of typing your word at the keyboard, you put it into another definition, the process is rather similar, except that instead of calling your definition directly, Mops compiles a machine language call instruction at that point, to do the calling.  Then, when the later definition executes, and that call instruction is reached, your earlier definition is called.\par For Mops word types other than colon definitions, the code field doesn't necessarily contain code.  For example, for values and constants it contains the actual 4-byte value.  In this case we call this field the "data field", since it contains data.  But it is really the same field by a different name.\par \pard\plain \s254\qc\sb240\keepn \b\f21 The kernel or nucleus\par \pard\plain \s17\qj\sb120 \f20 In the diagram, you'll see that above some memory areas used by the Mac system is the {\ul Mops kernel code}.  The {\ul kernel} (also known as {\ul nucleus}) is the lowest, most elemental part of the Mops dictionary\emdash that part of Mops without any predefined classes.  It is what is loaded into memory when you double-click the Mops application icon itself.  Saved Mops images, such as Mops.dic, appear to the Finder as documents with Mops as their owner. Therefore, when you open a saved Mops image, the Finder starts the Mops kernel as the application, and passes the name of the saved image file to the Mops kernel as a parameter (see Inside Macintosh for more detail on this).  The Mops kernel then determines whether the file is a valid Mops image file, and, if so, loads it in an area of memory above the kernel.  (This way of doing things is very efficient for development, since the image saved is the document you have been working on. You may say many variations of this document without changing the application itself)\par \pard \s17\qj\sb120 The memory area dedicated to the Mops kernel and other specifics of your program is known as the {\ul application} {\ul heap}, or simply the {\ul heap}.\par \pard\plain \s254\qc\sb240\keepn \b\f21 The heap\par \pard\plain \s17\qj\sb120 \f20 The heap is a region of memory that can be divided into smaller sections, called blocks.  When a program needs some memory temporarily, it can ask the Macintosh Memory Manager for a block of heap, and later give it back when it is done.  This is what the Mops kernel does at startup in order to acquire memory for future expansion of the Mops dictionary.  Mops requests a block of heap that will be large enough to allow for expansion of the user dictionary, but will leave enough room for both the system and Mops to use on a temporary basis (dynamic heap) as the program executes.  Exactly how much memory is to be devoted to the dynamic heap can be altered by the Mops Install utility, which was described in lesson 21 of the Tutorial.\par \pard \s17\qj\sb120 Many parts of Mops and the Mac Operating System rely upon dynamic heap.  For instance, when your application requires a resource, such as a font, to be loaded from disk, the Font Manager places the font in the dynamic heap.  Mops modules (described below) are loaded into the dynamic heap, and any class can be told to create an object whose data exists on the dynamic heap instead of in the dictionary.  Whenever you see a System Error 25, it usually means that heap has become used up or fragmented (see the Memory Manager section of Inside Macintosh).  You can remedy this situation either by leaving more dynamic heap with the Install utility  or by being more careful to release the heap used by your application's modules or heap objects once they are no longer needed.\par \pard \s17\qj\sb120 The Mops dictionary can grow until it exhausts its allotted block of heap.  The Mops word ROOM will re\-turn the amount in bytes of available dictionary space at any time.  \par \pard\plain \s254\qc\sb240\keepn \b\f21 Mops stacks\par \pard\plain \s17\qj\sb120 \f20 The two Mops stacks\emdash data (parameter) and return stacks\emdash  are allocated above the applica\-tion heap.  Both grow downward: the return stack grows towards the base of the data stack.  The Mops kernel allocates room for 1500 32-bit cells on the return stack.  The data stack is limited only by the maximum ad\-dress to which the heap is permitted to grow, and is allocated 50000 bytes in the distributed Mops system.  Macintosh Toolbox routines allocate their local variables on the stack, which accounts for the relatively large size of the data stack.\par \pard \s17\qj\sb120 Various system errors can be caused by one of the stacks growing beyond its bounds.  This type of error can be difficult to detect, but you should be particularly alert for return stack problems when writing recur\-sive routines.  The return stack also gets heavy use when you use a lot of named parameters and/or local variables in your methods or Mops words, since the previous val\-ues of these quantities are saved on the return stack.\par \pard \s17\qj\sb120 The data stack is used not only by Mops, but also by the Toolbox when you invoke one of its routines.  Toolbox routines allocate their local data and do parameter passing on the system stack, which is actually the same as the Mops data stack.  This makes the Mops/Toolbox inter\-face fairly easy.  A Mops word need only place parameters on the data stack, just as if it were about to execute another word or method (also see the later chapter "Calling the Toolbox").  If the Toolbox routine calls many other routines, the system stack could potentially grow into the application heap.  The Macintosh might catch this problem with its "stack sniffer" routine, in which case you will see the dreaded System Error 28.  Alternatively, the Macintosh could begin producing a bizarre sequence of sights and sounds caused by overwriting of some heap data be\-fore the stack sniffer could catch it.  In cases like this, you either must give Mops more stack using the Install utility, or adjust your algorithm to nest less deeply on the data stack.\par \pard\plain \s254\qc\sb240\keepn \b\f21 Addresses\emdash relocatable and absolute\par \pard\plain \s17\qj\sb120 \f20 For speed, we normally hold all addresses in the normal Mac form (which we'll call {\ul absolute} since its the actual address which is directly used by the hardware).  This does mean, however, that we have to do some juggling to handle addresses that are stored in the dictionary and then saved in a dictionary image which is reloaded later.  In general, these addresses won't be valid any longer, since the program may well be located at a different place in memory.\par \pard \s17\qj\sb120 For this kind of operation we have defined a relocatable address format, and the words @abs and reloc! to respectively fetch and store a relocatable address with conversion to/from absolute.  We have also provided two classes, DicAddr and X-Addr which use the relocatable format internally.  (DicAddr is for addresses of data, and X-Addr for executable word addresses.)  These have access methods that incorporate the conversion.  {\b You should always use one of these mecha\-nisms for accessing relocatable addresses.}  Don't rely on any details of the relocatable address itself, as this may change at any stage in the future, and probably will.  It will stay at the same size as a stack cell, but we make no other guarantees.\par \pard \s17\qj\sb120 Note that relocatable conversion does not need to be done nearly as often as @, w@ or c@, so that we really do gain by standardizing on absolute addresses.\par \pard\plain \s254\qc\sb240\keepn \b\f21 Handles and pointers\par \pard\plain \s17\qj\sb120 \f20 When you allocate a block of memory in the heap, you can ask for either a Handle or a Pointer.  A pointer points directly at the memory you allocated, while a handle points at what is called a Master Pointer, which is what actually points to the memory.  See the Memory Manager chapter of Inside Macintosh for more details on handles and pointers.  But briefly, using a handle allows the Memory Manager to move the block of memory around, and thus allow memory to be used more efficiently.  When the Memory Manager moves a block of memory, it updates the master pointer so that programs will still know where the block of memory is.  However, blocks accessed via a pointer can't be moved, since the Memory Manager has no way of knowing where the pointer (or any copies of it) are located\emdash the program may have put them anywhere.\par \pard \s17\qj\sb120 In Mops, we encourage the use of handles rather than pointers.  (Apple thinks this is a good idea too.)  Both handles and pointers are objects, with appropriate methods defined for them.  If you want to do a number of operations quickly on a block of memory allocated via a handle, you may lock it in memory so the Memory Manager won't move it while you are accessing it.  You may then retrieve the actual address of the block, and know that it will remain valid until you unlock the block.  The methods lock: and unlock: of class Handle perform this function.\par \pard \s17\qj\sb120 An accidental clobbering of a handle or pointer can produce a bug that can have very nasty and generally unrepeatable results, and be very hard to track down.  Making them objects helps dis\-courage doing dangerous things with them, and also allows a degree of error checking.  An unal\-located handle or pointer object is given a value which should always cause a trap if it is used as an address.  (The actual values we use are $ FFA00101 for unallocated handles, and $ FFA00103 for unallocated pointers.  These two values are defined as constants with the names NilH and NilP respectively.)  These are illegal addresses on all Macs, as far as I am aware, and give a Bus Error if used.\par \pard \s17\qj\sb120 You may define objects which are allocated on the heap, with a handle pointing to them.  See the section "Dynamic Objects" below.\par \pard\plain \s255\qr\sb720\sa1440\keepn \b\f21\fs48 \sect \sectd \sbkodd\linemod0\linex0\cols1\colsx0\endnhere\titlepg {\headerl \pard\plain \s244\brdrb\brsp80\brdrhair \tqc\tx4680\tqr\tx9360 \f20 II-\chpgn  Mops General Reference\par }{\headerr \pard\plain \s244\brdrb\brsp80\brdrhair \tqc\tx4680\tqr\tx9360 \f20 \tab \tab Chapter 6\emdash Strings in Mops II-\chpgn \par }{\footerr \pard\plain \li200 \f20 {\f21 \par }}\pard\plain \s255\qr\sb720\sa1440\keepn \b\f21\fs48 Strings in Mops\par \pard\plain \s254\qc\sb240\keepn \b\f21 String types\par \pard\plain \s17\qj\sb120 \f20 There are three main ways of representing strings in Mops: as STR255 strings, as addr-len format strings, or as objects of class String or String+.\par \pard \s17\qj\sb120 When WORD parses a string, it places at HERE (the next available memory location above the dictionary) a byte representing the length of the string, followed by the text of the string.  This is the same representation as that used by the Toolbox for the str255 data type (see Inside Macintosh).  When  passing strings as parame\-ters on the stack and manipulating them, however, it is usually most convenient to use two cells to represent the string as ( addr len -- ). The word COUNT accepts an address of a str255-format string and returns its ( addr len )  representation.  Conversely, the word STR255 converts addr len to str255 format, returning the address of the length byte to facilitate Toolbox calls.\par \pard \s17\qj\sb120 Mops preserves a special 256-byte buffer expressly for conversion of addr len to str255 format, and this buffer's address is left on the stack by the word BUF255.  You can use this area occa\-sionally as a tempo\-rary workspace for other operations, provided you don't interfere with routine string processing.  Note that STR255 allows you to have only one string at a time. For Toolbox calls that require multiple strings, you will have to use the word >STR255, which accepts an arbitrary address for setup of the string.\par \pard\plain \s254\qc\sb240\keepn \b\f21 String literals and constants\par \pard\plain \s17\qj\sb120 \f20 A Mops string literal is a quote followed by one space and the text of the string, immediately followed by another quote:\par \pard\plain \s8\li720\sb120 \f22\fs20 " Harold"     \tab \\ leaves ( -- addr len ) of string\par \pard\plain \s17\qj\sb120 \f20 Thus, " Harold" TYPE would print the word Harold on the screen.  You should use the string lit\-eral when\-ever you have a single occurrence of a string.  \par \pard \s17\qj\sb120 String constants (SCON), on the other hand,  are useful when you need to use a string several times in your code.  You assign a name to the string, and then use the string name for operations with that string, as fol\-lows:\par \pard\plain \s8\li720\sb120 \f22\fs20 scon\tab harry\tab "Harold"\tab \tab \\ assign name harry to string \line harry  type\tab \tab \tab \tab \\ prints "Harold" on the screen\par \pard\plain \s17\qj\sb120 \f20 {\b Note that in this case you don't put a space between the " and the first character of the string.}  In the first example, " was a word, and so had to have a space after it.  In the second example, " isn't a word, but just a character being read by the word SCON.  In fact you can use any character as a delimiter, which is useful if you need to include a " within the string itself.  The first non-blank character after the name of the scon is the delimiter, and the string consists of all the characters up till the next occurrence of the delimiter.  Thus you can have:\par \pard\plain \s8\li720\sb120 \f22\fs20 scon\tab 3quotes  /"""/\par \pard\plain \s17\qj\sb120 \f20 Using the name of the scon in your program leaves ( addr len ) on the stack, and compiles into a single xt of the dictionary entry for the constant name.  Both string literals and constants are fixed strings that once defined, cannot be changed.  \par \pard \s17\qj\sb120 For heavily text-oriented applications, a more suitable approach would be to define the text strings as Resources (see section on Using Resources in Mops).\par \pard\plain \s254\qc\sb240\keepn \b\f21 Other string techniques\par \pard\plain \s17\qj\sb120 \f20 For string variables, use an object of classes String or String+, discussed in Part III of this man\-ual.  These classes are useful for building strings dynamically, finding substrings, and searching within strings.\par In the Tutorial we described the word & which compiles a single literal ASCII character.  This can be used either inside or outside a definition.  There are also the ANSI standard words CHAR and [CHAR] which perform this function.  Outside a definition, the phrase:\par \pard\plain \s8\li720\sb120 \f22\fs20 char A{\f21 \par }\pard\plain \s17\qj\sb120 \f20 places the ASCII code for 'A' (65) on the stack.  Inside a definition, the phrase\par \pard\plain \s8\li720\sb120 \f22\fs20 [char] A{\f21 \par }\pard\plain \s17\qj\sb120 \f20 compiles a literal for 'A', and places the value on the stack at runtime.  And as we've seen, you can use\par \pard\plain \s8\li720\sb120 \f22\fs20 & A\par \pard\plain \s17\qj\sb120 \f20 either inside or outside a definition, which is probably more convenient (although not ANSI).\par \pard \s17\qj\sb120 There are several primitives for getting a string from the input stream (either keyboard or disk) into the dictio\-nary.  WORD gets the next word, without embedded blanks, and moves it to HERE, then returns that address.  @WORD is a useful word that takes the place of the frequent phrase BL WORD.  For strings, WORD" reads a quote-de\-limited string from the input stream, moves it to HERE, and returns that address.  MWORD ("Mops word") executes BL WORD, and maps the word to upper case.  It is used by Mops itself when interpreting or compiling.\par \pard\plain \s255\qr\sb720\sa1440\keepn \b\f21\fs48 \sect \sectd \sbkodd\linemod0\linex0\cols1\colsx0\endnhere\titlepg {\headerl \pard\plain \s244\brdrb\brsp80\brdrhair \tqc\tx4680\tqr\tx9360 \f20 II-\chpgn  Mops General Reference\par }{\headerr \pard\plain \s244\brdrb\brsp80\brdrhair \tqc\tx4680\tqr\tx9360 \f20 \tab \tab Chapter 7\emdash Calling the Toolbox II-\chpgn \par }{\footerr \pard\plain \li200 \f20 {\f21 \par }}\pard\plain \s255\qr\sb720\sa1440\keepn \b\f21\fs48 Calling the Toolbox\par \pard\plain \s17\qj\sb120 \f20 Because Mops' data stack is the Macintosh system stack, calling stack-based Toolbox routines is fairly easy.  You should read the Inside Macintosh section on Using QuickDraw from Assembly Language to un\-derstand how Toolbox routines use the stack, but we will give you a brief overview here. \par \pard\plain \s254\qc\sb240\keepn \b\f21 Toolbox data cells\par \pard\plain \s17\qj\sb120 \f20 Toolbox routines expect parameters of two types on the stack: 16-bit and 32-bit.  Since all Mops parameters are 32-bit, you might occasionally have to convert a Mops cell to a 16-bit Toolbox cell.  As we saw earlier, both Mops stacks grow towards low memory.  Moreover, the stack pointer always points to the high-order word (a word is 16 bits) of the top 32-bit element.  To convert a 32-bit value to a 16-bit value, we need only add 2 to the stack pointer, which will advance it to the low-order word.   There is a Mops word called MAKEINT that does this for you.  It gets its name from the fact that the Toolbox Integer data type is 16 bits long.  Conversely, you can convert a 16-bit element to a 32-bit cell in two ways.  For un\-signed integer values, you can simply use WORD0 to push 16 bits  of 0 to the stack, creating a 32-bit cell with its high-order word 0.  For signed integers, use I->L, which converts a signed integer to a signed long (32-bit) value.  This will produce a high-order word of $ FFFF if the integer is negative.  The INT: method for Mops INT objects will return their value as 16 bits.\par \pard\plain \s254\qc\sb240\keepn \b\f21 Toolbox data types\par \pard\plain \s17\qj\sb120 \f20 Three principal Toolbox data types use a 16-bit representation: Integer, Boolean, and Char.  Other data types are either stored in a 32-bit cell, or you pass a 32-bit pointer to a longer data structure.  Any composite structure longer than 32 bits uses a pointer when passing it as a parameter.\par \pard \s17\qj\sb120 When a Toolbox routine requires a VAR parameter, this is a call by address, and must use a pointer to the actual data structure, even if it is an Integer or a Long.  This is because the Toolbox will actually change the value of the parameter, and needs its location to do so. \par Certain calls may require two 32-bit cells to be packed into two 16-bit cells.  For example, to convert a Mops Point to a Toolbox Point, you use the Mops word PACK.  UNPACK does the opposite operation, converting two 16-bit values to signed 32-bit values.\par \pard\plain \s254\qc\sb240\keepn \b\f21 Procedure and function calls\par \pard\plain \s17\qj\sb120 \f20 Toolbox routines are for historical reasons defined in terms of the Pascal language.  They can be either {\ul Procedures} or {\ul Functions}, depending on how the Toolbox responds to their calls.  In C terminology, we would say that they either return a result or don't.\par \pard \s17\qj\sb120 Procedures don't return any result on the stack.  To set them up, you just push your parameters on the stack in the order that they are listed.  Functions, on the other hand do return a value of either 16 or 32 bits on the stack.  They are like primitive Mops words that can only return a single cell.  To set up a func\-tion, you must first make room for the value returned, using WORD0 for a 16-bit value or 0 for a 32-bit value.  Then push the parameters onto the stack as you would for a Procedure.  Finally, after all the param\-eters are set up, you can use CALL followed by the name of the routine.  You can find the name from the list of Toolbox calls in this manual or from Inside Macintosh\emdash the names are exactly the same.  CALL, when compiled, invokes a module that contains the hashed values of all the Toolbox routine names, and compiles a trap number that does the actual work of the call.  Here are examples of typical Procedure and Function calls, first with the (Pascal) definition as in Inside Macintosh, then with the equivalent Mops code: \par \pard\plain \s13 \f22\fs20 \par   PROCEDURE InvertRndRect (r: Rect; ovalWidth, ovalHeight: INTEGER);\par \par \tab rect\tab myRect\tab \tab \\ create a rectangle object\par \par \tab addr: myRect\tab \tab \\ get a pointer to the rectangle\par \tab rWidth rHeight  pack\tab \\ pack two 32-bit values into two integers  \par \tab call  InvertRoundRect\tab \\ call the Toolbox routine\par \par \par \par   FUNCTION  GetNewWindow (windowID: INTEGER; wStorage: Ptr;\par         behind: WindowPtr) : WindowPtr;\par \par \tab 0\tab \tab \tab \tab \\ make room for returned WindowPtr \par \tab int: resID\tab \tab \tab \\ get this window's resource ID\par \tab ^base\tab \tab \tab \tab \\ addr of this object for window \par \tab -1\tab \tab \tab \tab \\ in front of all other windows\par \tab call GetNewWindow\tab \tab \\ call the Toolbox routine\par \tab put:  windowPtr\tab \tab \\ save the returned window ptr\par \pard\plain \s254\qc\sb240\keepn \b\f21 Accessing system variables and constants\par \pard\plain \s17\qj\sb120 \f20 You may sometimes need to access system variables, which exist in particular memory locations.  These are called "low memory globals", because they are in low memory, and they are accessible to all programs.  These are all given particular names by Apple.  Likewise there are many system constants which Apple define by name.\par \pard \s17\qj\sb120 There is a Mops module that looks up these names for you, so that you can put the name in your program without having to worry about the actual value.  You can access globals thus:\par \pard\plain \s8\li720\sb120 \f22\fs20 global <name>\par \pard\plain \sb240 \f20 and the address of the appropriate global will be pushed at run time.  Thus, \par \pard\plain \s8\li720\sb120 \f22\fs20 global Ticks @\par \pard\plain \s17\qj\sb120 \f20 will yield the current number of ticks.\par You can access system constants thus:\par \pard\plain \s8\li720\sb120 \f22\fs20 konst <name>\par \pard\plain \s17\qj\sb120 \f20 and the value corresponding to <name> will be pushed at run time.\par \pard\plain \s255\qr\sb720\sa1440\keepn \b\f21\fs48 \sect \sectd \sbkodd\linemod0\linex0\cols1\colsx0\endnhere\titlepg {\headerl \pard\plain \s244\brdrb\brsp80\brdrhair \tqc\tx4680\tqr\tx9360 \f20 II-\chpgn  Mops General Reference\par }{\headerr \pard\plain \s244\brdrb\brsp80\brdrhair \tqc\tx4680\tqr\tx9360 \f20 \tab \tab Chapter 8\emdash Modules II-\chpgn \par }{\footerr \pard\plain \li200 \f20 {\f21 \par }}\pard\plain \s255\qr\sb720\sa1440\keepn \b\f21\fs48 Modules\par \pard\plain \s17\qj\sb120 \f20 Mops provides a facility for creating separately compilable, relocatable modules.  Modules encourage you to separate your program into well-defined, independent units, which makes your code easier to understand and main\-tain.  You must explicitly state which definitions from a given module will be available (exported) to callers outside the module.  Any other definitions become unavailable to the rest of the program after the module is compiled.  Modules are loaded auto\-matically on the heap whenever one of the exported definitions is refer\-enced.  The application must manage and release any modules that are no longer needed.\par \pard\plain \s254\qc\sb240\keepn \b\f21 Module guidelines\par \pard\plain \s17\qj\sb120 \f20 Certain guidelines must be observed when dividing your application into modules.\par \pard \s17\qj\sb120 Exported names are taken to be executable words.  Therefore you mustn't export other things such as objects or Values.  If you need to export an object, you will need to define a word in the module which gets the address of the object (just naming it will do that), then export that word name.  You can then use late binding to send a message to the object.\par \pard \s17\qj\sb120 You may export class names.  Thus, you can define a class in a module, include the class name in the imports list, and instantiate objects of that class anywhere.  In fact in the Mops system itself, we handle windows, menus and dialogs this way.  All the methods of the class are in effect exported along with the class name; you don't have to take any special action, apart from putting the class name in the imports list, and taking care with action handlers (see below).  Whenever you send a message to an exported class, the module will be invoked automatically.\par \pard \s17\qj\sb120 Naturally this has some performance implications.  There is a fair amount of overhead involved in invoking a module.  You can reduce this to some extent by locking the module over a number of calls (this is true for ordinary exported words as well).  But if message execution for a particu\-lar class is really time-critical, it would really best to leave the class in the main dictionary.  Where exported classes are most useful is for those classes that depend heavily on Toolbox calls for most of their methods (such as windows, menus and dialogs).  Toolbox calls are generally much slower than Mops module invocations, so the extra time penalty of putting the class into a module won't be significant.\par \pard \s17\qj\sb120 In Mops you can enter modules only through the exported words (otherwise a machine base address register will not be set correctly, and you'll crash).  Therefore a module should not store the address of one of its internal words in a vector in the main dictionary.  Even if the module is locked in memory, you would not be able to execute this vector.  We have included a check on stores to vectors, that a module address isn't being stored outside the module, so as to give an error message if this is attempted.  This check can be turned off, but don't do it unless you are absolutely sure you know what you are doing!\par \pard\plain \s254\qc\sb240\keepn \b\f21 How to use modules\par \pard\plain \s17\qj\sb120 \f20 Each module has a corresponding object in the main dictionary, which is used for interaction with the module, and which conceptually {\i is} the module.  These module objects have appropriate methods to load them, purge them, query their status etc.\par \pard\plain \s252\sb240\keepn \f21\ul Creating modules in Mops is a three-stage process:\par \pard\plain \s17\qj\sb120 \f20 1.  Create a definition for the module and the entry points that are to be available to the rest of the applica\-tion.  This must exist in the resident portion of the application,  and has the following format:\par \pard\plain \s8\li720\sb120 \f22\fs20 FROM MyMod IMPORT\{ word1 word2 word3 \}\par \pard\plain \s17\qj\sb120 \f20 This statement declares a module, MyMod, from which will be imported three definitions, word1, word2 and word3.  These two names will exist only in the disk image of the module until one of them is referenced, at which time the entire module will be loaded into the heap.  On the disk, the binary image of the module will have the name MyMod.bin.\par \pard \s17\qj\sb120 2.  Write the source code for the module in a separate file, called whatever is the name of your module, followed by ".txt".  Thus in the above example the source file would be called MyMod.txt.\par \pard \s17\qj\sb120 3.  The module must be compiled and saved in its binary format before it will be available to callers.  To compile a module, you must send a compile: message to the module, e.g.\par \pard\plain \s8\li720\sb120 \f22\fs20 compile: MyMod\par \pard\plain \s17\qj\sb120 \f20 When the module has been compled, a message will appear stating that the module has been saved.  You must have room in your dictionary to load the module source file.  \par \pard \s17\qj\sb120 When we compile a module, we temporarily hide all of the main dictionary above the module object itself.  This means you don't have to worry about what you might have loaded in the dic\-tionary when you want to recompile a module.\par \pard \s17\qj\sb120 If you need to call a module several times in succession, you can save some run-time overhead by locking it in memory while you are making the calls.  Do it thus:\par \pard\plain \s8\li720\sb120 \f22\fs20 lock: MyMod\par \pard\plain \s17\qj\sb120 \f20 You will also need to lock the module if you get the address of somewhere in the module\emdash an object, say\emdash and need to use the address again later.  If the module isn't locked, it may move in the heap in the meantime or be removed altogether, so that the address won't be valid any longer.  When you are finished with the module, remember to unlock it thus:\par \pard\plain \s8\li720\sb120 \f22\fs20 unlock: MyMod\par \pard\plain \s17\qj\sb120 \f20 When you are completely finished with a module, you can release its heap memory thus:\par \pard\plain \s8\li720\sb120 \f22\fs20 release: MyMod\par \pard\plain \s17\qj\sb120 \f20 You do not have to do this, however, since loaded modules which are not actually being exe\-cuted will be released automatically if more heap space is needed.  If you want a module not to be released from memory, you can send the message\par \pard\plain \s8\li720\sb120 \f22\fs20 keep: MyMod\par \pard\plain \s17\qj\sb120 \f20 This will flag a module as needing to be kept in memory.  Unlike the situation with lock:, the module may be moved within the heap by the Memory Manager, if it isn't actually being exe\-cuted.  To undo a keep:, send\par \pard\plain \s8\li720\sb120 \f22\fs20 drop: MyMod\par \pard\plain \s17\qj\sb120 \f20 This will not release the module from memory, but will once again allow it to be released if more heap space is needed for something else.\par To include a module in an installed application, mark it as installable any time before calling install.  Do it like this:\par \pard\plain \s8\li720\sb120 \f22\fs20 true  setInstall: MyMod\par \pard\plain \s255\qr\sb720\sa1440\keepn \b\f21\fs48 \sect \sectd \sbkodd\linemod0\linex0\cols1\colsx0\endnhere\titlepg {\headerl \pard\plain \s244\brdrb\brsp80\brdrhair \tqc\tx4680\tqr\tx9360 \f20 II-\chpgn  Mops General Reference\par }{\headerr \pard\plain \s244\brdrb\brsp80\brdrhair \tqc\tx4680\tqr\tx9360 \f20 \tab \tab Chapter 9\emdash Miscellaneous Topics II-\chpgn \par }{\footerr \pard\plain \li200 \f20 {\f21 \par }}\pard\plain \s255\qr\sb720\sa1440\keepn \b\f21\fs48 Miscellaneous Topics\par \pard\plain \s254\qc\sb240\keepn \b\f21 ANSI standard\par \pard\plain \s17\qj\sb120 \f20 Mops is fairly close to the ANSI Forth standard.  If you load the file ANSI, the remaining differ\-ences are dealt with, and you should, we hope, have a conforming ANSI Forth system, imple\-menting the CORE word set, the ERROR and ERROR EXT words, and most of the CORE EXT words.  Thus ANSI standard Forth programs using these word sets should be able to run under Mops.\par \pard \s17\qj\sb120 Note that Mops selectors are not consistent with the standard, since under the standard, word names ending with colon must be normal Forth words.  We have therefore provided a value SLCTRS? which if set to false will disable selectors.  The file ANSI sets this flag false.  Set it back to true if you need to.\par \pard\plain \s254\qc\sb240\keepn \b\f21 Local sections and temporary objects\par \pard\plain \s17\qj\sb120 \f20 Local sections are an extension to the named parameter/local variable scheme.  Local variables are so useful, that there could be a tendency to make definitions too long, simply because you need to keep a number of local variables around.  Local sections remove this problem, since they allow local variables to have a scope which extends over several definitions.  Within a local sec\-tion, all words have access to the named parameters and locals.\par \pard \s17\qj\sb120 You begin a local section with the word LOCAL.  The syntax is e.g.:\par \pard\plain \s8\li720\sb120 \f22\fs20 LOCAL  LocName  \{ parm1 parm2 \\ loc1 loc2 loc3 -- \}\par \pard\plain \s17\qj\sb120 \f20 The word LocName is the "main" word of the local section, i.e. the one which takes the named parameters and whose entry causes any locals to be allocated.  It must be the last word defined in the local section, using :LOC and ;LOC in place of : and ;.  LOCAL doesn't start the definition of this word; it functions like a forward definition.  It is really a means of making the names of the parms and locals available to the compiler at the start of the local section.  All the words defined between LOCAL and the ;LOC at the end of the main word, can access the parameters and locals.  These words can be called freely from other definitions within the local section, but must not be called from outside, for obvious reasons.\par \pard \s17\qj\sb120 We also have local sections for methods, which work in a similar manner.  You declare a local section for methods with MLOCAL instead of LOCAL.  :MLOC commences the definition of the "main" method, and ;MLOC ends the definition of that method, and ends the local section.\par \pard \s17\qj\sb120 Temporary objects are rather like local variables.  They could also be called "local objects" but the word "local" is being used for enough things already, so we're calling them "temporary".  It's the same thing, though.  They are normal objects in all respects, except that they only exist within one definition (or local section), and have no storage allocated otherwise.  The syntax is as in this example:\par \pard\plain \s13 \f22\fs20 \par : SomeWord\par temp\{\tab int\tab \tab anInt\par \tab var\tab \tab aVar\par \tab string\tab aString  \}\par \par \tab 123 put: anInt\par \tab " hello"  put: aString\par \tab ...\par ;\par \pard\plain \s17\qj\sb120 \f20 You can also use the syntax\par \pard\plain \s8\li720\sb120 \f22\fs20 temp \{ ... \}\par \pard\plain \s17\qj\sb120 \f20 with "temp" and "\{" as separate words, if you prefer.  I tend to use both, depending on how many temporary objects I'm declaring, and how I want to format the declaration.\par \pard \s17\qj\sb120 As you can see, within the definition you can use the temporary objects in exactly the same way as normal objects.  They are actually allocated in a frame on the return stack.  However you can use >R etc freely in the definition, since I keep a separate frame pointer.  Of course, the tempo\-rary objects get a classInit: message automatically when the definition is entered and their space is allocated.  They also get a release: message automatically when the definition exits (either at the semicolon or via EXIT).  Thus if you use a temporary string as in the above example, you don't have to worry about sending it release: to get rid of its heap storage at the end of the definition.\par \pard \s17\qj\sb120 As with local variables, if you call a definition recursively, you will get a fresh copy of any tem\-porary objects.\par \pard \s17\qj\sb120 The syntax for temporary objects within a local section is exactly as you would expect:\par \pard\plain \s8\li720\sb120 \f22\fs20 LOCAL  localName  \{ parm1 parm2 \\ loc1 loc2 \}\line temp\{\tab  int1\line \tab  var1\tab \}\par \pard\plain \s17\qj\sb120 \f20 The local variables here are entirely optional.  A local section can have either local variables, or temporary objects, or both.  (Not much point in having neither!!)\par \pard\plain \s254\qc\sb240\keepn \b\f21 Case statements\par \pard\plain \s17\qj\sb120 \f20 We provide no less than three different flavors of case statement in Mops; each of these is most suitable in a different situation.\par The first is the Eaker model, and was described in the Tutorial.  We'll use expr1, exprn2 and so on  to mean any code that leaves one result on the stack.\par \pard\plain \s13 \f22\fs20 \par expr1\par CASE\tab expr2  OF  some code\tab ENDOF\par \tab expr3  OF  some more code\tab ENDOF\par \tab default code comes here\par ENDCASE\par \pard\plain \s17\qj\sb120 \f20 This form of case construct compiles directly to a set of equivalent simpler operations:\par \pard\plain \s13 \f22\fs20 \par expr1 expr2  OVER =\par IF\tab some code\par ELSE\tab expr3  OVER =\par \tab IF\tab some more code\par  \tab ELSE\tab default code\par \tab THEN\par THEN\par DROP\par \pard\plain \s17\qj\sb120 \f20 As you can see from the equivalent Forth code, If any of expr2, expr3... matches expr1, the associated code is executed and then control passes to after the whole case construct.  If none match, the default code is executed.  Note also that right at the end, a DROP is done to get rid of the expr1 value\emdash this means that the default code can be left out completely without leaving a spurious value on the stack.  But if you consume the expr1 value in the default code, remember to put a dummy value on the stack to be consumed by the DROP.  Here's a (rather useless) example:\par \pard\plain \s9\sl240\tx720\tx1440\tx2880\tx7200 \f22\fs20 \par CASE\tab 10\tab OF\tab ." ten"\tab ENDOF\par \tab 12\tab OF\tab ." twelve"\tab ENDOF \par \tab 13\tab OF\tab ." thirteen or sixteen"\tab ENDOF\par \tab 16\tab OF\tab ." thirteen or sixteen"\tab ENDOF\par \tab 20 30\tab RANGEOF\tab ." twenty to thirty inclusive"\tab ENDOF\par \tab ( default )\tab ." something else, namely "  .\par \tab 0\tab ( to be consumed )\par ENDCASE\par \pard\plain \s17\qj\sb120 \f20 Notice that the ENDCASE consumes one value off the stack, and also that there's no easy way of handling different values which lead to the same action (as in 13 and 16 above).\par The second type of CASE we have in Mops is a keyed case, in which a test value is compared to succesive values in a linear list.  Here's the equivalent of the above example:\par \pard\plain \s9\sl240\tx720\tx1440\tx2880\tx7200 \f22\fs20 \par CASE[  10  ]=>\tab ." ten"\par     [  12  ]=>\tab ." twelve"\par     [  13  ], [ 16 ]=>\tab ." thirteen or sixteen"\par     [ 20  30  RANGE]=>\tab ." twenty to thirty inclusive"\par     DEFAULT=>\tab ." something else, namely "  .\par ]CASE\par \pard\plain \s17\qj\sb120 \f20 This format will compile to more compact code than the former example, and should execute significantly faster.  The former CASE syntax has the advantage that the test values are com\-puted each time, so can be different on different executions, if this is what you want.  If, how\-ever, your test values don't change, which is more likely, the latter CASE[ syntax is better to use, since the test values are obtained at compile time and compiled once and for all into the code.  As you may gather from the syntax, compilation is turned off and on when obtaining the test values, so that for example you could put  {\f4\fs18 CASE[  value1 value2 +  ]=>}  etc.  The arithmetic will take place at compile time.\par \pard \s17\qj\sb120 You can also see that there's a straightforward way of handling different values giving the same action.  You can also use  RANGE],  with the expected meaning.\par The third type of case we have is an indexed case.  In this kind of case, a direct table lookup is done to determine the outcome.  Here's our example again, with one change:\par \pard\plain \s9\sl240\tx720\tx1440\tx2880\tx7200 \f22\fs20 \par SELECT[ 10 ]=>\tab ." ten"\par       [ 12 ]=>\tab ." twelve"\par       [ 13 ], [ 16 ]=>\tab ." thirteen or sixteen"\par \tab DEFAULT=>\tab ." something else, namely "  .\par ]SELECT\par \pard\plain \s17\qj\sb120 \f20 Notice that the syntax is almost the same as for the keyed case, but that there's no equivalent of the range test.  This is precisely because it uses a direct table lookup rather than a series of com\-parisons.  Later we might implement the filling in of a range of entries in the table, in which case we could implement the range test.  But we haven't done this yet.\par \pard \s17\qj\sb120 This code is the fastest of all to execute, since one direct lookup is done on the table.  However in some situations this construction may take up too much space.  The table which is generated will contain two bytes for every value in the range between the highest and lowest test values.  Thus in this example the table will have an entry for every integer between 10 and 16 inclusive, i.e. 7 entries, which will take 14 bytes.  This would be fine, but in many situations the table would be enormous.  Mops will assume that an attempt to build a table of more than 500 entries is an error, and give a message.\par \pard\plain \s254\qc\sb240\keepn \b\f21 Recursion and forward referencing\par \pard\plain \s17\qj\sb120 \f20 You may occasionally wish to call a word from within its own definition (this is called {\ul recursion}).  At first glance you may think that the logical thing to do would be to simply use the word's own name.  (This was actually the way things were done in Neon.)  However you may often want to call an earlier word with the same name, in the situation where you are redefining the word to have similar but slightly changed behavior.  For this reason it is now standard Forth practice to "hide" the name of the current definition while it's being compiled, so that a dictio\-nary search won't find it, but will instead find an earlier word with the same name, if there is one.  This is what Mops does as well.  We therefore need another way of specifying recursion, and this is done, logically enough, with the word RECURSE.  Using RECURSE means that you are call\-ing the current definition.\par \pard \s17\qj\sb120 If a situation arises in which you need to reference a Mops word before it has been defined, you can use Mops's {\ul forward} {\ul reference} facility.  Before the word can be referenced the first time, you must declare it as {\ul forward} in the following manner:\par \pard\plain \s8\li720\sb120 \f22\fs20 forward newWord\par \pard\plain \s17\qj\sb120 \f20 This declares newWord as a forward referenced Mops word.  Later, when you are able to define newWord, you must do so in the following manner:\par \pard\plain \s8\li720\sb120 \f22\fs20 :f  newWord  ...  ;f\par \pard\plain \s17\qj\sb120 \f20 :f is a special colon compiling word that resolves forward referenced definitions.  It creates a headerless entry for the new word in the dictionary, and then patches the previous entry, built by FORWARD, to point to the new definition.  This will cause all compiled references to the FORWARD definition to actually execute the later definition.  If you forget to resolve a forward reference with :f ... ;f, you will see a message at runtime informing you of the exact nature of the unresolved forward reference.  \par \pard \s17\qj\sb120 As a related issue, the Mops word PATCH can be used to patch any given word's references to another word.  PATCH is used in the following manner:\par \pard\plain \s8\li720\sb120 \f22\fs20 patch oldWord newWord\par \pard\plain \s17\qj\sb120 \f20 Both :f and PATCH make oldWord behave like a colon definition, which means that they cannot be used for specialized definitions such as classes, objects, data structures, etc.\par \pard\plain \s254\qc\sb240\keepn \b\f21 Using resources in Mops\par \pard\plain \s17\qj\sb120 \f20 A resource on the Macintosh is essentially a structured database into which you can store initial\-ization in\-formation for Toolbox objects and other data items, such as strings.  Resources can improve the maintain\-ability of your program: if you store all of the textual information for your application in a resource file, for example, it becomes very easy to convert your application to another language or change the wording of a given string.  Another benefit of resources is that they shift the burden of storage for initialization values from your resident code to the dynamic heap, so your application takes up less memory space.\par \pard\plain \s253\sb240\keepn \b\f21 Toolbox resources\par \pard\plain \s17\qj\sb120 \f20 There are several ways in which you can use resources with Mops.  For example, Toolbox objects such as Windows generally have two methods you can summon for bringing a window alive.  NEW: relies upon values passed to the method via the stack, and is independent of resource files.  GETNEW: uses only a re\-source ID to find the template for the object in the cur\-rently open resource files.  For instance, a Window would have a resource of type 'WIND'  from which it would get its size, visible and goAway values, etc.  Note that resource templates such as those of type 'WIND' only contain information relating to the portion of the object that the Toolbox knows about - in the case of a Window, the window record.  Other parts of the object, such as the window actions, must still be initialized by the application's code.  Certain objects, such as those of class Icon, get all of their data from a resource item, and simply read the resource data whenever they are called upon to do anything.\par \pard \s17\qj\sb120 Another way to use resources is for non-Toolbox objects that have no predefined template type.  For these objects, you will need to use an existing type such as STR, or define your own types using ResEdit (see Putting Together a Mops Application).\par \pard\plain \s253\sb240\keepn \b\f21 Defining and using resources\par \pard\plain \s17\qj\sb120 \f20 Mops provides an easy way to define a resource item from within your application.  For instance:\par \pard\plain \s8\li720\sb120 \f22\fs20 resource myWind\line 'Type WIND  256  set: myWind\par \pard\plain \s17\qj\sb120 \f20 defines a resource called myWind that has type WIND and a resource ID of 256.  When you need to access this resource, sent the message\par \pard\plain \s8\li720\sb120 \f22\fs20 getnew: myWind\par \pard\plain \s17\qj\sb120 \f20 Resource is a subclass of Handle, so you can now obtain a pointer to the resource data with\par \pard\plain \s8\li720\sb120 \f22\fs20 ptr: myWind\par \pard\plain \s17\qj\sb120 \f20 Note that if you do anything that might cause a heap compaction, this pointer will be wrong;  but you can avoid this with the lock: method of class Handle, thus:\par \pard\plain \s8\li720\sb120 \f22\fs20 lock: myWind\par \pard\plain \s17\qj\sb120 \f20 You can open a new resource file in the following manner:\par \pard\plain \s8\li720\sb120 \f22\fs20 " myFile.rsrc"  openResFile\par \pard\plain \s17\qj\sb120 \f20 This opens the resource file named " myFile.rsrc" and make it the first file in the search order.  All open re\-source files are closed automatically when your application terminates.  Mops uses the file mops.rsrc for its resources during normal operation, and you can add your own resources to this file with ResEdit.\par \pard \s17\qj\sb120 The source file QD1 includes support for cursors, icons and QuickDraw pictures via the resource interface.  This makes it very easy for you to dress up your application with fancy graphics that you can create with a graphics application, and then add them to a resource file.\par \pard\plain \s254\qc\sb240\keepn \b\f21 Clearing nested stacks\emdash Become\par \pard\plain \s17\qj\sb120 \f20 In a non-hierarchical, non-modal environment such as the Macintosh, the user is generally free to select an\-other menu choice or open a different window at any time.  This could happen while your code is nested several levels down, listening to events.  If the user selects a new menu op\-tion that leads to an entirely new part of the program and your code is already several words deep on the return stack, the routine dispatched by the menu will nest several levels more.  This could continue indefinitely until your application runs out of return stack, at which point it will bomb.\par \pard \s17\qj\sb120 You have two ways to avoid this situation.  One is to create an inverted architecture for your program, such that its event loop is at the highest level, and the code always returns to that level before listening to the event queue.  This implies that you can never use KEY from within a called word, but only from the highest level.  This may often be a good solution, but in other sit\-uations it may not lead to the easiest or the clear\-est implementation of a particular problem.\par \pard \s17\qj\sb120 Mops gives you an alternative method by providing you with a Mops word called BECOME.  BECOME  causes Mops to erase everything that currently is on the stacks, and resets them to their normal empty values.  Mops then executes the word whose name follows BECOME in the input stream.  This automati\-cally makes that last word the highest-level word in the application.  In this manner you can actually have several mini-applications within one, each callable from the other.  At the point that BECOME is executed, you can rest assured that the stacks are empty and the application is essentially at ground zero.\par \pard\plain \s254\qc\sb240\keepn \b\f21 System vectors\par \pard\plain \s17\qj\sb120 \f20 Mops uses a powerful technique called {\ul vectoring} to provide maximum flexibility for the pro\-grammer.  Vec\-toring is the name given to the process of using a global or local variable to hold the address of a Mops word.  For example, let's say that you would like Mops to interpret a file from disk just as though you were typing it at the keyboard.  A built-in Mops system vector, named KEYVEC, always holds the address of the word that Mops normally uses to acquire key\-board input.  By changing the contents of KEYVEC to point to a special word you define\emdash a word that reads a single character from disk\emdash all Mops words that accept keyboard input will then take their input from disk, instead of from the keyboard.  For example:\par \pard\plain \s13 \f22\fs20 \par \tab : diskKey  Here 1 read: ffcb  drop\tab \\ get 1 character from disk\par \tab \tab here c@  ;\tab \tab \tab \tab \\ place it on the stack\par \par \tab " sam" name: ffcb\par \tab open: ffcb  .\par \tab ' diskKey -> keyVec\tab \\ set KEYVEC to get chars from disk file Sam\par \pard\plain \s17\qj\sb120 \f20 Of course, in a real example you would have to restore the proper KEYVEC value when EOF (end of file condition) was reached.  \par \pard \s17\qj\sb120 Mops has a full set of vectors for all critical I/O and compilation routines, allowing you to tailor the behavior of the Mops environment very easily.  These vectors cannot reside in the Kernel, since that would preclude having several saved images that used different vectors.  Thus, each saved image has its own set of system vectors, located near the start of the dictionary.\par \pard \s17\qj\sb120 System vectors are slightly different to normal vectors, in that a 0 value may be stored in a sys\-tem vector.  This means that the default action is to be taken.  Each system vector has its own predefined default word (which cannot be altered).\par \pard \s17\qj\sb120 Here are the main system vectors and their required behaviors\emdash there are others that are used internally in the Mops system and should not normally be changed, unless you really know what you are doing.  Also there are some system vectors relating to Apple events which are discussed separately later.\par \pard\plain \s18\fi-360\li360\ri6580\sb120\sbys \f20 KEY  ( -- char)\par \pard\plain \s19\qj\li2880\sb120\sbys \f20 gets keyboard input.\par \pard\plain \s18\fi-360\li360\ri6580\sb120\sbys \f20 EMITVEC  ( char -- )\par \pard\plain \s19\qj\li2880\sb120\sbys \f20 sends one character to the primary output device.\par \pard\plain \s18\fi-360\li360\ri6580\sb120\sbys \f20 PEMITVEC  ( char --)\par \pard\plain \s19\qj\li2880\sb120\sbys \f20 sends one character to the secondary output device.\par \pard\plain \s18\fi-360\li360\ri6580\sb120\sbys \f20 CRVEC  ( -- )\par \pard\plain \s19\qj\li2880\sb120\sbys \f20 sends a carriage return to the primary output device.\par \pard\plain \s18\fi-360\li360\ri6580\sb120\sbys \f20 PCRVEC  ( -- )\par \pard\plain \s19\qj\li2880\sb120\sbys \f20 sends a carriage return to the secondary output device.\par \pard\plain \s18\fi-360\li360\ri6580\sb120\sbys \f20 TYPEVEC  ( addr len -- )\par \pard\plain \s19\qj\li2880\sb120\sbys \f20 sends a string to the primary output device.\par \pard\plain \s18\fi-360\li360\ri6580\sb120\sbys \f20 PTYPEVEC  ( addr len -- )\par \pard\plain \s19\qj\li2880\sb120\sbys \f20 sends a string to the secondary output device.\par \pard\plain \s18\fi-360\li360\ri6580\sb120\sbys \f20 ECHOVEC  ( char -- )\par \pard\plain \s19\qj\li2880\sb120\sbys \f20 handles echoing to the output device of the keys being input by ACCEPT.\par \pard\plain \s18\fi-360\li360\ri6580\sb120\sbys \f20 ABORTVEC  ( -- )\par \pard\plain \s19\qj\li2880\sb120\sbys \f20 cleans up the stacks and notifies the user of an error.  The Mops word CL3 ("clean-up 3") is normally executed by this vector, and your error word should call CL3 if it is to return to the Mops interpreter.\par \pard\plain \s18\fi-360\li360\ri6580\sb120\sbys \f20 QUITVEC  ( -- )\par \pard\plain \s19\qj\li2880\sb120\sbys \f20 this word will be executed before the interpreter enters its main loop.  It should be the startup word for an installed application.\par \pard\plain \s18\fi-360\li360\ri6580\sb120\sbys \f20 UFIND  ( -- xt true OR -- false)\par \pard\plain \s19\qj\li2880\sb120\sbys \f20 is a special purpose variant of FIND (this  vector is actually called by FIND before FIND searches the Mops dictionary for an occur\-rence of a particular name at the top of the dictionary -- HERE.  You won't have to worry about  this vector unless you plan to write new compiling words for Mops.\par \pard\plain \s18\fi-360\li360\ri6580\sb120\sbys \f20 OBJINIT  ( -- )\par \pard\plain \s19\qj\li2880\sb120\sbys \f20 initializes certain areas of the kernel at Mops startup.  It  normally contains the xt of SYSINIT.  Should not be altered  by the user.\par \pard\plain \s18\fi-360\li360\ri6580\sb120\sbys \f20 HEADER  ( -- )\par \pard\plain \s19\qj\li2880\sb120\sbys \f20 lays down a dictionary header.{\b \par }\pard\plain \s254\qc\sb240\keepn \b\f21 Mops defining and compiling words\par \pard\plain \s17\qj\sb120 \f20 Much of the Mops language is, itself, written in Mops.  This seemingly unlikely loop is possible because Mops is an {\ul extensible} language - meaning that you can write new words in Mops that modify or extend the basic behavior of the language itself.  In a sense, every word that you write extends Mops, because it adds to the same dictionary used by the Mops system.  There are three layers of extensibility in Mops:\par \pard\plain \s252\sb240\keepn \f21\ul 1. Vocabulary extensions. \par \pard\plain \s17\qj\sb120 \f20 Whenever you write a new word, instantiate a new object, create a new Value, and so on,  you are extend\-ing the vocabulary of words that succeeding words can use.  This obviously adds more power and function to the language.\par \pard\plain \s252\sb240\keepn \f21\ul 2. Class extensions.\par \pard\plain \s17\qj\sb120 \f20 When you define a new class of objects, you are extending Mops in a some\-what more profound way than in a vocabulary extension.  Creating a new class creates a new template for building other objects.  These templates are known as {\ul defining} {\ul words}, because they can, them\-selves, define new dictionary entries.  This is a powerful technique, because there is a good chance that you will be able to reuse defining words in your other applications.  Eventually, you'll develop a large library of Classes, which should make your future application development much easier.\par \pard\plain \s252\sb240\keepn \f21\ul 3. Compiler extensions.\par \pard\plain \s17\qj\sb120 \f20 The deepest layer of extensibility is concerned with constructing the tools that create defining words. Words such as :CLASS or :M are specialized compiling words that can truly extend the language syntax and add entirely new features.  Compilers are the inner soul of the Mops lan\-guage.  They create control structures (such as IF, BEGIN and DO), Mops's class compilation facility, message processing, prefix operators...even colon itself is an example of a Mops com\-piler word.  Mops's compiler words come largely from Forth.\par \pard \s17\qj\sb120 You can use Mops for years without ever writing a compiling word, because Mops's class/object facility provides a very complete environment for programming.  But if you are an advanced programmer and are interested in writing compiling words, the best source of ideas and learning is in the Forth literature, particu\-larly the FORML and Rochester conference proceedings, avail\-able from the Forth Interest Group.\par \pard\plain \s254\qc\sb240\keepn \b\f21 Error handling\par \pard\plain \s17\qj\sb120 \f20 Mops' error handling is based upon the ANSI Forth Standard, which uses the two words CATCH and THROW.  CATCH is used as follows:\par \pard\plain \s8\li720\sb120 \f22\fs20 ['] someWord  catch\par \pard\plain \s17\qj\sb120 \f20 (of course, if interpreting rather than compiling, put ' instead of [']).  The action which takes place is to execute SomeWord, and if no error occurs, push a zero on top of whatever SomeWord may have put on the stack.\par \pard \s17\qj\sb120 By saying "if no error occurs", we really mean that THROW did not take an error exit.  THROW pops the top item on the stack, and if it is non-zero, it restores the stacks to where they were when the current CATCH was called (assuming that at least one CATCH is in effect).  Then the non-zero value, assumed to be an error code, is pushed onto the stack and execution continues straight after the CATCH.  If THROW finds a zero value on top of the stack it means no error, and execution continues normally.\par \pard \s17\qj\sb120 From this you can see that CATCH and THROW provide a flexible means of unwinding out of deeply nested code if an error occurs.  If CATCH catches an error, but doesn't want to recognize that particular error code, it can simply re-THROW it.\par If no CATCH is in effect when an error occurs, Mops takes its default error action, which is to display an error message and execute ABORT.  ABORT sets all stacks to their empty state, and initializes other Mops system variables to a suit\-able value before returning.  \par \pard \s17\qj\sb120 Before it executes, ABORT executes the System Vector ABORTVEC, to give extra flexibility in error recovery.  Mops normally installs its own error handler word in ABORTVEC, called CL3, which prints the current stack of load files and clears this stack.  You should call CL3 if you install an error routine for use during development, although the use of CATCH and THROW would probably be better.  For your final installed application, since much of the Mops system won't be present, the Install routine asks you to specify an error word, which will be placed in ABORTVEC.  You should provide a routine which tells the user what is happening and a suit\-able action to take (most likely in an Alert or Dialog box).\par \pard \s17\qj\sb120 There are two error routines that indirectly call ABORT\emdash ABORT" and ?ERROR.  ABORT" must be followed by a space, and then a string terminated by a quote.  Its action at runtime is as follows:  if the top of the data stack is true (non-zero), it will print the string between the quotes and then execute abort.  If false, ABORT" returns without doing anything.   For instance, the phrase\par \pard\plain \s8\li720\sb120 \f22\fs20 read: theFile  abort" File read failed"  \par \pard\plain \s17\qj\sb120 \f20 would check the return code from a disk read operation, and abort if it indicated an error.  You can force an ABORT" to occur with the statement TRUE ABORT" ..." .  \par \pard \s17\qj\sb120 Embedding a lot of error strings in your code can take up unnecessary memory space, and  it also makes the messages difficult to change.  ?ERROR allows you to specify the actual text for your error strings in a resource file, and takes the resource ID number of the string to print, assumed to be a resource of type "STR " (note the space at the end).  It works conditionally in the same way as ABORT".  For instance, \par \pard\plain \s8\li720\sb120 \f22\fs20 find not ?error -13\par \pard\plain \s17\qj\sb120 \f20 prints the string with resource ID -13 if the word in the input stream is not found, and then aborts.   Mops uses ?ERROR for most of its error messages.   If you want, you can just print a resource string without executing ABORT by using the word MSG#.  It takes a resource ID just as ?ERROR does.  All of the error words function in compilation state only.  To get a list of all messages and their numbers, type\par \pard\plain \s8\li720\sb120 \f22\fs20 .msgs\par \pard\plain \s17\qj\sb120 \f20 If you want to add a new message, do it this way:\par \pard\plain \s8\li720\sb120 \f22\fs20 <msg number> " the text of your message"  addMsg\par \pard\plain \s17\qj\sb120 \f20 If you want to change an existing message, you can't just use AddMsg as above or you'll get an error\emdash this is just as a safety check.  You have to remove the existing message first, thus:\par \pard\plain \s8\li720\sb120 \f22\fs20 <msg number>  removeMsg\par \pard\plain \s17\qj\sb120 \f20 If adding your own messages, please use numbers above 200, so as not to clash with future error messages we may want to add to the Mops system.\par For an error while loading with echo off, the last word in the dictionary will usually be the word that experi\-enced an error.\par \pard \s17\qj\sb120 The file Mops.rsrc is a resource file containing all of Mops's error messages.  Whenever one of the error words executes, it checks that Mops.rsrc is open.  Of course, you must have Mops.rsrc within the folder Mops \'c4, or Mops won't be able to find it.\par \pard\plain \s254\qc\sb240\keepn \b\f21 Inline definitions\par \pard\plain \s17\qj\sb120 \f20 You may specify that a definition or method is to be compiled inline whenever it is used.  This allows faster execution.  The syntax is:\par \pard\plain \s8\li720\sb120 \f22\fs20 : XXX  inline\{ <some code> \}  ;\par \pard\plain \s17\qj\sb120 \f20 The code <some code> is stored as a string, and whenever xxx is compiled into a definition, the string is compiled using EVALUATE.  We actually store the source text for <some code> as a string, and EVALUATE it.  This can give very good compiled code due to our optimization, which is why we took this approach.  This syntax is really equivalent to\par \pard\plain \s8\li720\sb120 \f22\fs20 : XXX  " <some code>"  evaluate  ;   immediate\par \pard\plain \s17\qj\sb120 \f20 but the syntax is probably clearer.  It also has advantages when used in methods.  The syntax for an inline method is\par \pard\plain \s8\li720\sb120 \f22\fs20 :m YYY:\line \tab inline\{ <some code> \}\line \tab <some more code>  ;m\par \pard\plain \s17\qj\sb120 \f20 The reason there are two pieces of code is that we can't do compilation at run time, since the Handlers segment isn't always present then, but late binding does occur at run time.  Therefore we need some pre-compiled code which is the equivalent of the inline code, but which can be called in the conventional manner on a late bind.  Thus the two pieces of code above ought to be the same.  There is, however, one difference.  We assume that inline code chunks will be fairly short, and are to be optimized for speed.  Therefore, when compiling the inline code (on an early bind), we do not change the machine's address register which normally points to the current object's base address.  A normal method entry involves saving the previous base address on the return stack and setting up the new value, then popping the previous value when we exit the method.  But for inline methods we bypass this procedure.  Therefore if you want to refer to the current object's base address in some inline code, you can't use ^BASE.  Instead, use the word OBJ.  This is an immediate word which will generate the most efficient code to reference the object's base address, whatever it is, and allow our normal optimization to take effect.  (Thus if we early-bind the same inline method to different objects, and there is a reference to OBJ, we will not necessarily get identical code compiled.  It will depend on whether the object being bound to is a dictionary object, an ivar, or whatever.)  Likewise, if you need to make an indexed reference in an inline method, instead of ^elem, use IX.  All this sounds complicated, but it is actually fairly simple to use.  The file Struct has many methods which use inline code, so if you look there you will see plenty of examples of how to do it.\par \pard\plain \s255\qr\sb720\sa1440\keepn \b\f21\fs48 \sect \sectd \sbkodd\linemod0\linex0\cols1\colsx0\endnhere\titlepg {\headerl \pard\plain \s244\brdrb\brsp80\brdrhair \tqc\tx4680\tqr\tx9360 \f20 II-\chpgn  Mops General Reference\par }{\headerr \pard\plain \s244\brdrb\brsp80\brdrhair \tqc\tx4680\tqr\tx9360 \f20 \tab \tab Chapter 10\emdash Utilitiy Modules II-\chpgn \par }{\footerr \pard\plain \li200 \f20 {\f21 \par }}\pard\plain \s255\qr\sb720\sa1440\keepn \b\f21\fs48 Utilitiy Modules\par \pard\plain \s17\qj\sb120 \f20 The Mops system contains several modules providing general functions that you might want to use in your application.  You can do this either by referencing the imported names from the compiled modules as they are distributed in the Mops Folder, or by altering the source in the Modules folder and recompiling it to tailor the modules for your own use.  Modules are advanta\-geous in that they take up very little room in the resident dictionary, and load themselves only when needed on the application heap.\par \pard\plain \s254\qc\sb240\keepn \b\f21 The Alert box\par \pard\plain \s17\qj\sb120 \f20 This module gives you a predefined alert box without having to define any resources.  Use Alert" within a word or method to produce an informatory message.  Example:\par \pard\plain \s8\li720\sb120 \f22\fs20 readLine: myFcb  2 alert" A read error has occurred"\par \pard\plain \s17\qj\sb120 \f20 If the readLine is successful no alert will appear, but if readLine returns a non-zero result, an alert box with the given message will be displayed along with the specific error number.  You may use Alert" in place of Abort" in your final application to comply with the "Mac Standard".  Although customized alert boxes are better, this gives you a "quick and dirty" means of produc\-ing an alert box.\par \pard \s17\qj\sb120 To use Alert", you must first include the source file AlertQ in your application.  You may use  need AlertQ  to accomplish this.\par \pard \s17\qj\sb120 You may modify the sizes and positions of any of the items, by using ResEdit to modify the re\-sources ALRT 900 and DITL 900 in your application.  These resources come initially from Mops.rsrc, and are copied into installed applications by Install, if the file AlertQ has been included.\par \pard\plain \s254\qc\sb240\keepn \b\f21 The Decompiler and Debugger\par \pard\plain \s17\qj\sb120 \f20 These are integrated these into a single module, DebugMod, since the job of displaying compiled code is very similar whether you're decompiling or debugging.  To decompile a word, type\par \pard\plain \s8\li720\sb120 \f22\fs20 see  aWord\par \pard\plain \s17\qj\sb120 \f20 or to debug a word, type\par \pard\plain \s8\li720\sb120 \f22\fs20 debug  aWord\par \pard\plain \s17\qj\sb120 \f20 then keep typing spaces to step through each instruction.  Of course, if you're debugging, nothing will happen until  aWord  gets executed.\par \pard \s17\qj\sb120 The display gives a kind of pseudo-assembler, since we're compiling native code.  But if you've loaded the source file through the usual load mechanism, the source will appear in a window at the top of the screen.  If you loaded with logging on (turn it on with  +LOG  and off with -LOG)  then a "log file" will have been generated, which will allow the Decompiler/Debugger to find the right place in the source corresponding to whatever compiled code you're looking at.  The source window will be scrolled to the right place and an underscore will appear more or less under the right source text.  This will move along as you step through the compiled code.\par \pard \s17\qj\sb120 If you're running under System 7 and also have Quick Edit running, then instead of Mops pro\-ducing its own (rather primitive) source code display, an Apple event will be sent to Quick Edit asking it to open the source file.\par If you type <return> instead of space, then if you are looking at a call to another word (JSR or BSR), you will go down into that definition.  If you type U, you will come back up again.  Q will quit decompiling/debugging.\par \pard \s17\qj\sb120 If you are debugging, G does a "go" (return to normal execution) and N is like G except that you will drop into the Debugger again the {\ul N}ext time you execute the word you wanted to debug.  Typing R gives you a dump of the machine registers.  Typing F (for Forth) gets you to the Forth/Mops interpreter so you can inspect values etc.  Typing  Resume  gets you back into the debugger with everything as you left it.\par \pard \s17\qj\sb120 Typing the arrow keys forces scrolling of the source text window.  Keypad-7 goes to the top of the source, keypad-1 goes to the end, keypad-3 goes forward to the next colon, and keypad-9 goes back to the previous colon.  (These keys are used by Microsoft Word to mean Home, End, Page down and Page up, respectively, which is why I chose them.)\par \pard \s17\qj\sb120 To decompile/debug in a module, type e.g.\par \pard\plain \s8\li720\sb120 \f22\fs20 in aMod  see aWord\par \pard\plain \s17\qj\sb120 \f20 To decompile/debug a method, type:\par \pard\plain \s8\li720\sb120 \f22\fs20 [in aMod]  see aMeth: aClass\par \pard\plain \s17\qj\sb120 \f20 The debugger works fine on both my Mac Plus and IIsi, and even under System 7.  Since I change two interrupt vectors (T-bit and TRAP #0), it may not always work on all Macs or sys\-tems.  It may, and hopefully it will, but I may not get a chance to try it out.  I will be very sur\-prised indeed if it works on PowerPC Macs.\par \pard \s17\qj\sb120 Be careful if you are using Macsbug\emdash the debugger replaces the vectors when it terminates nor\-mally, but if the program crashes or something, the vectors may be left changed, and Macsbug won't then work properly.  Rebooting is the only way out.\par If you're running under System 7 and have Quick Edit running as well as Mops, then as we men\-tioned above, Debug and See will send Quick Edit an Apple event asking it to open the source file.  You can use this feature directly, by typing\par \pard\plain \s8\li720\sb120 \f22\fs20 edit someFile\par \pard\plain \s17\qj\sb120 \f20 Then assuming that someFile can be found via the normal Mops file lookup, the Apple event is sent to Quick Edit so that it will open the file.  If the file can't be found, or Quick Edit isn't run\-ning, you'll get an error message.\par \pard\plain \s254\qc\sb240\keepn \b\f21 The Profiler\par \pard\plain \s17\qj\sb120 \f20 The purpose of a profiler is to give statistics on time spent in various lines of code, and also the number of times they have been executed.  Because of the hierarchical nature of the language, it seemed to make the most sense to base profiling on a given word, whose definition is profiled.  This way bottlenecks can be tracked down interactively, and you can zero in on the places of interest, rather than have to wade through a mountain of useless information.  Anyway, it was easier to implement this way.\par \pard \s17\qj\sb120 To use this feature, the file containing the definition to be profiled must be loaded with logging on, since the profiler needs to know the correspondence between the source and compiled code, and this is recorded in the log file.  Once this is done, just type\par \pard\plain \s8\li720\sb120 \f22\fs20 profile aWord\par \pard\plain \s17\qj\sb120 \f20 then after aWord has been run, more than once if need be, type\par \pard\plain \s8\li720\sb120 \f22\fs20 showP\par \pard\plain \s17\qj\sb120 \f20 and the source code of the definition of aWord will appear on the screen, with the statistics on the left side of each line.  Turn printing on first for a hard copy.\par \pard \s17\qj\sb120 Profile and showP are in DebugMod.  Profiling works by putting a breakpoint on the first instruction corresponding to each source line.  There is thus a few instructions' overhead on each line, which will slightly skew the timing results for lines such as   aValue IF  which only contain one instruction anyway.  We try to minimize this effect by not counting time while the profiling code itself is running, but the breakpoint trap and the return instruction (RTE) do take a number of cycles.  Use your common sense.  Also, for processor independence, we use Mac ticks (1/60 secs) to count time.  Therefore the word being profiled ought to accumulate at least several sec\-onds' execution time, for the results to be very meaningful.  Call it repeatedly in a loop, if neces\-sary.  The longer the execution time, the more accurate the results.  If you get a lot of lines apparently taking zero time, this probably means you need to run the word more times.  (But remember, lines consisting of just  THEN, say, don't actually compile any code.  So of course they won't take any time.)\par \pard \s17\qj\sb120 If you're only interested in the execution counts, you don't need to bother about the length of the run.  These counts ought to be right, no matter what.\par Finally, this is a new feature, and it hasn't been very extensively tested, so please exercise caution (i.e. don't blame me if you crash without saving).\par \pard\plain \s254\qc\sb240\keepn \b\f21 Run-time initialization\par \pard\plain \s17\qj\sb120 \f20 We have a feature to make it easy to do special-purpose run-time initialization.  Some files such as LongMath need an initialization call on startup (in the case of LongMath, this is to check if the processor we're running on has 32-bit multiply and divide instructions).  Using several such packages together could cause problems, as each could have redirected ObjInit without being aware of the others.  And yet we want to be able to have standard packages such as LongMath which don't have to be aware of what other packages may or may not be present.  To avoid this problem, we have an x-array of words to execute on startup, called INIT_ACTIONS, and these are all executed right after ObjInit is called.  This way, ObjInit can be restricted to just initializ\-ing the standard Mops objects, and any extra initialization can be done by adding a cfa to init_actions.  If you write a package that needs special startup action, make the startup action into a word, let's call it MyStartupWord, then at the end of your code put\par \pard\plain \s8\li720\sb120 \f22\fs20 ' MyStartupWord  add: init_actions\par \pard\plain \s17\qj\sb120 \f20 and that's it.  If you do a Forget or RL (reload) there's no problem, since the Mops loading code starts by purging init_actions of any xts above the current top of the dictionary.  This prevents init_actions from getting invalid xts in it.\par \pard\plain \s254\qc\sb240\keepn \b\f21 PowerPC assembler and disassembler\par \pard\plain \s17\qj\sb120 \f20 Mops can't generate native PPC code yet\emdash maybe we'll get there for the next major release\emdash but in the meantime we do have a PPC assembler and disassembler, thanks to Xan Gregg.  Xan has written this assembler for the PPC version of MacForth, and he's kindly allowing me to distribute it with Mops in exchange for a program I've written to parse Apple's new Universal Headers.\par \pard \s17\qj\sb120 I've adapted the assembler to the Mops environment, so it's a module, pasmMod (with the source file pasmMod.txt).  You write a PPC code definition thus:\par \pard\plain \s8\li720\sb120 \f22\fs20 :ppc_code  someName\par \par \tab <ppc instructions>\par \par ;ppc_code\par \pard\plain \s17\qj\sb120 \f20 This will create a normal header for someName in the dictionary, then align the DP to a 4-byte boundary (as required for PPC code), then compile the code.  Note that if you tick someName, the resulting "cfa" mightn't be on a 4-byte boundary since our cfa's are only 2-byte aligned for the 680x0.  So the "cfa" should be rounded up to the next 4-byte boundary to get the address of the first PPC instruction in the definition.  Possibly when we have a full native PPC version of Mops we might do something a bit more sensible here.\par \pard \s17\qj\sb120 There's no manual for the assembler or disassembler yet\emdash you're on your own!  But the comments in the source files are fairly extensive, so if you're the type of person who might want to write PPC assembly, you'll probably be able to figure out what to do!  \emdash especially as the file "test pasm" in the System Source folder has a definition containing all PPC instructions.  Note: it's a Forth-style postfix assembler.\par \pard \s17\qj\sb120 The PPC assembler-related files are:\par \par \pard\plain \f20 pasmMod.txt\tab \tab in "Module Source"\tab \tab the assembler.\par disasm\tab \tab in "Module Source"\tab \tab the disassembler  (loaded by pasmMod.txt).\par test pasm\tab \tab in "System Source"\tab \tab a big test definition with all the \par \tab \tab \tab \tab \tab \tab \tab PPCinstructions.\par \pard\plain \s17\qj\sb120 \f20 \par \pard\plain \s255\qr\sb720\sa1440\keepn \b\f21\fs48 \sect \sectd \sbkodd\linemod0\linex0\cols1\colsx0\endnhere\titlepg {\headerl \pard\plain \s244\brdrb\brsp80\brdrhair \tqc\tx4680\tqr\tx9360 \f20 II-\chpgn  Mops General Reference\par }{\headerr \pard\plain \s244\brdrb\brsp80\brdrhair \tqc\tx4680\tqr\tx9360 \f20 \tab \tab Chapter 11\emdash Technical Section II-\chpgn \par }{\footerr \pard\plain \li200 \f20 {\f21 \par }}\pard\plain \s255\qr\sb720\sa1440\keepn \b\f21\fs48 Technical Section\par \pard\plain \s17\qj\sb120 \f20 This chapter is intended for hackers, or people who want to understand the nucleus source code better, or for those who are just insatiably curious.  You may use Mops with great success with\-out reading this section, but if you run into some obscure problem which defies analysis, or if you're writing a lot of assembly code definitions, you might find something useful here.\par \pard\plain \s254\qc\sb240\keepn \b\f21 Mops run-time environment\par \pard\plain \s17\qj\sb120 \f20 In compiling code to reference the dictionary, we have the problem that native 68000 code only allows a 16-bit displacement for addressing, in the normal An plus displacement addressing mode.  That is, unless we resort to extra steps in every memory addressing operation, every part of the dictionary must be within 32K of where an A register is pointing.  The 68020/030 chips have a 32-bit displacement mode, but the 68000 doesn't.  Mops has to run on 68000 machines (Plus, SE, Classic, PowerBook 100), of course, so I was forced to find a solution to this problem.  The eventual solution was to dedicate three A registers for addressing.  Mops uses A3 and A4 to address the main dictionary\emdash these registers are set up with A4 pointing 64K higher than A3, and these two registers never change during execution.  This way we can address a dictionary up to 128K in size.  A dictionary can be larger than this, but memory references above the 128K range may be slightly less efficient.  (We give details on this in the later section "Dictionary size".)\par \pard \s17\qj\sb120 We call A3 "lobase" and A4 "hibase".  Modules are addressed using A5 ("modbase").  Since Neon never allowed a module to be accessed from outside except through an exported word, we maintain this rule in Mops, and thus we can ensure that A5 is always valid when a module is in execution.\par \pard \s17\qj\sb120 We use A6 as the data stack pointer, and A7 as the return stack pointer.  This is the other way around to Neon and Yerk.  The advantage for Mops is that a Mops word can be called with a simple BSR or JSR instruction, and nothing further needs to be done with the return address, since it is already on the top of the return stack.  All the words which call the system (such as TRAP) exchange A6 and A7 before the system trap, and then exchange them back on return.  This means that Mops code can push parameters onto the data stack and take results from the data stack, exactly as in Neon and Yerk.\par \pard \s17\qj\sb120 In Mops we have been able to eliminate the methods stack (which Neon had).  We have the same functionality, but we don't need actually need a separate stack.  This comes about because we use A2 for the base address of the current object in methods, and save nested object addresses on the return stack.  Named parameters and local variables used to use the methods stack in Neon; we use D4-D7 and an overflow memory area, and save whatever is necessary on the return stack during nested definitions.\par \pard \s17\qj\sb120 So to summarize the register usage:\par \pard\plain \s13 \f22\fs20 \par D0-2\tab scratch\par D3\tab loop counter I\par D4-7\tab named parms/locals\par \par A0-1\tab scratch\par A3\tab lobase\par A4\tab hibase\par A5\tab modbase\par A6\tab data stack pointer\par A7\tab return stack pointer\par \pard\plain \s254\qc\sb240\keepn \b\f21 Dictionary header format\par \pard\plain \s17\qj\sb120 \f20 This has changed somewhat from Neon.  Most significantly, we have an 8-way threaded struc\-ture, for speed in lookup.  To decide which thread to use for a given word, we simply use the length of the word's name, modulo 8.\par \pard \s17\qj\sb120 In a dictionary header, first there is a 4-byte link field at the lfa (link field address), which gives the displacement from the lfa itself to the previous header on the same thread.  Then comes the name field, which consists of a length byte followed by the name itself, with a zero byte added if necessary so that the total name field is even in length.  Next comes the 2-byte handler code (see later under "compilation and optimization".  That is the end of the header.  We say that the fol\-lowing byte is at the cfa, even though we don't have a code field as such.  For most definitions, executable code starts at the cfa, and for constants, variables and values the data comes there.\par \pard \s17\qj\sb120 In earlier Mops versions we used a 2-byte link field.  The change to 4 bytes was made to allow very large dictionaries.\par \pard\plain \s254\qc\sb240\keepn \b\f21 Compilation and optimization\par \pard\plain \s17\qj\sb120 \f20 Compilation in a STC/native code system is necessarily a bit more involved than in traditional Forth-based systems.  Optimization adds another level of complexity.  Most user coding can be done exactly as in Neon, but the underlying compilation process is a bit different, and so there are a few pitfalls to avoid.\par \pard \s17\qj\sb120 Firstly, let's look at plain ordinary colon definitions.  When a reference to one of these is com\-piled, we compile a BSR.S if we can, otherwise a JSR.  Such words are EXECUTEd simply by calling them.  So far so good.\par \pard \s17\qj\sb120 We also have inline definitions.  For example, it would have been silly to handle DUP by JSRring to the following code:\par \pard\plain \s8\li720\sb120 \f22\fs20 MOVE.L\tab (A6),-(A6)\line RTS\par \pard\plain \s17\qj\sb120 \f20 when we could simply have compiled the MOVE right in line.  Two bytes instead of 4 for the JSR, and much faster.  So what we do is mark certain definitions as inline, and when we compile them, we just move the code in.  In previous versions of Mops you couldn't EXECUTE such definitions, but as from v. 1.6  you can, since we include an RTS instruction at the end of the original copy of the inline code (which starts at the cfa of the definition).  This RTS isn't copied over when the code is inlined in another definition, but is there in the original copy so that it can be called by EXECUTE.\par \pard \s17\qj\sb120 Other dictionary items, such as objects, require other special actions to take place when a refer\-ence to them is compiled.  So what we have tried to do is to take quite a general approach to the problem.  Each dictionary header contains a 2-byte field we call the "handler code".  This determines exactly what should happen when a reference to this dictionary item is to be com\-piled.  For inline definitions, the handler code is positive (but not zero).  It is interpreted as a byte count of the number of bytes of inline code, and this code immediately follows the count.  For most other dictionary items, the handler code is negative and even.  It is used as an opcode for a call to Handlers, which is a separate segment (CODE segment 3).  There are quite a number of different opcodes, and this gives us great flexibility.  In installed applications, the Handlers seg\-ment is not included, and this saves about 16K of code space, and also makes it completely impossible to do any Mops interpretation from installed applications.\par \pard \s17\qj\sb120 Our method of code optimization should be transparent to the user, but the method used has some interesting features.  We don't attempt the complexities of looking ahead in the input stream to find sequences of words that could be optimized.  Rather, we check what we have already compiled to see if it can be improved.  Whenever the Handlers module compiles code that may have optimization potential, it pushes a descriptor onto a stack.  Then when we are checking for optimization possibilities, we check downwards on this stack and take appropriate action.  Each descriptor contains a copy of the DP value for the start of the corresponding code sequence, so whenever we find that we can optimize the previously-compiled code we can easily reset the DP to the right place, then emit the improved code.  This technique allows us to get some surprisingly good results.  For example, if vv is a variable, the code\par \pard\plain \s8\li720\sb120 \f22\fs20 0  vv  i +  c!\par \pard\plain \s17\qj\sb120 \f20 will compile to\par \pard\plain \s8\li720\sb120 \f22\fs20 LEA\tab xx(A3),A1\tab \tab ; Address of vv to A1\line CLR.B\tab 0(A1,D3.L)\tab \tab ; Index on D3 (loop counter i)\par \pard\plain \s17\qj\sb120 \f20 This technique also means that we never have to backtrack if we tried an optimization strategy which failed.  The unoptimized code is always compiled first, and is only recompiled if we know we can legitimately improve it.  This optimization technique has worked well in practice, and generally gives around a 15% improvement in execution speed and a 10% reduction in code size.  Of course, some common code sequences are improved much more than this.\par \pard \s17\qj\sb120 Another optimization involves conditionals.  If, for example, we have the code\par \pard\plain \s8\li720\sb120 \f22\fs20 aConst  IF  <some code>  ELSE  <some more code>  THEN\par \pard\plain \s17\qj\sb120 \f20 where the conditional is testing a constant, the condition will be evaluated at compile time, and either <some code> or <some more code> will be compiled, but not both.  We therefore have a conditional compilation capability, without introducing any new syntax at all.\par Finally, it is worth noting that our optimization technique is reasonably efficient, so that compi\-lation speed does not appear to have been degraded significantly at all.  It is certainly much faster than Neon.\par \pard\plain \s254\qc\sb240\keepn \b\f21 Object format\par \pard\plain \s17\qj\sb120 \f20 Here is our format for normal objects (remember that ivars declared within record \{...\} won't have a header\emdash that is, there will be nothing before the object's actual data).  I'll take this from the top.  For dictionary objects, this will be the cfa.  For heap objects, this will be the beginning of the heap block.\par \pard \s17\qj\sb120 \par \pard\plain \s18\fi-360\li360\ri6580\sb120\sbys \f20 2 bytes\par \pard\plain \s19\qj\li2880\sb120\sbys \f20 offset to the indexed area.  For non-indexed objects, this will be 6.  See below for the subtle reason.\par \pard\plain \s18\fi-360\li360\ri6580\sb120\sbys \f20 4 bytes\par \pard\plain \s19\qj\li2880\sb120\sbys \f20 Class pointer (relocatable)\par \pard\plain \s18\fi-360\li360\ri6580\sb120\sbys \f20 2 bytes\par \pard\plain \s19\qj\li2880\sb120\sbys \f20 Offset from the data start to the class pointer.  -6 for simple objects.\par \pard\plain \s18\fi-360\li360\ri6580\sb120\sbys \f20 (object's data starts here)\par \pard\plain \s17\qj\sb120 \f20 For indexed objects, the indexed area (after the ivars) is preceded by a descriptor with the format:\par \pard\plain \s18\fi-360\li360\ri6580\sb120\sbys \f20 2 bytes\par \pard\plain \s19\qj\li2880\sb120\sbys \f20 Width of indexed elements (in bytes)\par \pard\plain \s18\fi-360\li360\ri6580\sb120\sbys \f20 4 bytes\par \pard\plain \s19\qj\li2880\sb120\sbys \f20 Number of elements minus 1 (i.e. LIMIT-1)\par \pard\plain \s17\qj\sb120 \f20 The last field was a 2-byte field in Neon, and also it held Limit rather than Limit-1.  The expan\-sion to 4 bytes allows the number of elements to be limited only by available memory.  The change to Limit-1 is so that we can do a bounds check on an index with a single CHK machine instruction.\par \pard \s17\qj\sb120 The reason we need the offset from the data to the class pointer relates to multiple inheritance.  In Neon, the class pointer immediately preceded the object's data.  But with multiple inheritance, we will have the ivars for the various superclasses following each other.  If a method in one of the superclasses is called, and it needs the class pointer, it can't look just before its first ivar, since that isn't actually the start of the object's data any more.  So what we do is put a 2-byte off\-set to the class pointer before {\ul each} group of ivars belonging to each superclass.\par \pard \s17\qj\sb120 Now for the reason we use 6 as the offset to the indexed area header for non-indexed objects.  When doing indexing, we use the indexed area header or descriptor (I sometimes abbreviate this as "xdesc") to check for the indexed access being in bounds.  We actually do the check with a CHK instruction, so it is a very fast check.  Now, for non-indexed objects, an offset of 6 won't get us to any xdesc, since there isn't one, but will get us to the other offset - the offset to the class pointer.  Now this offset is always negative.  When the CHK instruction is executed, it will see a negative number as the "number of elements", and always fail.  I don't normally resort to clever tricks like this, but efficiency considerations were paramount here.\par \pard\plain \s254\qc\sb240\keepn \b\f21 Dictionary size\par \pard\plain \s17\qj\sb120 \f20 The Mops main dictionary may be very large (up to 8 megabytes, in fact).  We had to find a way to solve the problem of addressability for the part of the dictionary that is above the hibase (A4) range.\par \pard \s17\qj\sb120 What we do, if we have to compile a reference to this area, is to use a PC-relative mode, if the in\-struction making the reference is within 32K bytes of the target location.  This will probably be so for the majority of references.  If we're outside the PC-relative distance, we compile the sequence\par \pard\plain \s8\li720\sb120 \f22\fs20 MOVE\tab A3,A0\line ADD.L\tab #offset,A0\line <op>\tab (A0)\par \pard\plain \s17\qj\sb120 \f20 This involves some overhead, but it does the job.  Another problem is that if the operation we are compiling alters memory, we can't use the PC-relative mode, even if we are within 32K of the target location (not on a 68000, anyway).  So in this case we compile\par \pard\plain \s8\li720\sb120 \f22\fs20 LEA\tab <addr>,A0\line <op>\tab (A0)\par \pard\plain \s17\qj\sb120 \f20 Hardened hackers will be quick to point out that we can't do a  TST  in PC-relative mode either.  So now we always compile a MOVE to D0 instead of a TST.  This sets the condition code exactly as for a TST, and takes the same number of cycles.\par \pard \s17\qj\sb120 To get some idea as to the real-world space/time penalty for compiling these code sequences, I loaded Mops up to Files, then did a big ALLOT to get the DP above the hibase range, then loaded the rest of the system.  The resulting load was less than 10% larger than normal.  The speed seemed unaffected, but I didn't do detailed measurements.  I expect it was impacted to about the same extent as the space.  These results suggest that for most applications, going over the hibase range won't make a lot of difference.\par \pard\plain \s254\qc\sb240\keepn \b\f21 CODE resources\par \pard\plain \s17\qj\sb120 \f20 In the original Neon implementation, the CODE 0 resource was the jump table (as in all Mac applications), and CODE 1 was the dictionary.  In installed applications, each module became another code segment, but in "development mode" these were the only CODE segments there were.  On startup, CODE 1 expanded itself (via _SetHandleSize) to the required dictionary size, and the selected dictionary image was then read in above the nucleus.\par \pard \s17\qj\sb120 The Mops scheme is a slight development of this.  Under System 7 I found the system was load\-ing CODE 1 high, because it was marked "locked".  It then couldn't expand itself, since it couldn't relocate while running, and there was no room above it.  I found I could get around this problem by not marking it locked in the resource file, but felt that maybe I was heading for trou\-ble later on.  I thought that possibly having a CODE segment expand itself, while actually run\-ning, might not be such a marvellous idea.  So now we have another CODE segment.  The main dictionary is now CODE 2, and CODE 1 is a small segment that does most of the initialization stuff.  It also gets a handle to CODE 2, unlocks it (just in case), expands it as needed, then moves it high, locks it and jumps to it.  Once in CODE 2, we unload CODE 1, which has done its job.\par \pard \s17\qj\sb120 CODE 3 is the Handlers segment.  It has only one entry point, and an opcode is passed to it to tell it what to do.  The comments in Handlers have all the details.\par \pard \s17\qj\sb120 Installed applications have CODE 0, CODE 1 and CODE 2 segments.  Handlers is not present, and is not needed.  The CODE 2 segment doesn't need to be expanded, since all the needed dic\-tionary is already there.  CODE 1 still does all the initialization, but skips the part where it expands CODE 2.  As in Neon, any needed modules become additional CODE segments.  Their resource numbers will be strange numbers obtained by calling UniqueID, but the names are attached to the resources so you can tell which is which in ResEdit, if you need to.\par The jump table is very short, since it only needs to reference 4 CODE segments.  Modules are accessed through the corresponding module object in the dictionary, not through the jump table.  Other object-oriented systems on the Mac have used the jump table for implementing dynamic objects, and so have run into problems with the original 32K limit on the size of the jump table.  This limit has now been removed by Apple with its new "32-bit everything" addressing scheme, but in Mops we never had the problem anyway.\par \pard\plain \s254\qc\sb240\keepn \b\f21 Relocatable address format\par \pard\plain \s17\qj\sb120 \f20 This section is included for information only, and to help debugging.  A I said at the beginning, please don't rely on these details remaining accurate.  I have no plans to change at the moment, but you never know.\par \pard \s17\qj\sb120 Our relocatable address format was determined largely by the need to be able to address any\-where within a very large dictionary, and also to fit in 4 bytes.  The top byte is 5, 6 or 7.\par It is 5 if the address is relative to the main dictionary.  The low 3 bytes give the offset from lobase (A3).\par The top byte is 6 if it is a module address.  The low three bytes give the offset from modbase (A5).\par \pard \s17\qj\sb120 The top byte is 7 if it is a self-relative address.  We currently use this for a module address which is stored in the same module.  A situation can arise for which A5 isn't valid\emdash an action handler in an object whose class is implemented in a different module, may well be accessed when A5 is set up for that other module.  This relocatable format will work in this situation since it doesn't depend on A5.\par It only takes around 10 machine instructions to decode a relocatable address, and we also pick up the case where the top byte isn't 5, 6 or 7, and give the "Not a relocatable address" error.  (We used 5, 6 and 7, rather than 0, 1 and 2, to give a higher rate of error detection\emdash if an erroneous longword is used as a relocatable address, its probablilty of having a high byte of zero would be greater than for most other values, I would expect.)\par }