
                Pygmy Forth version 1.5 MANUAL
             Copyright 1989-1997 Frank C. Sergeant
                                 809 W. San Antonio St.
                                 San Marcos, TX  78666
                                 pygmy@pobox.com
                                 http://www.eskimo.com/~pygmy

                    **** DISCLAIMER ****
All RISKS associated with using this software and/or 
information are WITH YOU!  I assume no liability whatsoever. 
If this is not satisfactory to you, do not use this software 
and/or information.
                 **** End of Disclaimer ****

     Pygmy Forth version 1.5 is a fast direct-threaded Forth
for reasonably compatible MS-DOS & PC-DOS machines.  It
includes an editor, assembler, and metacompiler (so it can
recompile itself) in only 16K to 18K.  Up to 15 files can be
open simultaneously.  It now includes a multi-tasker and the
ability to execute C library routines.  It comes with full
source code and documentation.  It is based loosely on
Charles Moore's cmFORTH.

    TABLE of CONTENTS

              Chapter  1   Terms of use and distribution
              Chapter  2   "Bonus Disk"
              Chapter  3   Pygmy Forth T-shirts
              Chapter  4   Credit Where Credit is Due
              Chapter  5   Why I Wrote Pygmy
              Chapter  6   What Is Pygmy?
              Chapter  7   How To Run The Program
              Chapter  8   If You Are New to Forth
              Chapter  9   What Was New With Version 1.2
              Chapter 10   What Was New With Version 1.3
              Chapter 11   What Was New With Version 1.4
              Chapter 12   What Is New With Version 1.5
              Chapter 13   Tips
              Chapter 14   How Files Work
              Chapter 15   The Assembler
              Chapter 16   The Editor
              Chapter 17   The Metacompiler
              Chapter 18   Vocabularies
              Chapter 19   Additional Information
              Chapter 20   How to Reach Me
              Chapter 21   The Glossary & Index
              Chapter 22   Memory Map
              Chapter 23   Files
              Chapter 24   Direct Threaded
              Chapter 25   History & Philosophy
              Chapter 26   How to Print the Source Code
              Chapter 27   _Starting Forth_ Notes
              Chapter 28   Multi-Tasker
              Chapter 29   C Library Routines, etc.
              Chapter 30   The Kermit File Transfer Protocol
              Chapter 31   Addresses and Additional Resources


Chapter 1        Terms of use and distribution

     I hold the copyright to all of the documentation and
source code and machine code included in the Pygmy Forth
version 1.5 package, including the organization and
presentation thereof, with the exception of the parts taken
from public domain sources or contributed by others.

     Please see the DISCLAIMER near the beginning of this
document.  Conditional upon recipients accepting full
responsibility for any adverse consequences or damages, I
grant to recipients of this package permission to further
distribute it; to post it on computer bulletin boards, ftp
sites, cdroms, etc.; to use it for developing personal or
commercial applications; and to use parts of it in building
other Forth systems.  I DO NOT GRANT permission to
distribute printed copies of the source code or the
documentation, or to publish the same in books, magazines,
etc.  If you wish to do something along these lines, please
contact me.  (I am excluding from this the excerpted source
code you have incorporated into your own Forth system, and
nothing here is intended to prevent you from printing out a
hard copy of the source code and documentation for your own
use.)

                Is This Shareware or What?

     Well, yes and no.  You are welcome to use Pygmy.  If
you do, you assume all risk.  Don't use it on anything
important until and unless you have completely tested it.
If you like Pygmy, feel free to send me some money.  A gift
of any amount will be appreciated.  Please don't refrain
from writing, regardless.


Chapter 2     "Bonus Disk"
              (available only via uuencoded email)

     I offer a "Bonus Disk" to encourage you to "register"
if you send me at least $15.  Because of the way my bank
works, this must be in the form of a check drawn on a U.S.
bank and payable in U.S. dollars, a U.S. or International
Postal Money Order payable in U.S. dollars, or cash in U.S.
dollars.  (My bank wants to charge me $15 to $20 dollars to
process either a wire transfer or a check drawn on a foreign
bank or payable in a foreign currency.  This strikes me as
insane in this age of computers, but there you have it.)  Do
not go to any great expense to pay for a money order or to
insure your letter, as any risk of loss, even of cash, is
very slight, considering the amount of money involved.

     Furthermore, it is no longer a physical disk.  I will
send you the "bonus disk" as uuencoded email.  So, please
send me your email address.  If you do not have an email
address, you have a friend or neighbor who does.

     Here are the probably contents of the "bonus disk"
(exact contents subject to change):

 1. PYGMY.DOW
    Shadow file commenting block by block on
    the PYGMY.SCR source code.

 2. SERIAL.SCR, SERIAL.DOW
    Serial I/O routines with interrupt driven input.

 3. Double (32-bit) and Quad (64-bit) number support with
    128-bit intermediates.

 4. FILTER.SCR examples of creating filter programs to read,
    modify, and write from and to standard input and output.

 5. Copies of various articles on metacompilers,
    introduction to Forth, help screens, 8 Queens in Forth,
    arbitrarily high precision math (e.g. 1000 decimal
    digits).

 6. Some laser printer support code (HP Laser Jet II, etc.)

 7. Forth assembler for the Motorola 68HC11 microprocessor
    that can be run from Pygmy on the IBM PC.

     You really ought to get this, for the shadow blocks if
nothing else.  Combined with the ability to switch back and
forth between source and shadow while in the editor, they
provide a very useful on-line reference.


Chapter 3       Pygmy Forth T-shirts

     When my girl friend Beth was a child, she published a
family newsletter called _The Heitzman Press_.  Her
grandfather was in the sign and printing business and
produced a cartoon that she put in one of her issues.  The
cartoon shows Beth in a cannibal's stew pot saying "You
can't do this to me, I'm the editor of the Heitzman Press!"
and the cannibal, holding a shield and spear, replying
"Don't worry missy, soon you be Editor in Chief."

     Beth extracted the image of the cannibal to use as the
logo for Pygmy Forth.  She had a few T-shirts made that say
"Pygmy Forth" and show the Pygmy caricature from the cartoon
in black, green, and brown.  The shirts are a light tan or
beige, 100% cotton.  At the moment (July, 1997) we have five
of them left, all Extra Large.  While supplies last, we will
sell these for $20 in North America and $25 elsewhere,
postpaid.  If there is enough interest in them (which I,
personally, find difficult to believe), Beth possibly will
have more made, and in a variety of sizes.  If you are
interested, it might be best to confirm availability by
email before sending money.


Chapter 4       Credit Where Credit is Due

     Pygmy Forth was inspired by cmFORTH for the NOVIX, a
public domain Forth written by Charles Moore.  Much of the
overall structure and specific high level code reflect this
influence.  Some of the machine code, especially flag
producing words, is tighter due to ideas suggested by Robert
Berkey.  Wil Baden provided OF THENS.  The initial approach
to handling files was suggested by Dennis Ruffer by his
description of files in Forth Inc's polyForth.  Rob Chapman
contributed the idea of (and how obvious when you think
about it) having FOR NEXT do the loop <n> times instead of
<n+1> times.  He also contributed a slogan that I've
adopted: "It's so simple - it HAS to work."  Many other
people, especially Ian Watters, Greg Lisle, Brad Rodriguez,
J.E. Thomas, and David Zethmayr have offered suggestions and
encouragement (and prodding) that have helped make Pygmy as
pretty as it is today.  Thank you.


Chapter 5          Why I Wrote Pygmy

     Pygmy Forth's goals:
          1. Fast, comfortable editor.
          2. Reduced sized and complexity.
          3. Inclusion of certain cmFORTH ideas:
             a. PUSH POP (instead of >R R>)
             b. FOR NEXT
             c. no IMMEDIATE word
                (but it does have words that are immediate)
             d. simple Metacompilation

     Pygmy includes
         1. a fast screen oriented block editor
         2. an 8088/8086 assembler
         3. full source code
         4. full metacompiler, easy to use
         5. up to 15 files open & accessible at one time
         6. default set of files opened automatically
         7. FOR/NEXT, PUSH, POP, \, COMPILER vocabulary, and
            other cmFORTH improvements
         8. BIOS video calls for the best mix of speed
            and compatibility.
         9. optional direct video for fastest speed
        10. vectored I/O  ( EMIT, KEY, KEY?, CR )
        11. documentation (this file)
        12. _Starting Forth_ compatibility hints for people new
            to Forth
        13. an experimental beginner's tutorial
        14. VIEW for rapidly locating the source code for
            a particular word
        15. a relocatable dictionary
        16. ability to make individual words or groups of
            words headerless
        17. ability to load from textfiles with FLOAD
            and to mix and nest between LOAD and FLOAD
            as deeply as you like
        18. multi-tasker
        19. PC serial port routines (** here or on bonus disk? **)
        20. Kermit file transfer protocol written in Forth
        21. embeddable in C wrapper to allow Forth to use C
            library routines and to allow C to call Forth
        22. it runs on everything from an XT or palmtop
            (HP95LX, HP100LX, HP200LX, Atari Portfolio,
            etc.) to a Pentium under DOS or in a DOS box
            in Windows 3.1, Windows 95, Windows NT, or
            Linux.


Chapter 6             What Is Pygmy?

     Pygmy is one step on my path toward a "perfect" Forth.
It runs on IBM PC/XT/AT and compatibles.  It is based (more
and more loosely) on Charles Moore's cmFORTH for the NOVIX
Forth chip.  I have made many changes to allow it to run on
a PC, and other changes as well.

     cmFORTH was designed to run on a NOVIX connected by a
serial line to a host terminal or computer that supplies
editing and file storage services.  Therefore, cmFORTH does
not include an editor.  Also, no assembler is needed
because the NOVIX's assembly language is Forth (more or
less).

     Pygmy Forth includes an editor & assembler and still
only takes up about 18K bytes fully loaded.  The kernel
(without editor and assembler) is less than 10K.  Actually,
you have quite a lot of control on just how big it is
because you can customize the system just the way you like
it.  It comes with complete source code, including the
metacompiler, so it can recompile itself.  The metacompiler
can also be used for compiling custom applications.  In this
case you can eliminate the parts (such as the editor &
assembler & various utilities) that the final application
will not need.  And you can make words headerless to reduce
the size of your final applications.  Regenerating the
kernel (with 1 LOAD) takes about a second on my Pentium
90 MHz PC.  Then, extending it with the editor, assembler,
multi-tasker, etc. with 5 LOAD takes about a second.

     Pygmy is direct threaded with top of stack kept in a
register.  It has a comfortable screen oriented block
editor.  You can move quickly from block to block with the
PgDn & PgUp keys, search across blocks, insert blank blocks,
and compress out blank blocks, and switch between related
blocks (for shadows or for comparing different versions of
an application).

     Pygmy allows 15 files open at one time.  These are all
accessible "simultaneously" at different block numbers.
Your default files are opened automatically and the defaults
can be changed, of course, and additional files can be
opened. .FILES shows you the defaults and the documentation
shows examples of how to reset them.  If you need more than
15 files open at one time, there is supplemental code that
shows how to have over 200 files open at one time.


Chapter 7           How To Run The Program

     Make a backup copy of the distribution disk, if you got
it on a disk.  (I do not think you will get it on disk from
me, as I have gone to email or ftp distribution only.)  If
Pygmy is distributed in a ZIP file, unzip it.  If you are
going to run from a hard disk, set up a directory and copy
all of the files to that directory as in the following
example.

           C:\>md pyg 
           C:\>cd pyg 
           C:\PYG\>copy a:*.*

    Then bring up Pygmy by typing
           C:\PYG\>pygmy

     All of the source code for the system, both the kernel
and the extensions, is in the block file PYGMY.SCR.  The
manual is a regular text file, PYGMY.TXT (the file you are
currently reading), which is readable with LIST or nearly
any text editor.  Another block file, YOURFILE.SCR, is
provided for the source code you write.  It starts out with
8 blank blocks and can be enlarged as much as you like with
the Editor's F9 key.  Of course, you are free to create and
use additional block files, but you do not have to do so in
order to use Pygmy.

     To read the source code, bring up Pygmy and then use
Pygmy's editor to browse through the block file PYGMY.SCR.
To start at the beginning, make sure Caps Lock is on, then
type

           0 EDIT    

(end all commands by pressing <Enter>).  Then just start
browsing with the PgDn & PgUp keys.  If you have the shadow
blocks available, press Ctrl-A to switch between a source
code block and its shadow.  To get out of the editor press
Esc.  To get back in where you left off, type

           ED

   To skip to a particular block, press Esc to get out of
the editor and then type    n EDIT    where n is the block
you want to jump to.  To see what files have been opened
automatically, get out of the editor and type

           .FILES

   To see the source code for a particular word, type VIEW
followed by the word's name, e.g.   VIEW EXPECT  or you can
use the shorthand  V  .

   If you get error messages when you try to open files, it
probably means that your CONFIG.SYS file is not allowing
enough files.  Change or add a "FILES=" statement to
CONFIG.SYS so it says  FILES=20  or higher, then reboot and
try again.  (As shipped PYGMY.COM tries to open only a few
files automatically, so this should rarely be a problem.)

   If your monitor works with DOS it should work with Pygmy.
Version 1.5 of Pygmy no longer tries to set itself up to
match a particular monitor.  Instead, it accesses the video
through BIOS calls.  However, the direct writes to video
memory is much faster on old, slow computers.  So, you can
re-vector EMIT to use the direct writes instead of the BIOS
if you wish.


Chapter 8         If You Are New to Forth

     The purpose of this manual is not primarily to teach
Forth.  To learn Forth, work your way through the book
_Starting Forth_ by Leo Brodie.  It should be available from
the Forth Interest Group (see phone number below).  Pygmy
does not try to be compatible with _Starting Forth_.  I have
a few notes in a later chapter about converting the
_Starting Forth_ examples to Pygmy that may help.

     Jump in and try to write some simple code.  See my
experimental Tutorial article to see if it helps get you
oriented.  Spend some time browsing the source code in
PYGMY.SCR with the built-in editor.

     As a Forth to learn with, Pygmy may have some
advantages:  (1) it doesn't cost much, (2) the entire source
code is included, (3) it is small enough and
non-intimidating enough that you have a chance to grasp it,
(4) metacompiling, using Pygmy, is the easiest I have ever
seen, and (5) I am usually available to answer questions via
comp.lang.forth or email.  (Let's abandon the postal service
altogether for this sort of thing and use it only for
sending me checks or cash.)

     If you want to try it without a book, then read all of
the documentation and read the source code as well.  Try out
simple examples.  Join FIG and read _Forth Dimensions_.
Then get a book, like you should have done to begin with.
Then read everything again and try out more examples.  There
is no substitute for doing your own experimenting.  The word
VIEW is a great help.  To examine the internals of a word or
data structure, use DUMP or DU.  Make heavy use of the
source code and shadows.  The stack comments are most
helpful, showing what goes into a word and what comes out.
You could even try the experimental tutorial I have
included.  Print it out so you can work from a hard copy.


Chapter 9        What Was New With Version 1.2

Just the highlights:     

   / does a signed division, truncating toward zero  
     ( eg    -3  2  /  returns  -1  ) rather than flooring.  

   U/   does an unsigned divide.

   BOOT is DEFER'd to make it easy to customize
( e.g. ' MYAPP IS BOOT ).

   Fast DO LOOP are now available (courtesy of Robert
Berkey).  [no longer included as of version 1.5]

   TYPE ( a # -)  replaces the cmFORTH TYPE ( a - a').  I
have also added  COUNT  and  -TRAILING to support it.  I
like the cmFORTH TYPE ( a - a') but the ending address was
only used in one or two places so I've changed this to TYPE$
( a -).

   NUMBER now understands hexadecimal literals such as $8000
and $FF and ascii character literals such as  'A  'B  'z.

   .S  

   "   has been added for in-line string literals.  At
compile time it compiles the following text up to the ending
quote mark as a counted string.  It then commas in a zero
byte, which is not included in the count.  The purpose of
this is to make it easy to setup "asciiz" strings for DOS.
E.g.  : TST  " this is a string "  TYPE$  ;


Chapter 10     What Was New With Version 1.3

     File handling has been overhauled.  Everything is now
done relative to the unit# of the file.  See UNIT, SETTLE,
CHOP, OPEN, ?CLOSE, etc. (but see additional changes in
version 1.4, where the handle is used even more often).

     ABORT is now a DEFER'd word, to make customizing
applications easier.

     For Leonard Morgenstern, NUMBER & LITERAL are now
DEFER'd.  (This also makes adding the double and quad number
extensions easier.)

     (ONEKEY  is the default for KEY.  It returns a single
value no matter what key is pressed, rather than a single
value for some keys and two values for other keys, as DOS
does.  I prefer the consistency of a single value.  You
can still say  ' (KEY IS KEY  if you prefer the double code
for special keys.  [in version 1.5, (KEY is the current
name for what used to be (ONEKEY]

     All the source code is now in a single (block) file.
All the documentation is now in a single (text) file.

     Metacompiling is even easier.

     FILES now keeps track of the highest block # in the
file.  Neither the editor nor BLOCK will go outside actual
file bounds.

     HOLES was added to editor (F9).  SETTLE & CHOP make
managing block files more convenient.

     Search across now always goes to end of file, no need
to set the ending block number.  (But Esc key will abort
the search.)

     THRU no longer uses the data stack, so multi-block
definitions which pass arguments on the stack during
compilation can now be loaded with THRU.

     Added N! ( n a - n) to store n into a, keeping a copy
of n

     Changed FOR/NEXT so 0 FOR ... NEXT goes thru loop zero
times & u FOR ... NEXT goes thru loop  u times.

     ABORT" now includes the IF.

     Added +UNDER ( a b c - a+c b).

     Added NIP ( a b c - a c).

     Straightened out the redundant EXIT.  


Chapter 11      What Was New With Version 1.4

     Some of the following words are optional extensions and
are not in PYGMY.COM until you LOAD them.  See blocks
139-141 for information on loading these extensions.

     "  can now be used outside definitions as well as
within.

     FILE handling has changed and/or improved in several
directions.  Check _all_ your code for compatibility with
the new file handling words.  We can now open a file inside
or outside of definitions with a string literal (or a named
string as before) " FILE17.SCR" 4 OPEN  which beats the
cumbersome process of v1.3.  Files are now opened by
specifying the name and the unit number.  The number of the
first block of each file is the unit number times one
thousand, e.g.  0, 1000, 2000, 3000, etc.

The following words now take a handle instead of a unit#:
  LBLK  >EOF  >BOF  FCLOSE  POSITION@  >POSITION  +POSITION
  FILE-READ  FILE-WRITE  MORE  FILE-SIZE  SET-FILE-SIZE

FOPEN and FMAKE take an asciiz counted string and return a
handle and flag, eg.  " T1.TXT" FOPEN  from inside or
outside of a colon definition.

The following words still take unit#:
     ?CLOSE ?OPEN OPEN? EXISTS? MAKE ?MAKE

Thus there is no longer a need for HANDLE-WRITE, etc.  I
think this factoring is more flexible and will let us do
anything we want to do with DOS files.  The above form the
basis for a textfile loading facility, which is optionally
loaded, or not, at metacompile time.  I'd like to please
those who really want to be able to load source code from
textfiles while not penalizing those who only want to load
from blocks.  The main words are

  READ-LINE ( - a #) 
  FLOAD ( name -)              e.g.  " FILE3.TXT" FLOAD
  INCLUDE ( <file-name> ( -)   e.g.  INCLUDE FILE3.TXT

they use various auxiliary words such as 
  FIB  ( holds addr of file input buffer)
  #FIB ( holds length of text string in file input buffer)
  >FIN ( holds offset from start of textfile)
  FBLK ( holds handle number for active textfile)
  FIBH ( holds handle number that matches contents of FIB)

This system allows virtually unlimited nesting in any
combination of block and textfile  LOAD and FLOAD and
INCLUDE.

Restrictions on contents of textfiles:  They are expected to
contain lines of no more than 132 characters [as of version
1.5, this can be changed -- see block 2], which end in CRLF
($0D $0A).  Single words may not cross line boundaries.
Paren type comments ( such as this) would be fine as long as
the parens are paired on the same line.  However I am adding
a slightly different definition of left paren (as an
extension) which will allow multi-line comments, such as

(  This is a multi-line 
   comment because the ending paren 
   is not on the same line as 
   the beginning paren.) 

All control characters in the file buffer (after
partitioning it by CRLF pairs) are converted to spaces.
Thus, there is no special requirement as to whether the file
ends in Ctrl-Z, etc.  Even though lines are expected to end
in CRLF pairs, there is no problem if the CRLF is missing
from the final line of the file.

There is now a #TIB which is analogous to #FIB.  QUERY can
be used to gather text to be WORD'd (a simple #TIB OFF at
the end will keep INTERPRET happy; no more having to fool
with SPAN and >IN) and now EXPECT can be used without
disturbing INTERPRET since the #TIB function has been
separated from SPAN, thus no need for $INPUT, but I have
added #INPUT as an extension.

Textfile loading does not involve the unit# table and
neither does SAVEM or SAVE, so the need for UN-UNIT (or its
newer name RELEASE) goes away as well (or so I think).

I have improved TXT>BLK which _creates_ a block file from a
textfile, and BLK>TXT which _appends_ a range of blocks to
the end of an already existing textfile.  (I think only one
of the words was in version 1.3, and that it was much
slower.)

Conditional compilation:

I have added   .IF ...  .ELSE  ...  .THEN    and  ?LOAD  to
the metacompiler for conditional compilation (e.g. to allow
the constant TFILES to control whether to load the textfile
words or just the plain block words).  Don't nest the .IF
etc.

  -1 CONSTANT TFILES   ( true if textfiles are desired)
  TFILES .IF   73 75 THRU  .ELSE  76 LOAD  .THEN

View Fields and Headerless Words

I've been going up and down and back and forth on this.  At
first I made view fields a metacompile-time option; once set
the system always had view fields or never had view fields.
I also allowed headerless words with Ian's suggested |
symbol preceding the word to be made headerless, but only
during metacompilation.  I didn't want users burdened with
view fields if they didn't want them, or if space was too
tight.  However, I decided if I was going to have headerless
words at all then I hated not to be able to behead the
various editor support words.  So, I decided to allow
headerless at anytime.  That eases the burden that view
fields might cause, as space can now be saved, if necessary,
by making certain words headerless.  I was torn over whether
to use | which is compact but has to be used for every word
you want headerless, or to use  HEADERS OFF ... HEADERS ON
to bracket an entire section that is to be made headerless.
I finally compromised by allowing both.  And, they can
co-exist without trouble.  If either HEADERS are OFF or if a
word is preceded by | then the word will be headerless,
otherwise headerful.

This means we need PRUNE and { and } in the kernel, not just
in the metacompiler.  The two versions do different things.
The alternate dictionary must be established before using
headerless.  Currently the word SET-EDGE sets up H' and
remembers its initial value.  EDGE refers to the edge of the
world that the headerless words' headers fall off of.  I'm
open to suggestions for better names.  Care to suggest a
decent name for this?  PRUNE resets H' from EDGE, and is
included in SAVE, because an unpruned dictionary with
headers over the EDGE would be useless if reloaded.  Note:
as shipped, EDGE is set to $C000.  Be sure not to let the
dictionary grow above this value if you have any unPRUNE'd
headers present.  (If you define any headerless words, PRUNE
before HERE gets to $C000, or do SET-EDGE to set the EDGE to
a higher value.)

Using this headerless feature has allowed most of the editor
and assembler support words' headers to vanish.

EMIT and video words

v1.3 did direct video writes for speed.  On occasion this
caused problems on slightly non-IBM-compatible computers
(such as the AT&T 6300 (or whatever number it was).  v1.4
has changed to doing EMIT and related words with BIOS Int
$10 calls.  This should greatly increase compatibility and
should still be fast (providing no TSRs such as NEWKEY get
in the way and slow things down).  [Note, June '97, the BIOS
EMIT is not fast enough on XTs, so you probably will want to
revector EMIT to a direct write version.]

     As before, most of the I/O words are vectored, so you
still can replace any routines with ones of your own. The
need for system variables CUR, VID, and CRTC goes away.
[well, see the direct EMIT code in the extensions]

     Also, these low level words such as (EMIT, (CR, (KEY
now have any ending parenthesis removed, so as not to
accidentally end comments.

     ATTR is still used, but with a difference.  In v1.3,
this value was merged with every character written to the
screen.  Also, the attribute byte was kept in the most
significant byte of the variable ATTR (to make the merging
simpler).  Now ATTR holds the attribute in the least
significant byte.  So, if you had used  $7100 ATTR ! to make
a pretty dark blue on light blue screen, you will need to do
$71 ATTR !  2000 .ATTR or  $71 ATTR ! CLS instead, with
v1.4.  Now the attribute is only combined with characters by
the word .ATTR.  See .ATTR below.

     Summary of video words:

   (AT  ( row col -)   positions the cursor.
                       It is usually what AT uses.

   (CUR@  ( - row col) fetches current cursor position
                       (so you can save it and later
                       restore it).  It is usually
                       what CUR@ uses.

   (EMIT   ( c -)      Writes a byte to the screen at the
                       current cursor position and advances
                       the cursor, using a BIOS Int$10
                       teletype style video write.  Scrolling
                       is done automatically at bottom of
                       the screen.

   AT@     ( - aacc)   Reads the character and attribute
                       byte of the character on screen at
                       the current cursor location.  The
                       most significant byte is the
                       attribute and the least significant
                       is the character.  Use 255 AND to
                       isolate the character, or use 256 U/
                       to isolate the attribute.

   .ATTR   ( # -)      Writes the specified number of blanks
                       to the screen, applying the value in
                       ATTR to each one.  This starts at the
                       current cursor location but does
                       not change the position of the
                       cursor.  For example, this is used by
                       (CLS to clear the screen and set the
                       attributes of all the screen
                       positions at once.  These attributes
                       will remain in effect until changed
                       again by .ATTR (or some word that
                       uses it, such as (CLS ).  So, if you
                       want to write a field with a
                       different attribute (e.g. blinking,
                       or a different color), you first need
                       to set ATTR to the new attribute
                       value (e.g. $BBFF ATTR !) and then
                       write the text of the field, e.g.

        ATTR @       ( optionally save current attribute)
        $71 ATTR !   ( dark blue on light blue background)
        25 .ATTR     ( clear a field 25 characters wide)
        ." This is the new text"
        ATTR !       ( optionally restore previous attribute)

   (CLS   ( -)        Clears the screen by writing 2000
                      spaces, using the current attribute
                      (in ATTR).  Note, this could be
                      changed if you have a larger or
                      smaller screen than 80 x 25.  It is
                      usually what CLS uses.

     This set of BIOS video words is more than the bare
minimum we might get by with.  For example, CLS could be
done with 25 carriage returns.  Then we would not need .ATTR
or AT@.  (AT@ is used in (BOOT to set ATTR to whatever
attribute is currently in use at position 0 0 when the v1.4
is invoked.)  But, then, you could not change attributes and
so could not underline or reverse fields, or change colors,
etc.  Also, AT is now in the kernel in v1.4 but was not in
v1.3.

     In addition to these words, two more BIOS video words
are included in the unloaded (extension) section:

       SCROLL-UP ( row col row col #lines attr -)

       SCROLL-DOWN ( row col row col #lines attr -)

                 These scroll the text the specified number
                 of lines, and blank the new lines at either
                 the top or bottom.  All of this is done
                 only in the window specified by the upper
                 left row and col and the lower right row
                 and column.

     I have added various additional words in the extension
section, including COLORS.  Load it, if it is not already in
the PYGMY.COM, and try it out.  You can set the color by
storing the correct numbers into ATTR, but you might want to
use words such as BLUE ON-BLUE or RED ON-YELLOW or BLINK or
UNDERLINE or REVERSE, etc.

     QUIT restores EMIT to whatever is in DEFAULT-EMIT.

     Pygmy no longer tries to guess what type of video
display is present.  When it wakes up, it sets the cursor to
top left, fetches whatever attribute byte is already there,
and uses it thereafter unless you change it.  So, if you
have a color screen at the DOS prompt, and like those colors
(or don't like them), they should be the same colors in
Pygmy.  If you don't like those colors, say   $1F ATTR ! CLS
or  $71 ATTR ! CLS  and see if you like those colors better.
Also try the word COLORS that lets you step through various
possibilities of foreground and background colors by
pressing the F1 and F2 keys, as mentioned above.

Miscellaneous 

     CONDENSED (for use in printing blocks 6 per page in
SHOW2) is currently set for a HP Laser Jet.  See the load
blocks if you want to change this for other printers.  To
check its setting, just type SEE CONDENSED  (as SEE now
handles DEFER'd words).

     DUMP and DU save the base, display in HEX, then restore
the base.  As DU does multiple DUMPs, and I can give it a
huge count and interrupt it with a keypress, I rarely need
to follow DU with another DU or DUMP.  So, DU no longer
leaves the next address on the stack.

     BYE now does FLUSH before exiting.

     Constants set the data & return stack initial
addresses, so if you want to change the sizes you only need
to make the change in a single location.  In addition, there
is a constant STACKSEG which should ordinarily be set to
either 0 or to 1.  If STACKSEG is 0 then the data and return
stacks will be in the same 64K segment that contains the
rest of Pygmy.  If STACKSEG is 1 then the data and return
stacks will be in the 64K segment above the 64K segment
which contains the rest of Pygmy.  I've added the constant
TOP so the location of the disk buffers & input buffers can
be customized (for those attempting to minimize the RAM
Pygmy occupies when running).  Note that I have set up the
data and return stacks to use their own segment and each has
about 32K of room.  If you switch back to using stacks in
the same segment as the rest of Pygmy be sure to alter the
stack offsets accordingly!  All of this is now done easily
by setting options at the beginning of PYGMY.SCR; see the
load blocks.  [version 1.5 has returned to putting the
stacks in same segment containing the rest of the code]

     SEE now shows what DEFER'd words are deferred to, very
handy!  Now that we allow headerless words and are using
RECOVER and have view fields (and if all else fails we have
the search across blocks facility) the former SEE has been
discontinued and the new SEE's only function is to show
where a DEFER'd word is pointing.


The Editor

     v1.3's editor on pretty-thoroughly-IBM-compatible
computers has been a joy for me to use.  However, it has not
been very easy to convert to other (dare I say "weird")
hardware.  So, I have re-written the editor slightly so it
keeps its hands off the video except through properly
DEFER'd words, rather than trying to write to the video
memory directly.  So, if you can make versions of CLS, AT,
CUR@, and EMIT that work on your machine, and if your screen
has enough rows and columns, you should be able to get the
full screen editor working on your machine.  ED and PgDn and
PgUp no longer restore ins/overwrite to overwrite, thus the
setting stays the way you left it, unless you say EDIT.

     The system variable CURSOR has been renamed to EBLK.
It is used by the editor to keep track of the beginning
address of the block buffer that holds the block being
edited.

     I have added a shadow facility to the editor.  Ctrl-A
switches between related blocks.  Alt-A sets the current
block as one of the two base blocks.  The default, if you do
not set any base blocks with Alt-A (or if you set them both
to the same block), is to consider that alternate thousands
are related  (0 and 1000, 1 and 1001, etc. or 2001 and 3001,
2002 and 3002).  That's why I have moved YOURFILE.SCR to
2000, to leave room at 1000 for the Pygmy shadow blocks (see
Bonus Disk) that match PYGMY.SCR at 0000.  Do Alt-A on the
two blocks you want to compare and then hold down Ctrl-A to
see the difference ("flickering" as described by Dick
Miller).


NUMBER
     
     I want NUMBER ( a - n), which takes a counted string,
to become NUMBER ( a # - n), which takes an address and
count.  I have compromised.  I added (SNUMBER ( a # - n) and
left SNUMBER and NUMBER as ( a - n).


Textfiles

     They are nestable to any level and in any combination
with LOAD.  Use " <filename>" FLOAD for postfix or use
INCLUDE <filename> for prefix.  At the moment the length of
any one textfile is limited to 64K.  Setting a single
constant in the metacompiler to true or false determines
whether the textfile code will be included in the kernel.
That way, non-users of textfiles do not have to suffer the
extra overhead.

                       
EXPECT

     I fixed a bug in EXPECT that was pointed out by Steve
Birrell, whereby it wouldn't let you type the full length if
backspace-deleted characters took up some of the room.
EXPECT can now be used without concern for resetting SPAN or
>IN as it no longer disturbs the terminal input buffer.  See
QUERY when you want to get some input and use WORD on it.

MS

     v1.4 now has a (more or less) machine-independent
timing word, MS, in the extensions.  This reads Timer 0 to
tell when it has killed approximately the requested number
of milliseconds.  Since loop speeds will vary among
different speed machines, there will still be some slight
variation.  Feel free to cusomize the count value to tune it
exactly for your specific machine if you wish.

>STD 
>DOS

     The BIOS video EMIT words cannot be redirected (via the
command line).  Unloaded optional words culminating in >STD
and >DOS can be redirected, although they are slower for
screen use than (EMIT etc.

added FILE-SIZE ( unit# - ud) 

I switched code for 0< to that suggested by Andrew McKewan

Fixed error pointed out by Greg Lisle in XREF (and made it
prettier?).

I put in a regular FORGET

I added textfile INCLUDE (which uses textfile FLOAD)

VIEW, HEADERS, and |

     Basically, as Ian Watters suggested, I have added VIEW
fields and the capability of making headerless words.  The
word | preceding a definition marks that one word as
headerless.  Some posting on GEnie requested that words
reading the input stream be factored so a version is
available that takes a pfa (e.g  : VIEW ( -) ' (VIEW ;  ),
however I have not done it that way.  Instead, I've provided
the word VFA so if a non-input stream version is needed,
just ( pfa) VFA @ and then do whatever you want with the
block number.  If the view field is zero then the word was
compiled from the keyboard (or a textfile).  VIEW simply
terminates in this case.  You can uncomment the code to have
it print an error message if you wish.

More details: 
HEAD is factored out of CREATE, the "pfa" of a headerless
word contains the magic byte $D6, which won't ever appear as
a machine opcode, followed by the value of the real pfa.
cmForth set the msb of the count byte.  The magic byte
method costs an extra byte for every headerless header, but
saves time in (-FIND on every compare when traversing the
dictionary).  The headerless headers don't disappear until
the word PRUNE is executed.  The word | preceding a word's
definition makes that one word headerless.  Pygmy has always
had the ability to compile utilities out of the way in
higher memory and then use them to compile words into the
lower dictionary area.  However, it takes PRUNE to cut those
high words out of the dictionary when you are through with
them.  The PRUNE version of the metacompiler will not work
for this except when metacompiling, hence a new version for
regular use.

By the way, the $D6 magic byte comes from Ian as a byte that
does not appear as an opcode in the '386 or lower.  Looking
in a '386 book it looks like we could also use $F1 or $82
for this purpose.

I tried out a high-level -FIND and it was about 8 times
slower than the code (-FIND.  So, we'll stick with the code
version for now.  Now (-FIND has become -FIND (ie no longer
DEFER'd); ditto for (WORD & WORD.

RESET and reset in version 1.3 have now been consolidated
into RESET.

A one byte INT3, has been added to the extensions (for Ian
Watters) [as of v1.5, it is in the assembler].

At Greg Lisle's suggestion I have changed OPEN so it takes a
unit number instead of a starting block number.  Also, I
have renamed F# which converts a block number to its
corresponding unit# to >UNIT#.

SHELLing out to DOS and the ability to read command lines
passed from DOS have been included as extensions.


Chapter 12      What Is New With Version 1.5

     Multi-tasking

     Command line execution

     Improved SHELL and EXEC documentation

     RP! and SP! take values from stack now

     Embeddable within a C wrapper
       (see the article)

     Kermit file transfer protocol (on bonus disk??)

     New serial port routines (on bonus disk??)

     Direct video EMIT available in the extensions.  Use
this if the BIOS EMIT is too slow on your machine.  To use
it, remove the appropriate left paren on block 141 so that,
when extending the kernel, 5 LOAD will load the direct EMIT.


Chapter 13                 TIPS

     Set Caps Lock on.  Most words must be typed in UPPER
CASE.

     To abandon changes you have just made in the editor,
use Esc to get out of the editor then type   EMPTY-BUFFERS

    ?SCROLL  is embedded in WORDS and DU to let you halt
the display by pressing any key (except Esc).  Press any key
again to start it up again (except Esc).  To bail out,
whether you are scrolling or paused, press Esc.  You can also
put ?SCROLL into your own words.  For my tastes, this is
very much better than the common practice of aborting when
you press the <Enter> key.

    DUMP ( a - a')  and DU ( a # -) allow you to inspect
memory.  DUMP dumps one line and leaves the address of the
next line ready for typing DUMP once more.  DU repeats DUMP
for a number of lines, dropping the final address.  ?SCROLL
is built in, so feel free to type  0  2000 DU  (you can get
out of it with Esc, or pause with any key).

    .FILES ( -) shows the files that are currently open and
the block numbers associated with them.  You can open ANY
type of file; you are not limited to Forth style BLOCK
files.

     The word ." works either inside or outside of colon
definitions.  There is no need for the abomination  .(
(Actually there are two words named  ."  one is in FORTH and
the other is in COMPILER.)  Similarly  "  can be used inside
or outside definitions for creating a string literal.

     Pygmy recognizes $xxxx as a hex number (e.g.  $2000
$FE  $03F8) and it recognizes character literals as well
(e.g. 'A 'B  'C  'z).  The hex literals are a great
convenience and allow us to stay in DECIMAL more of the
time.  The character literals allow us to avoid the ugly
CHAR & [CHAR] or ASCII & [ASCII].

     NOT inverts the truth value on the stack.  It is
equivalent to 0=.  If you want to invert each bit
individually, use  -1 XOR


Chapter 14           How Files Work

     Pygmy can access a number of files "simultaneously."
As shipped, it contains 15 slots or units for files, stored
in the FILES array.  I often refer to this as the unit#
table.  This can be changed to a smaller number if you wish.
If you must access more (perhaps over 200 files), that can
be done also, and sample code is included in PYGMY.SCR.
1000 blocks are reserved for each unit#.  The highest block
number that can be used is 32766.  Block number 32767 is a
dummy block number used when FLUSHing blocks back to disk.

     Before you can access a file (as a block file), it must
be installed into one of the slots.  This is done by the
word OPEN or by the word UNIT.  UNIT establishes the file's
name (as it is known to DOS) and starting block number.
This name can include the full path, including drive, for
those cases where the file is not in the current directory.
The parameters for OPEN or UNIT are the filename and the
unit#.  The unit# will then determine the starting block
number.  The starting block number will always be 1000 times
the unit#.  Thus the file in unit# 0 starts at block 0, the
file in unit# 5 starts at block 5000, etc.  The filename is
the address of a counted string that ends in a zero byte
(for the DOS "asciiz" format).  There are several ways to
define the name.  Previously I used the word NAMEZ: which
defined a word whose name is the string.  For example,

             NAMEZ: YOURFILE.SCR

but now I generally just use a string literal, e.g. 

            " YOURFILE.SCR"  2000 OPEN

   Once you have installed the file with UNIT or with OPEN,
you can open and close the file repeatedly just by using the
unit#.  To replace that file in a particular slot in the
unit# table, just open another file at the same unit#.  The
file that was previously in that unit# will be closed
automatically before the new file is opened.  You might want
to type FLUSH before opening the new file.

     As shipped, Pygmy version 1.5 has three files that are
already installed in units 0, 1, and 2.  These are
PYGMY.SCR, which contains all the source code, PYGMY.DOW
which contains the shadow blocks (see Bonuses), and
YOURFILE.SCR, which contains 8 blank blocks.  These are
automatically opened for you and ready to go.  YOURFILE.SCR
is provided so the new user of Pygmy has a block file ready
to hold his own source code.

     Any time you want to see which files are installed in
units, whether they are open, or what their starting block
numbers are, type

             .FILES

     You are not limited to these files.  Close them all
down with RESET-FILES if you like, and open your own set.
If you save that image of PYGMY  (eg  SAVE TST1.COM),
whenever you bring up that image (by typing TST1 at the DOS
prompt) your custom set of files will be opened for you
automatically (and the list of names and starting block
numbers will be displayed).

     Each block in the entire system of open files has its
unique number.  There is no need to use the F83 OPEN/FROM
CONVEY.  There is no need for OFFSET.  To copy a range of
blocks, whether to and from the same or different files,
just say  ( from to #) COPIES   e.g.

             17   300  50  COPIES

to copy the 50 blocks starting at block 17 to the 50 blocks
starting at block 300.  It is an error if those blocks do
not exist.  In earlier than 1.3 versions of Pygmy you
could extend a file just by accessing a block past the end
of file.  In later versions the blocks must already exist.
To extend a file, either use the word MORE or use F9 from
within the editor.  It does not work quite like the MORE of
F83.  If the file is not empty, the easy way to extend it is
to get in the editor and move to the last block and use the
F9 key (which does MORE for you).  For copying a single
block you can still use COPY.

For creating a new block file from within Pygmy, see NEWFILE
in the extensions.


Chapter 15              The Assembler

     The 8088/8086 assembler in Pygmy is a regular Forth
postfix assembler.  For examples of how it is used, browse
through PYGMY.SCR.

     Begin a code word with CODE and end it with END-CODE,
e.g.

         CODE DUP    BX PUSH,   NXT,   END-CODE

     Except in special cases (and then you know what you are
doing) code words must perform next somehow.  In Pygmy, this
code is laid down in-line (by the word  NXT,) rather than by
a jump to a central next routine.

     If your routine disturbs CS, DS, BP, SP, SI, or BX it
must restore it.  The direction flag must be left clear.

     BP points to the return stack.

     SP points to the data stack.  The top (data) stack item
is kept in BX rather than on the actual stack.  See example
above for DUP.

     SI is Forth's IP register.  AX is Forth's W register,
but you may use it freely without restoring it.

     The assembler words generally end in a comma, signaling
they actively "comma" data into the dictionary.  This is
useful for another purpose: as the assembler words and the
regular Forth words all sit in the same vocabulary (FORTH),
the comma helps distinguish between similar words, e.g. THEN
versus THEN,


     It is a "structured" assembler with
     
    <set-codes> <condition>
    IF,   XXXXXX    ELSE,   XXXXXX   THEN,

and

     XX #, CX MOV, BEGIN,  XXXXX  LOOP,     

etc.

     If it is not clear from the instruction whether the
operand is a byte or a word, a byte is assumed.
E.g.   0 [BX] SHL, would shift only a single byte.  To
override this, use W-PTR  e.g.

     0 [BX] W-PTR SHL,
     ( shift word at 0[BX] based on count in reg CX)

     For the shifts & rotates, if an immediate operand
precedes it, it shifts a single bit, e.g.

   1 #, AX SHR,   ( shift AX right one bit right)
or even
   300 #, AX SHR, ( shift AX right one bit, not 300 bits)

     If you want it to shift based on the contents of CL,
omit the immediate operand, e.g.

    4 #, CX MOV,  AX SHR, 

examples to shift right 1 bit:

     1 #, SI SHR,  
     1 #,  W-PTR  17 [BX] SHR,  
     1 #, AL SHR,

examples to shift right the # of bits in CL

     SI SHR,
     AL SHR,
     1300 ) SHR, 
     3752 W-PTR  ) SHR,

IN, and OUT,  (reading & writing I/O ports)

use  
      port #, AL IN, 
or
      port #, AX IN, 
for 8 bit ports

or 
      AX IN,   if the port number is the DX register. 

Do not use    AL DX IN,  as the DX is implied.


JMP, and CALL,

     Long JMPs & long CALLs are "not supported at this
time."  (Well, perhaps they are now?  Check the assembler
code to find out.)

     The instruction that does a bit by bit complement is
called NOT by Intel, but in _this_ assembler it is called
COM,.  This assembler uses NOT, to invert the test at the
beginning of an IF,   e.g.
 
      CS, IF, ( do if carry set)      THEN,
or  
      CS, NOT, IF, ( do if carry not set)  THEN,

     The full source code for the assembler is present in
the file PYGMY.SCR.  Some examples are included along with
the source code.  In addition, you can browse the code of
Pygmy's primitives for examples of how to use the assembler.
The general rule is that the operand(s) come first followed
by the opcode mnemonic (which ends in a comma).  With two
operands, the source comes first and the destination second,
like god meant it to be.  E.g. BX AX MOV,  lays down a move
instruction to copy the contents of register BX into
register AX.


Chapter 16              The Editor

                     Editor commands:

   To enter the editor, type  n EDIT.  To get out of the
editor, press the ESC key.  When you are in the editor you
can make changes by using the arrow keys to position the
cursor and then just typing.  Press the INS key to switch
between the insert and the overwrite modes.  The backspace
key will delete characters to the left of the cursor and the
Del key will delete the character the cursor is on.  Inserts
and deletes only occur on the current line.

   The PgUp & PgDn keys are used to move to the previous or
next block.  This is delightfully fast.  If the cursor is at
the beginning of the line already, Home moves to top of
screen; otherwise, Home moves to beginning of current line.
End moves past last character on current line.

     The very top line of the screen is a status line that
shows the block number and the file name and a brief
reminder of some of the function keys' functions.  It also
shows an "i" if in the insert mode.  It also shows a count
of the lines in the cut buffer.

   F1 repeats a search.

   F2 repeats a replace.

   F3 sets up a search string and then searches.

   F4 sets up a replace string and immediately replaces with
      it.  (To repeatedly change CAT to DOG, use F3 to set
      up CAT then use F4 to set up DOG and then press  F1 F2
      F1 F2 etc.)

   F5 deletes the current line.

   F6 joins the line below to the current line at the
      cursor.

   F7 "cuts" the current line to the cut buffer.  This does
      not alter the current line.  (See the "c= " on status
      line).

   F8 "pastes" the oldest line in the cut buffer to the
      current line on the block, overlaying the current
      line.  The cut buffer is almost unlimited in size.  It
      can be used to copy and move lines on the same block
      or to different blocks (even blocks in different
      files).  Notice that the count of lines cut (on the
      status line) changes as you press F7 & F8.

   F9 inserts blank blocks after the current block.

   F10 does a search like F1, but across multiple blocks.

   Esc exits from the editor.  If you want to cancel the
       most recent changes, after pressing Esc, type
       EMPTY-BUFFERS.  If you want your most recent changes
       to be applied to the disk immediately, after pressing
       Esc, type FLUSH.

   CR  ends the current line, pushing anything to the right
       onto the following line and pushing the lines below
       it down.

   Home  moves the cursor to the beginning of the current
         line.  If already at the beginning, it moves the
         cursor to top left corner.

   End  moves the cursor just past the end of text on the
        current line (which may be at the 1st position of
        the following line).

   Bksp  If not at the far left of a line, it deletes the
         character to the left of the cursor.

   Del  deletes the character the cursor is on.

   Ins  toggles insert vs overwrite modes (see the "i" on
        status line).

   Ctrl-A switches between related blocks (usually shadow
          blocks, but see Alt-A below).

   Alt-A marks the current block as one of a pair.  Do this
         on two separate blocks to mark the base block
         numbers for two related ranges so that Ctrl-A will
         then switch between them.  To return to the
         default, where the even thousands and the the
         following odd thousands are related (e.g. 0000 and
         1000, 0001 and 1001, etc. or 2000 and 3000, 2075
         and 3075) just press Alt-A twice on the current
         block.

     Note, the deletions and insertions only affect the
current line.

                          Oooops

     How do you exit from the editor without making any
changes? (cancel your changes, that is)?  Press Esc key to
get out of the editor and then type
     
       EMPTY-BUFFERS

Warning, this will only eliminate the changes that have not
yet been written back to disk.

     F9 is good for opening up a file in the middle or for
extending a file at the end.  As you move blocks around and
delete them from where they used to be, you may accumulate a
number of blank blocks.  SETTLE (used outside of the editor)
is used to let the heavy blocks sink to the bottom and let
the light blocks float to the top.  It only affects the
range of blocks that you specify, e.g.

                 315  345  SETTLE

will re-arrange those blocks so that any completely blank
blocks are at the highest numbers and the non-blank blocks
are at the lowest numbers.  This compresses out blank
blocks.  A related word CHOP will truncate a file by
chopping off all trailing blank blocks, e.g.

                 3 CHOP

will chop the blank blocks off the end of the file whose
unit# is 3.


Chapter 17          The Metacompiler

     Pygmy includes a metacompiler.  It is easy to use.  To
regenerate the kernel of Pygmy, edit the source code in the
file PYGMY.SCR to include your changes.  Then type

                     1 LOAD

     This will create a new version of the Pygmy kernel and
save it to disk.  Be sure to edit the file name you want it
saved as on scr #1.  Exit to DOS with

                     BYE

and bring up the new version you just created.  It is the
kernel only, without the editor or assembler or other
extensions.  However, it will have the file PYGMY.SCR
already set up in unit# 0, and opened automatically.  To
extend it, just load the proper load block.  This block
number is usually noted on block #1 to make it easy to find.
It will usually be block #5, e.g.

                     5 LOAD

Look at block 5 to see how this works.  You can edit the
load blocks so they will include just what you want and then
save the newly created Forth to the filename you specify.

     Metacompiling Pygmy is very easy, so don't put off
trying it.  It lets you fix all the aspects of Pygmy that
you disagree with me about.  Your first attempt should be to
generate a version of Pygmy with no changes whatsoever,
except possibly the filenames you save the new versions
under.  After you've done this once or twice you can begin
changing the kernel, or extending it differently.

     Here is how the metacompiler works.  First the load
block (#1) sets some options then loads the metacompiler.
This renames some of the current Forth's words (so they can
be found later) and then redefines the defining words needed
for the new Forth.  Note a number of variables such as TLIT
and TVAR etc.  These will hold the addresses of the target's
runtime routines (for LITERAL and VARIABLE etc.) as soon as
those runtime routines have been defined in the target.  The
metacompiler will use those values to compile the proper
code in the target.

     Then, the load block loads the target's code.  The
target is compiled starting at address $8000.

     H' holds the target's dictionary pointer (H holds the
host's).  Following H' is the relocation factor used for the
target code.  The curly braces switch between the target &
host spaces, so that the regular host facilities, such as ,
HERE -FIND etc can be used for both purposes.  The host does
need some special metacompiler words.  When we are
redefining a host word that we might need the original of,
the original is renamed, so we will still have access to it
under the synonym ( e.g.   : :' :  ;  ).  There are two
ghost vocabularies used for the target.  After our
redefinitions, FORTH & COMPILER refer to the target and
FORTH' & COMPILER' refer to the host.  This is the secret
that keeps everything straight.

     When interpreting, words are looked up and executed (as
is normal) from the FORTH' (host) vocabulary.  When
compiling a colon definition, COMPILER' (host) is searched
first.  If found the word is executed immediately.  If not
found, FORTH (target) is searched.  If found, the word is
compiled into the new definition.  If not found, it is
converted to a number (or an error) and compiled as a
literal into the new definition.  So, when metacompiling,
target COMPILER words are never executed, leaving the host's
free to operate.  When not compiling, target FORTH words are
never executed, leaving our regular host system free to
operate.  \ is redefined so when metacompiling, the word is
looked up in the target's COMPILER vocabulary and compiled
into the new definition.

     So what changes might you make?  Changing the constant
TMAX-FILES will let you specify just how many files to allow
open at the same time.  Changing TNB lets you change the
number of file buffers that will be used.  Currently TNB is
1, which allows 2 buffers.  Note that the number of buffers
must be a power of two (and greater than 1), so acceptable
values for TNB are 1, 3, 7, 15, etc.  (TNB and thus NB are
set to 1 less than the number of buffers.)  You can
eliminate the excess and useless words that I've included
which you see no need for.  (Just don't eliminate any that
are used in the definitions of other words that you want
to keep.)

   For target applications, you can let the metacompiler
compile all of your CODE (assembly language) words so that
you do not need to include the assembler in the final target
application.  (You might also eliminate the editor from the
final application if it isn't needed, but, since it is
loaded after the kernel has been created, that's not
affected by the metacompiler.)

   If you are target compiling an application and want it to
execute your code automatically (rather than coming up in
Forth) just point the word BOOT at your application.
Suppose you have named it  YOUR-APPLICATION. Type

              ' YOUR-APPLICATION IS BOOT

and then save it to disk  with something like 
   
              SAVE YOUR.COM

   Note that BOOT can be re-vectored as above at anytime,
not just when metacompiling.


Chapter 18            VOCABULARIES

     PYGMY, like cmFORTH, has two vocabularies: FORTH &
COMPILER.  Compiler words are immediate by virtue of being
in the COMPILER vocabulary.  INTERPRET only looks up words
in FORTH.  When compiling, COMPILER is searched first.  A
word found in COMPILER is executed immediately, otherwise
FORTH is searched and, if the word is found, it is compiled.
To force compilation of a COMPILER word, precede it with a
backslash ( \ ). This is used in place of the FORTH-83 word
[COMPILE].  CONTEXT holds the number that represents which
of the two vocabularies is active.  Whichever it is, it is
the vocabulary into which new words will be linked.  FORTH &
COMPILER set CONTEXT to the appropriate number.

     There are also has 2 "spare" vocabularies available for
use by the metacompiler.


Chapter 19        ADDITIONAL INFORMATION

   For additional information, browse through all of
PYGMY.SCR using the editor ( n EDIT ) and the PgDn & PgUp
keys.  Searching across blocks (using F10 in the editor,
after setting up the search string with F3) is handy for
finding a particular word's definition and where it is used.
Use VIEW <word> or its shorthand  V <word> to pop into the
editor on the source code for a particular word.  Then use
Ctrl-A to switch to the corresponding shadow block (see
Bonuses).


Chapter 20     How to Reach Me (and other addresses)

     I'm glad to hear your comments.  What I hope will be
my permanent email address is pygmy@pobox.com or
frank.sergeant@pobox.com.  This is a forwarding service and
will forward email to whatever real account I'm using at the
time.  Also, I expect to read (and post the occasional
message to) comp.lang.forth, so that is another place to
look for me if the pygmy@pobox.com address ever fails.
I would prefer to handle my correspondence by email rather
than the US Postal Service, so please use email.  For
sending money or in emergencies, my mailing address is

                  Frank Sergeant 
                  809 W. San Antonio St. 
                  San Marcos, Texas  78666

Currently, I also have a web page at
http://www.eskimo.com/~pygmy containing links to other Forth
information, etc.

Join FIG,
   Forth Interest Group        (408) 373-6784 (voice)
   100 Dolores St., #183       (408) 373-2845 (FAX)
   Carmel, CA  93923           office@forth.org

FIG is a great source for Forth related publications.  The
membership fee includes a subscription to _Forth Dimensions_,
in which I occasionally have an article.  Tell 'em I sent
you.  The FIG web site, http://www.forth.org/fig.html contains
extensive Forth resources.  See also http://www.forth.org.

I have also had occasional articles in
        _The Computer Journal_            (800) 424-8825
         P.O. Box 3900                    (916) 722-4970
         Citrus Heights, CA  95611-3900
Call or write for a trial subscription.

Send email to Greg Lisle (L.G.Lisle@iee.org) for
information about his PygTools shareware
utilities/libraries for Pygmy.


Chapter 21            The Glossary & Index

     The on-line availability of the system's complete
source code, coupled with the search across function in the
editor, plus VIEW, plus the editor's shadow block function
(if you have the shadow file PYGMY.DOW) serve as the
glossary and the index.  You can look up anything and
everything.


Chapter 22             MEMORY MAP

     Pygmy fits in one 64K segment or less.  In version 1.4,
it offered the choice of putting the stacks into a separate
segment.  I've decided this is more trouble than it is worth
and have returned the stacks to the single segment.  If, for
some reason, you particularly need the stacks in a different
segment, consult the version 1.4 source code for the
details.

     DOS loads Pygmy at offset $0100.  CS@ will fetch the
contents of CS (the code segment register), in case you need
to know the absolute address of the program.  The dictionary
grows up from low memory.  The tib, fib, disk buffers, and
the stacks are in high memory (within the one segment).  The
metacompiler constant TOP allows you to say how high
high-memory is.

Here is a sample memory map, with 4 disk buffers and TOP =
65536. (The following gives the flavor of the memory map,
not necessarily the actual values)

origin                 $0100
boot code              $0100
caller's saved SP      $0102
caller's saved SS      $0104
first word to execute  $0106   (this points to RESET)
continue with boot     $0108
1st word's VFA (null)  $0132
system variables       $0150 - $0197 (common to all tasks)
user variables         $0198 - $01EF (for Terminal task)
dictionary continues   $01F0
HERE                   $46ED  ( perhaps, with text files &
                                 multitasking loaded)
return stack pointer   $ECFE  ( grows down from $ECFE, ie R0 @ )
data stack pointer     $EBFE  ( grows down from $EBFE, ie S0 @ )
FIB @                  $EDFE  ( FIB is below TIB -- for textfile loading)
TIB @                  $EF00  ( TIB is below the disk buffers)
                              ( The highest disk buffer is 1K below TOP)
4th disk buffer        $F000
3rd disk buffer        $F400
2nd disk buffer        $F800
1st disk buffer        $FC00
metacompiler TOP      $10000  ( ie 65536, to allow a full segment)


Chapter 23                FILES

     MAX-FILES block files may be open at once.  If you want
a different mix, use RESET-FILES and open a new set, or
re-setup the files one by one with UNIT or OPEN.  If you
then save an image of Pygmy, those files will be opened
for you automatically next time you bring it up.

     To install a file, you must say what unit# to use.  Set
it to 0, 1, 2, etc.  The unit# you select determines the
starting block number for that file.  It is always 1000
times the unit#.


Chapter 24           DIRECT THREADED

     Pygmy is direct threaded, with TOS kept in a register
(BX) for speed.

     Constants are coded "in-line" rather than by jumping to
a central constant routine.  This costs 2 bytes per constant
but saves 40 cycles (46 vs 86).  (These timing notes refer
to the original calculations for an 8088.)  System variables
are really coded as constants.  So this method helps speed
up the system.  Note that the system variable TIB does not
return the address of the input buffer, but the address of
the address of the input buffer, as in figForth.

     Variables don't seem to offer the same advantage and so
they still use a central routine.

     DEFER/IS deferred words are supported.  EMIT, KEY,
KEY?, CR, BOOT, ABORT, NUMBER, and LITERAL are deferred.

           ( e.g.  DEFER EMIT   ' (EMIT IS EMIT    )


Chapter 25           HISTORY & PHILOSOPHY

     Pygmy is based on cmFORTH by Charles Moore.  cmFORTH
was designed for the NOVIX Forth chip.  cmFORTH didn't
include an assembler as that wasn't needed for the NOVIX.
Also, it didn't include an editor, as it was designed to be
used with a host terminal or computer that supplied the disk
storage and editing facilities.  A Forth for the IBM PC/XT
etc., can't do without an assembler and editor, and so these
have been included as part of Pygmy.

     Pygmy uses cmFORTH as a starting point for a fast lean
Forth that can be used for serious application development.

     I've added multiple files (up to 15, but you can change
to fewer if you like) open at the same time, and the default
set are opened automatically.  This was inspired by Dennis
Ruffer's notes on GEnie about Forth Inc's PolyForth.  If you
want up to 200+ files open at once (well, there are some
other considerations), see the supplemental code in
PYGMY.SCR.

     The editor is fast and comfortable.  

     I want Pygmy small and fast, but I want it comfortable
too.  It has grown bigger because of the VIEW fields, but
the ability to make words headerless compensates for that, I
think.

     I have not added additional vocabularies.  I like the
cmFORTH idea of marking immediate words by the fact that
they are in the COMPILER vocabulary.  Everything else is in
FORTH.  This limitation on the number of vocabularies has
not been a problem for me in practice, although it leads to
the naming of assembler words with an ending comma.

     DO/LOOP have not been included.  If you miss them too
much, load them (Robert Berkey's version) from the PYGMY.SCR
in version 1.4.  I probably haven't used DO/LOOP in 6 years
or so, just FOR/NEXT.

     I no longer use cmFORTH's  TYPE ( a - a').  The cmFORTH
TYPE worked on counted strings (i.e. a one byte count at the
address, followed by the string).  Instead I use a regular
TYPE ( a # -).  In addition there is TYPE$ ( a -) which
expects the address of a counted string.  It does COUNT TYPE
and does not leave an address on the stack.

     There are 3 name changes in cmFORTH (& Pygmy) that
delight me:  

             new names        old names

                  PUSH               >R
                   POP               R>
                     \        [COMPILE]

PUSH and POP are so much easier to read and write, for me,
than >R & R>.  PUSH & POP are so much better names, in my
opinion, that I don't see how you can try them and then go
back to >R & R>.  However, a number of people _have_
convinced me that _they_ see how to do it.  So, it is a
matter of opinion, and you are free to change them back if
you wish.

I also prefer \ to [COMPILE].  I like ( for comments, so I
do not mind losing \ for that purpose.  Also it is shorter
and clearer (I think) than [COMPILE] once you get used to
it.

     The stack comment for cmFORTH's  M/MOD is
( l h u - q r) but I have implemented it as the more
familiar ( l h u - r q).

     Of course, there are extensive changes from cmFORTH
because the primitives had to be coded in 8088/8086 machine
language rather than NOVIX.

     Overall I am very pleased with version 1.5.  Very
little has changed from version 1.4 except for the addition
of multi-tasking and the ability to embed Pygmy in a C
wrapper in order to call C library routines or to pass
control back and forth between a C program and Pygmy.  Other
than that, SP! and RP! now take their values from the stack
and the stacks are in the single segment with the rest of
the code.  Also, commands to Pygmy can be passed on the
command line, e.g.

      C:\FORTH\PYGMY CR CR ." Hello!" CR BYE

In addition, I have had a chance to run through the code and
documentation to correct some typos and improve some
comments and perhaps organize the files a little better.  If
you have been following the versions of Pygmy, I think you
will feel right at home with this new version.  If you are
new to Pygmy, well, you will be starting with the best
version of Pygmy.

     I think there is room for a number of different styles
of Forth.  Speed with lots of primitives in machine language,
versus ease of porting to other microprocessors by having a
minimal number of primitives:  I (more or less) went for the
speed.  I traded off some efficiency in disk access for a
much more regular and comfortable file interface.  I've
supplied the hooks for sequential file access (see FILE-READ
FILE-WRITE >POSITION >EOF >BOF etc.) primarily for accessing
data files in various formats for any purpose.  In addition,
as mentioned above, full textfile loading is available.

     I think a Forth system should come with its complete
source code, and so Pygmy does.  I would rank that as one of
my highest requirements in choosing a Forth.  I also think a
Forth system should be fairly _small_.  I am appalled by
systems (Forth as well as the modern C and Pascal systems)
that require many megabytes of a harddisk.  It is a shame
for increasingly bloated and slow software to throw away
much of the advances in hardware speed.

     However, there are several types of speed to consider.
For me, application speed is of secondary importance
(providing it is fast enough) to the speed with which I can
develop an application.  For me, programmer speed is more
important.  However, the economic tradeoffs have changed.
Memory and CPU speed are vastly cheaper than they used to
be.  Does this mean we are no longer concerned with the size
of the development environment or application?  I admit to a
certain inertia with regard to "moving with the times" (i.e.
it hurts me to see the modern slow, bloated applications),
but I believe size still matters.  One reason for that is
the rule that complexity breeds complexity.  Another reason
has to do with memory caches.  The smaller your application,
the more chance of it remaining in fast memory.  Another
reason has to do with the size of your personal memory
cache, i.e. your mind.  There is a mental cost associated
with huge development environments.  And, when those huge
development environments run _slowly_, even on a fast
machine, there is the destruction to your soul from being
made to wait.


Chapter 26      How to Print the Source Code

     SHOW prints source code blocks 3 per page.  SHOW2
prints source code blocks 6 per page (your printer must
allow 132 character lines).  These words are now included in
PYGMY.COM, so you don't have to load anything.  If you are
using SHOW2, you must set up the word CONDENSED so it will
work with your printer.  See blocks 5 and 162 for more info.
Once you have set CONDENSED correctly for your printer, type

   0  199  SHOW       ( 3 blocks per page)

  or

   0  199  SHOW2      ( 6 blocks per page)

  or

   0 199 1000 SHADOW  ( 6 blocks per page with shadows)

to print the entire contents of PYGMY.SCR.

     If you are using an HP LaserJet II, IIP, or III, (or
many other printers) you can set the characters per inch
from the front panel (internal font #10 on a II, for
example) and just set CONDENSED to a NOP
( e.g.   ' NOP IS CONDENSED ), or you can use the included
LJ-CONDENSED (i.e. ' LJ-CONDENSED IS CONDENSED ).


Chapter 27      _Starting Forth_ Notes

     The following are some notes and code for using Pygmy
with the first edition of the book _Starting Forth_ by Leo
Brodie.

 p. 12 & 13    STARS     & CHAPTER 6   DO LOOP +LOOP
  instead of     : STARS ( # -) 0 DO  STAR  LOOP  ;
         use     : STARS ( # -)  FOR  STAR  NEXT  ;

  Pygmy uses FOR ... NEXT instead of DO ... LOOP.

  The arguments for DO  are  limit & starting-index  and
  the loop counts up from starting-index  to just before limit
  e.g.     : TST1  7 0 DO  I  .  LOOP ;  would print
        0  1  2  3  4  5  6 ok

  FOR ... NEXT  only takes one argument, the starting index.
  It counts down that many times, e.g.

       : TST1  7 FOR I . NEXT ;
       would print      6  5  4  3  2  1  0  ok

  p. 25   stack underflow and overflow

  Pygmy does not check for stack overflow.  It checks for
underflow whenever you do .S

  Anytime an error occurs - such as typing in a word that it
doesn't know - it will reset the stack and the return stack
to their correct initial values.

  The word  .S  will display the contents of the data stack.
It shows the entire contents.  This is handy for debugging.
If, before and after loading one or more blocks, .S shows
different stack pictures you have an error in the blocks,
possibly an IF without a matching THEN.

  p. 50 & p. 83 non-destructive stack print

  The definition given in the book
   : .S  CR  'S S0 @ 2- DO I @ . -2 +LOOP ;
will not work in Pygmy.  However,  Pygmy has a built in  .S
you can use instead.

  p. 101   ABORT"
  Pygmy has an IF built into ABORT"
So, you can say  DUP 0= ABORT" error "  just as in the examples.

  p. 123   F83's  >R   is equivalent to Pygmy's  PUSH
  p. 123   F83's  R>   is equivalent to Pygmy's  POP

  p. 302   F83'S  [COMPILE] is equivalent to Pygmy's   \
that's a backslash - it does not indicate the whole line
is commented out as in F83.  It forces compilation rather
than execution of the following "immediate" word when you
are making a colon definition.  It only works on words that
are in COMPILER.

  p. 177    <#  and number conversion
  <# does not expect a double number, just a regular 16 bit
number.  However, in Pygmy you do not need to say TYPE after
the ending #> as the the TYPE is done as part of #>.  I was
undecided as to whether I liked this or not, but it has grown
on me.

  p. 258 TYPE in Pygmy is not like the TYPE in cmFORTH.
In Pygmy, TYPE is the same as in _Starting Forth_ and F83, etc.

 Pygmy also has the word TYPE$ ( a -) which expects the
address of a counted string.

  CHAPTER 9      internal structure
  In Pygmy, every definition consists of a 2-byte view field,
a 2-byte link field, a 1 to 32-byte name field, and a variable
length parameter field.

  The name field consists of a 1-byte count followed by zero
to 31 characters.

  In a colon definition, the parameter field begins with a 3
byte jump to machine language code that nests down a level.
Those 3 bytes are followed by the addresses of the words
that make up the definition (2 bytes per address).

  In a CODE definition - machine language - the parameter
field begins with the actual machine code.  A word may be
headerless, thus beginning with its parameter field.

  The following is information that you will not need unless
you write CODE words:

     The top stack item is kept in register BX.
     The word must end with an "in-line" next.  This is
         accomplished by the assembler macro  NXT,
     Register SI is used for IP so if you want to use SI
         you need to save & restore it.
     PUSH, & POP, are used for both stacks, see source code
         examples of switching the value in registers BP & SP
         by using the assembler macro  SWITCH,

Miscellaneous
       _Starting Forth_'s  TIB  is Pygmy's  TIB @


Chapter 28           Multi-Tasker

     See the source code and the examples in PYGMY.SCR.
PYGMY.DOW has additional information.


Chapter 29        C Library Routines, etc.

     Pygmy v1.5 has the ability to execute commands given on
the command line.  It also has the ability to be embedded
inside a C wrapper program.  In this case, Pygmy can have
access to C functions and variables and data structures,
including those in C libraries.  C can call Forth routines
and Forth can call C routines.  For full details, consult my
article "Coordinating Pygmy and C" in the March/April, 1996
(Volume XVII, Number 6) issue of _Forth Dimensions_.  A copy
of that article (in the file CPYG.TXT), along with the files
LP.C, BGI.SCR, and BGI.DOW, are included in this
distribution of Pygmy 1.5.


Chapter 30      The Kermit File Transfer Protocol

     As I write this in late June, 1997, I expect my article
"Kermit in Pygmy" to appear in _Forth Dimensions_ in the
near future.  It comprises the files KERMIT.SCR and
KERMIT.DOW and KERMIT.TXT, which describe my simple
implementation of the basic Kermit file transfer protocol.
These files are included in this distribution of Pygmy 1.5.
The article refers to the use of the multi-tasker for
polling the serial port.  This is interesting (to me, at
least) and seems to work fine on fast machines with buffered
serial ports.  However, for our production use, we have
switched back to using an interrupt routine for reading the
serial port, allowing it to work even with slow machines or
unbuffered serial ports.


Chapter 31     Addresses and Additional Resources


     See Chapter 20 above for how to reach me.


Join FIG,
   Forth Interest Group        (408) 373-6784 (voice)
   100 Dolores St., #183       (408) 373-2845 (FAX)
   Carmel, CA  93923           office@forth.org

FIG is a great source for Forth related publications.  The
membership fee includes a subscription to _Forth Dimensions_,
in which I occasionally have an article.  Tell 'em I sent
you.  The FIG web site, http://www.forth.org/fig.html contains
extensive Forth resources.  See also http://www.forth.org.

I have also had occasional articles in
        _The Computer Journal_            (800) 424-8825
         P.O. Box 3900                    (916) 722-4970
         Citrus Heights, CA  95611-3900
   or see my web page for a link to the TCJ web site
Call or write for a trial subscription.

Send email to Greg Lisle (L.G.Lisle@iee.org or
lglisle@aol.com) for information about his PygTools
shareware utilities/libraries for Pygmy.


                    **** The End ****
