Date:  05-Sep-92 03:47 EDTFrom:  Michael Hore [100033,3164]Subj:  Graphwin.mops \ Preliminary Mops version of Brian Dunn's proposed graphics and windows \ mini standard. \ Mops version by Mike Hore \ GEnie email: M.HORE \ Last modified:  Aug 30, 1992 \ Text windows and color not implemented yet.\		======================================\				Mops prologue\		======================================\ On the Mac, we work out the screen dimensions dynamically:: screen_width	screenbits  ( 0 0 w h )  drop nip nip  ;: screen_height	screenbits  ( 0 0 w h )  nip nip nip  ;: DEFER	['] null  vect  ;: DEFERUSER	['] null  vect  ;: USER	variable  ;: TOK		'    ;: [TOK]	postpone [']  ;		immediate: ['USER]	postpone [']  postpone 4+  ;		immediate: IS		postpone ->   ;		immediate: [ISUSER]	postpone ->   ;		immediate: TO		postpone ->   ;		immediate: LITERAL		hide  literal  ;	immediate	\ TEMP bug fix!: WITHIN?		hide  within? nip  ;' ?terminal	vect	KEY?: EKEY>CHAR		( n -- char true   or   ekey false )	0 $ FF  within?  ;: OFF		false swap !  ;: ON		true  swap !  ;:code  WAIT		\ ( n -- )  Wait for n ticks	pop.l	a0	call	delay;code: 16/		4 >>  ;:class  LONGWORDLIST  super{ string  sequence }:m  ADD:		\ ( ptr -- )	pad !  pad 4  add: super  ;m:m  FIRST?:	size: super  nif  false  exit  then   \ No elements - return false	reset: super  ^1st: super @  true  ;m:m  NEXT?:	\ ( -- ptr T  |  -- F )	4 skip: super  len: super  nif  false  exit  then	^1st: super  @  true  ;m;class \ The defaullst window update routine simply clears the window. \ The key and mouse routines ignore the keypress and mousepress.: default_update	\ the drawing window has already been set to the event window	cls	;: default_keys	\ take no action	;: default_mouse	\ take no action	;\ Mops already has a class called Window, so we define a subclass\ GWINDOW to implement the operations we need for GraphWin, then define\ a subclass called, strangely enough, WINDOW.:class  GWINDOW  super{  window  }	x-addr	KeyHndlr	int		X	int		Y	int		WIDTH	int		HEIGHT  40	bytes		TITLE:m KEY:	key: super  exec: keyHndlr  ;m:m SETKEY:	put: keyHndlr  ;m:m PUTXYWH:	put: height  put: width  put: y  put: x  ;m:m GETXYWH:	get: x  get: y  get: width  get: height  ;m:m PUTTITLE:  ( addr len -- )   addr: title  place  ;m:m GETTITLE:  ( -- addr len )	  addr: title  count  ;m:m SETMOUSE:	put: content  ;m:m ENABLE:		\ Same as enable: in window class, but doesn't set: self.	get: growFlg  if  @xy  ^base  call DrawGrowIcon  gotoxy  then	exec: enact  ;m:m CLASSINIT:		\ Sets up the default values, taken from init_window				\ in Brian's implementation.	classinit: super	10 40  200 200  putxywh: self	10							\ default to top left	40							\ avoid menu bar	screen_width   100 -				\ default nearly full screen	screen_height  100 -	putXYWH: self	" Title"  putTitle: self			\ default title	[tok] default_update	setDraw: self	\ default handlers	[tok] default_keys	setKey: self	[tok] default_mouse	setMouse: self  ;m;class\ Class Window is defined as a subclass of gwindow.:class  WINDOW  super{ gwindow };class\		====================================== \ For revectoring i/o with text windows, START_WINDOWS sets the following to \ the current actions of key etc then key etc are vectored to window_key etc. \ END_WINDOWS returns key etc to their initial actions.defer text_key?		( -- flag )defer text_key		( -- character )defer text_ekey?		( -- flag )defer text_ekey		( -- extended_character )defer text_emit?		( -- flag )defer text_emit		( character -- )defer text_type		( address length -- )defer text_expect		( address length -- )defer text_at-xy		( column# row# -- )defer text_page		( -- ) \ The following convert between user coordinates and pixel coordinates and \ back, from user angles to system angles, and from user colors to system \ colors.  They are used in the high level interface words to convert the \ user coordinates, angles and colors into system coordinates and colors \ before making system calls. \ DEFEZUSER is a defer which may be different for each task.  Each task \ may use its own conversion routines.  If your system does not have DEFERUSER \ you may use: \	user (>pixels) \	: >pixels  (>pixels) @  execute  ;deferuser >pixels		( <user coordinates>  --  pixel_x  pixel_y )deferuser pixels>		( pixel_x  pixel_y  --  <user coordinates> )deferuser angle			(  user_angle  --  system_angle )deferuser drawing_color		( <user color numbers> -- )	\ DRAWING_COLOR takes whatever numbers you use to define your colors	\ and sets 'color to some system value for later use when drawing. \ Each task may be using a different drawing color.  If other drawing modes \ are added later, such as fill pattern or line width, these must also be \ user variables, or each task may have its own system graphical context if \ such is provided by the operating system.user 'color	\ On the ST, this is a 9 level greyscale using pattern fills. \ Some low level functions: \ SCALEPOINT and UNSCALEPOINT convert between Atari ST resolution specific \ coordinates and a generic 640X400 ST display.  This allows the routines to \ work in any ST graphics mode.  The system calls use rez specific values. \ SCALEPOINT  ( generic_x  generic_y  --  rezmode_x  rezmode_y ) \ UNSCALEPOINT  ( rezmode_x  rezmode_y  --  generic_x  generic_y ) \ SCALERECT and UNSCALERECT do the same with two sets of points. \ : +point  ( a b  c d  --  a+c  b+d  )	\ implemented as below, with +: +point  ( a b  c d  --  a+c  b+d  )	>r					\ s: a b c	swap  >r				\ s: a c	+					\ s: a+c	r> r>  +				\ s: a+c  b+d	;: -point  ( a b  c d  --  a-c  b-d  )	>r					\ s: a b c	swap  >r				\ s: a c	-					\ s: a-c	r> r>  -				\ s: a-c  b-d	;\ In Mops, all the initializing is already done.: <init_windows>	; \ Given the operating system's window id, return the x,y \ coordinates of the top left corner of the window's display area. \ These are pixel distances from the top left corner of the screen. \ This is the area in which things may be drawn, rather than the \ entire area the window takes on the screen, some of which is used \ for borders and size boxes and titles.\ The Mac's graphics primitives are already window relative.: <window_workarea>  ( id -- x y )  drop  0 0 ; \ Given the position where the window should appear on the screen, and given \ the width and height you wish the WORKAREA of the window to be, create \ the window and return the system's window id.  The window is not yet \ opened.  These are pixel coordinates.\ For Mops, we use an ObjPtr to the window.ObjPtr	TheWIND  class_is  windowlongwordList	WINDOW_PTRS: <check_window>  { wptr --  b }	\ Returns TRUE if ptr points to one of our window						\ objects.	BEGIN		each: window_ptrs	WHILE		wptr = IF  uneach: window_ptrs  true  EXIT  THEN	REPEAT	false  ;\ <create_window> is the low level routine to fire up a window.  We assume\ the window object's address is already in theWind.: <create_window>  { x y width height \ s255 -- sys_window_id }	x  y  x width +  y height +  put: tempRect	screenbits true setGrow: theWind	tempRect				\ bounds rectangle	getTitle: theWind	docWind				\ it's a normal document window	false					\ initially invisible	true					\ has close box	new: theWind	theWind	;\ <<wsetup>> and <<wwindup>> are the Mops routines to setup for window\ operations and windup, respectively.\ <<wsetup>> takes the window obj addr (the sys_window_id) and sets up the\ objPtr theWind pointing to the window.\ <<wwindup>> doesn't do anything, but may in the future.\ Using <<wsetup>> and <<wwindup>> gives a lot of flexibility -- we could\ modify things to have windows on the heap, for example.: <<wsetup>>  ( sys_window_id -- )	-> theWind  ;: <<wwindup>>  ; \ Move the window to the desired pixel position and resize it so that the \ workarea is of the desired width and height.: <move_window>  { x y  width height  sys_window_id -- }	sys_window_id  <<wsetup>>	x y  move: theWind	width height	20 40  +point  size: theWind	<<wwindup>>  ;: <top_window>  ( sys_window_id -- )	<<wsetup>>  select: theWind  <<wwindup>>  ;: <open_window>  { x y width height sys_window_id -- }	\ Make the window visible.	\ Parameters as <MOVE_WINDOW>.	x y width height sys_window_id  <move_window>	sys_window_id  <<wsetup>>	show: theWind  <<wwindup>>  ;: <close_window>  ( sys_window_id -- )	\ Make the window hidden.	<<wsetup>>  hide: theWind  <<wwindup>>  ;: <delete_window>  ( sys_window_id -- )	\ Remove the window from the system.  Opposite of <create_window>.	<<wsetup>>  close: theWind  <<wwindup>>  ;: <title_window>  { title$ sys_window_id -- }	\ Set the title of the window to the supplied counted string.	\ Assumes there is a count byte at address TITLE$.	sys_window_id <<wsetup>>	title$ count  title: theWind	<<wwindup>>  ; \ Given pixel coordinates anywhere on the screen, return the system \ window id of the window which holds that pixel, or 0 if none.: <find_window>  { pixel_x  pixel_y \ wptr --  system_window_id | 0 }	pixel_x  pixel_y  pack find-window  -> wptr	( indicator )  1 <=		\ desktop or menu bar?	IF  0  EXIT  THEN	wptr <check_window>  NIF  0  EXIT  THEN	wptr			\ this is the sys id for window	; \ Return the current screen pixel position of the mouse pointer.\ NOTE: -- the Mac GetMouse gives window-relative\ coordinates!variable	ThePoint: <mouse_xy>  ( -- pixel_x  pixel_y )	thePoint  call GetMouse	thePoint @  l->g  unpack  ; \ Return the button state of the mouse as a bitmask where 1 means button \ is pressed.  Bit 0 is the leftmost button.\ The Mac, of course, has only one button!: <mouse_buttons>  ( -- bitmask )\	0  call Button  0<>  1 andf	0  call Button  0<>  1 and	; \ Show and hide the mouse pointer while drawing things.  If your system \ protects the mouse cursor while doing graphics primatives, you may make \ these into null operations.: <hide_mouse>	call HideCursor	;: <show_mouse>	call ShowCursor	;: <mode>	\ Sets the pen mode to "clear" if we're erasing	'color @ if  konst patBic  makeint  call PenMode  then  ;: <norm>	call PenNormal  ;	 \ Draw a thin line of the color set by SET_LINE_COLOR between \ the given scrfeen pixel endpoints.  Any clipping rectangle set by \ SET_CLIPPING is observed.  If your operating system does graphic operations \ inside windows automatically, the parameters are pixel offsets inside the \ window.: <draw_line>  ( pixel_x1 y1  x2 y2  -- )	<mode>	pack >r	pack  call MoveTo	r>    call LineTo	<norm>  ; \ Given screen pixel center x,y and pixel radius x,y and angle start,end \ shuffle things for system call with resolution scaled pixel coordinates.\ The Mac defines arcs in terms of an enclosing rectangle, so <<arc>>\ has to convert the parameters.  Three cheers for locals!!: <<arc>>  { cx cy  rx ry  start end  -- tempRect start:end }	cx rx -   cy ry -  cx rx +  cy ry +  put: tempRect	tempRect start  end start -  pack	<mode>  ;: <draw_arc>  ( pixel_x  py  radius_x  ry  start_angle  end  -- )	<<arc>>	call FrameArc		\ Draw an arcing line.	<norm>  ;: <draw_filled_arc>  ( pixel_x py  radius_x ry   start end  -- )			\ Draw a filled arcing pie segment.	<<arc>>  'color @ if  call EraseArc  else  call PaintArc  then	; \ Draw a color filled rectangle given the pixel screen coordinates. \ x1,y1 is the upper left corner, and x2,y2 is the lower right, inclusive.: <draw_filled_rect>  ( pixel_x1 y1  x2 y2  -- )	put: tempRect  1 1 stretch: tempRect	\ Mac doesn't include these								\  pixels normally	'color @ if  clear: tempRect  else  paint: tempRect  then	; \ Draw the text string at the given pixel screen p aosition. \ x,y is the top left corner of the first character draw.: <draw_text>  ( addr len  x y  -- )	( x y )  pack  call MoveTo	0 swap  pack  ( addr 0:len )	call DrawText	;\ We haven't implemented the color stuff in Mops yet, so the following\ words are dummies:: <set_line_color>	;: <set_text_color>	;: <set_fill_color>	; \ Each task may draw to and take i/o from any window. \ If either contains 0 then the full screen or the boot window is assumed.user 'drawing_window		\ window_id which task is drawing touser 'i/o_window			\ window_id which task is using for key, etc \ At any time, one window is on top.  This window is what will receive \ key and mouse events, even though several windows might be waiting for \ them.variable 'top_window		\ id of the window to take keys/mousedefer <perform_infrequent_events>		\ for forward referencevariable '#windows			\ Holds the current # of windows. \ A graph context has the current settings for fill/text/line colors and \ modes, as well as the current drawing window. \ Anything which isn't stored in the graph context might be changed between \ PAUSE or redraws.  Using system calls such as setting fill patterns might \ not apply after a PAUSE. \ The context is saved and restored when an event handler routine is called. \ A small LIFO stack is used to hold contexts during updates and the like.:class  graph_context_struct  super{ object }	var	gc_drawing_window		\ the current drawing window	var	gc_i/o_window		\ the current i/o window	var	gc_color			\ ST: greyscale value for GREYSCALE:m get:  ( -- wind i/o_wind color )			get: gc_drawing_window			get: gc_i/o_window			get: gc_color  ;m:m put:  ( wind i/o_wind color -- )			put: gc_color			put: gc_i/o_window			put: gc_drawing_window  ;m;class:class gc_array  super{  graph_context_struct  obj_array  };class4 gc_array  'gc_stack			\ A small stack for graph contexts.						\ max depth of 4variable 'gc_depth			\ index of the top of the gc stack						\ holds -1 when stack is empty: set_gc_stack  ( -- )			\ addr of the top of the gc stack	'gc_depth @				\ index of the depth of the stack	select: 'gc_stack			\ make indexed element current	;: save_graph_context	1  'gc_depth  +!  set_gc_stack	'drawing_window @  'i/o_window @  'color @  put: 'gc_stack	;: restore_graph_context	get: 'gc_stack  'color !  'i/o_window !  'drawing_window !	-1  'gc_depth	\ mth  +!  set_gc_stack	;\ >id and id> convert between window addresses and window ids.\ In Mops, absolute addresses are used as ids, so no conversion is\ necessary.: >id  ( 'window -- window_id )		\ convert window address to id	;: id>  ( window_id -- 'window )		\ convert window id to address	; \ We disable ADDED_WINDOW, which in Brian's implementation makes sure that the \ given id is of a window which has been added with ADD_WINDOW.  We do this \ since if we attempt to send a message to an invalid Mops window address we'll \ get a "not an object" error.: added_window  ( window_id -- )	\ Be sure this window has been added.	drop  ; \ DRAWING_WINDOW and I/O_WINDOW redirect graphics or i/o to a window. \ 0 is a valid id meaning the boot screen or window.: drawing_window  ( window_id -- )	\ redirect graphics to this window	dup 'drawing_window  !		\ set the window id to use in future	<<wsetup>>  set: theWind  <<wwindup>>	;: i/o_window  ( window_id -- )	\ which window to use for key/emit	'i/o_window  !	;8   constant text_width			\ in pixels16  constant text_height		\ in pixels \ PIXEL_SPACE is one of the default coordinate systems. \ PIXELS>PIXELS is used to convert both PIXELS> and >PIXELS.: (>pixels)  ( user_x  user_y  --  pixel_x  pixel_y )	;: (pixels>)  ( pixel_x  pixel_y  --  user_x  user_y )	;: pixel_space	['] (>pixels)		[isuser] >pixels	[tok] (pixels>)		[isuser] pixels>	;	\ [isuser] sets the action of a deferuser word. \ 16K_SPACE is another coordinate space. \ The screen is assumed to be slightly over 16K wide and as tall as is \ needed to make virtual user pixels square. \ The actual width is enough over 16384 to make conversion to pixels have \ no remainder.  If your screen has square physical pixels then the vertical \ conversion will also have no remainder. \ 16K_SPACE is meant to be used when you wish the display to look similar in \ size and proportion on everyone's screen.  Workstation and full page \ displays might allow a larger coordinate system with 16K_SPACE to keep \ approximate size the same as typical personal computer screens.  On such a \ system there would be unused areas of the screen when run with programs \ assuming a smaller personal computer screen.16 1024 *  constant  16K: 16Kscreen_width		16K screen_width mod negate  screen_width +  16K +  ;: 16Kscreen_height	16Kscreen_width  screen_height  screen_width  */  ;: 16K>pixels  ( 16K_x  16K_y  --  pixel_x  pixel_y )	screen_height  [ 16K  screen_height  screen_width  */ ] literal  */	swap	screen_width  16K  */	swap	;: pixels>16K  ( pixel_x  pixel_y  --  16K_x  16K_y )	[ 16K  screen_height  screen_width  */ ] literal  screen_height  */	swap	16K  screen_width  */	swap	;: 16K_space	[tok] 16K>pixels	[isuser] >pixels	[tok] pixels>16K	[isuser] pixels>	; \ DEGREE_ANGLES sets the action of ANGLE to convert a number from 0 to 360 \ into system angles for use by the arc related system calls. \ 0 is directly right, 90 is directly up, 180 is left, 270 is down.: <angle>  ( user_angle -- system_angle )	[ 360 90 + ] literal  swap -	\ Mac angles go clockwise	;: degree_angles		\ Set to use degrees for angle conversions.	[tok] <angle>	[isuser] angle	; \ LOOKUP_WINDOW, on Brian's system, is given the system window id and returns  \ forth's window id.  On Mops, the two id's are the same.: lookup_window  ( sys_id -- window_id )	;\ The Mac, thankfully, has an intelligent clipping scheme!: set_clipping  ( -- )		\ set the clipping rectangle to redraw area	;: do_window_rectangles  ( #parameters action id -- ) 	drop					\ s: a b c .. d  #parameters action 	>r  drop  r>			\ s: a b c .. d  action 	execute	; \ +WINDOW is used to convert to window relative coordinates by adding the \ coordinate of the top left corner of the workarea of the window.\ The Mac is always window-relative, so no conversion is needed.: +window  ( pixelx y -- pixelx' y' : add corner of window )	; \ DRAW_xx are user level words which take user space coordinates and \ convert to pixel coordinates, set colors, then call DO_WINDOW_RECTANGLES \ to set the clipping for the visible areas of the window and call the \ primative to do the actual drawing in each visible area of the window.: draw_line  ( x1 y1  x2 y2  -- )	>r  >r	>pixels  +window		\ convert x1,y1 to pixels + window	r>  r>	>pixels  +window		\ convert x2,y2	<set_line_color>		\ set the line drawing color depending					\ on contents of user variable 'COLOR	4				\ 4 parameters: x1, y1, x2, y2	[tok] <draw_line>		\ the action to perform w/ the params	'drawing_window @		\ the window id to use for the action	do_window_rectangles	\ clip and draw	;: draw_point  ( x y -- )	2dup	draw_line	;: draw_filled_rect  ( x1 y1  x2 y2  -- )	>r  >r	>pixels  +window	r>  r>	>pixels  +window\	<set_fill_color>x	<set_fill_color>	4	[tok] <draw_filled_rect>	'drawing_window @	do_window_rectangles	; \ Given user coordinates for center x,y and radius x,y and start/end angles \ return pixel coordinates and system angles.: <<draw_arc>>  { cx cy  rx ry  start end  --  cx' cy'  rx' ry'  start end }	cx cy  >pixels			\ convert to pixels	+window				\ offset of the window	rx ry  >pixels			\ convert radiuses to pixels	start angle   end angle		\ the start/end angles to use	;: draw_arc  ( center_x center_yx  radius_x  radius_y  start  end  -- )	<<draw_arc>>			\ convert everything to pixels	<set_line_color>	6	[tok] <draw_arc>	'drawing_window @	do_window_rectangles	;: draw_oval  ( center_x center_y  radius_x  radius_y  -- )	0  360				\ use full oval	draw_arc	;: draw_circle  ( x y  radius  -- )	dup				\ same radius for x and y	draw_oval	;: draw_filled_arc  ( center_x center_y  radius_x radius_y  start end  -- )	<<draw_arc>>	<set_fill_color>	6\	[tok] <drxaw_filled_arc>	[tok] <draw_filled_arc>	'drawing_window @	do_window_rectangles	;: draw_filled_oval  ( center_x center_y  radius_x radius_y  -- )	0  360	draw_filled_arc	;: draw_filled_circle  ( x y radius -- )	dup	draw_filled_oval	;: draw_text  ( addr len  x y  -- )	>pixels  +window	<set_text_color>	4	[tok] <draw_text>	'drawing_window @	do_window_rectangles	;: rgb_drawing_color  ( red green blue -- )	\ each from 0-255	+ +					\ s: 0 to 765	9  766  */	'color  !\	;rx	;: rgb_colors	\ set the action of drawing_color	[tok] rgb_drawing_color		[isuser] drawing_color	; \ FOREGROUND_COLOR and BACKGROUND_COLOR are used to specify fore/background \ colors without having to know what they are in the user coordinate space.: foreground_color	0  'color !	;: background_color	8  'color !	; \ The following erase the drawing or i/o windows using high level routines.: erase_drawing_window	background_color	0 0  pixels>	screen_width  screen_height  pixels>	draw_filled_rect	;: erase_i/o_window	'drawing_window @	'i/o_window @  'drawing_window !	erase_drawing_window	'drawing_window  !	; \ If using dynamically allocated windows, some of the actions of TEXT_WINDOW \ should be factored out into an INIT_TEXT_WINDOW. \ A normal window requires WINDOW_STRUCT bytes for its record. \ A text window requires TEXT_WINDOW_STRUCT bytes plus additional bytes \   #rows  #columns *    for text storage. \ ID> and >ID eeshould be adjusted to use a lookup table for the dynamically \ allocated windows, along with some method for maintaining the table \ such as ALLOCATE_WINDOW and DEALLOCATE_WINDOW, between which you may \ add and delete windows from the operating system.: init_window  { 'window -- }		\ No action needed since it's handled						\ by CLASSINIT:	; \ TITLE_WINDOW is given the address of a counted string. \ A byte holding the # of characters is stored at that address, and \ the characters to use follow immediatly after. \ There is no check to see if the window has been added.: title_window  { title$  window_id \ 'window -- }	\ Give a window a title.	window_id id>  to 'window				\ window address	'window  <<wsetup>>	title$ count  putTitle: theWind	title$ 'window <title_window>	<<wwindup>>	;: add_window  { window_id -- }				\ Tell the operating system about this window.	window_id  <<wsetup>>	getxywh: theWind					\ Position and size								\ in screen pixels.	<create_window>  drop				\ op system call	\ record this window's pointer in the window pointer list:	window_id  add: window_ptrs	1  '#windows  +!	;: updates_window  ( xtoken  window_id -- )	\ Tell what updates a window.	id>  <<wsetup>>  setDraw: theWind  <<wwindup>>	;: takes_window_keys  ( xtoken  window_id  -- )	\ Tell what handles keypresses.	id>  <<wsetup>>  setKey: theWind  <<wwindup>>	;: takes_window_mouse  ( xtoken  window_id  -- )	\ Tell what handles mouse.	id>  <<wsetup>>  setMouse: theWind  <<wwindup>>	;: window_size  { window_id -- width height } \ Return size of a window.	window_id  added_window			\ error checking	\ s: window_id	<<wsetup>>	getXYWH: theWind	>r >r 2drop r> r>				\ s: width  height  in pixels	pixels>					\ convert to user coordinates	<<wwindup>>	;: move_window  { x y width height  window_id \ 'window -- }	\ Move/resize window.	window_id  added_window	window_id  id>  to 'window	'window  <<wsetup>>	x y  >pixels	width height  >pixels	putXYWH: theWind	<<wwindup>>	\ Tell the operating system to move and resize the window:	x y  >pixels	width  height  >pixels	'window				\ the window's system id	<move_window>	;: size_window  { width height  window_id | 'window -- }	\ Resize a window.	window_id  added_window	window_id  id>  to 'window	'window  <<wsetup>>	getXYWH: theWind  2drop		\ use the current position	width					\ use the new size	height				\ already in user space	window_id	move_window			\ takes user space coordinates	;: top_window  ( window_id -- )	\ Move the window to the top.	dup  added_window	dup  'top_window  !		\ this window will now be on top	id>					\ the window's system id	<top_window>			\ operating system call	;: open_window  { window_id \ 'window l t r b -- } \ Make a window visible and on top.	window_id  added_window	window_id  id>  to 'window	'window <<wsetup>>	getxywh: theWind			\ the last supplied position/size	'window	<open_window>			\ make the window visible	window_id  top_window		\ move the window to the top	<<wwindup>>	;: close_window  ( window_id -- )	\ Make a window invisible.	dup  added_window	id>	<close_window>	;: delete_window  { window_id \ 'window -- }	\ Remove window from the op system.	window_id  added_window	window_id id>  to 'window	'window	<delete_window>			\ Have the op sys remove the window.	;: update_window  ( id -- )		\ call update handler	<<wsetup>>	update: theWind			\ In Mops, this forces it to be called	<<wwindup>>	; \ On systems where checking for events might take a significant amount of \ time, it is slow to check every time a character is printed. \ In the WINDOW_KEY etc. words, PERFORM_INFREQUENT_EVENTS is called to \ allow event handling without slowing down printing too much.variable 'last_infrequent_event		\ time when last did an event60	constant	1SECOND	\ 60 ticks = 1 sec. on the Mac. 0	value		MODIFIERS	\ Modifiers for last key event: do1event						\ Process 1 event	next: fEvent	IF		\ It's a key event		-> modifiers		actW  IF key: actW  ELSE  drop  THEN	THEN  ;: perform_events	do1event	;: perform_infrequent_events		\ only 16 times per second	global Ticks @			\ current time in 1/60ths of a sec.	'last_infrequent_event @  -	\ subtract previous time	1second 4 >>  >  if		\ enough time has passed		global Ticks @			\ current time		'last_infrequent_event  !	\ set the prev time\		doier1event		\ do an event		do1event		\ do an event	else				\ not enough time has passed		pause			\ just pause	then	;tok perform_infrequent_events	is <perform_infrequent_events>: reset_vars			\ initialize some global and user variables	0  'top_window  !			\ no top window	0  'drawing_window  !			\ draw to raw screen	0  'i/o_window  !			\ i/o to textmode	0  '#windows !				\ no windows added so far	-1  'gc_depth  !			\ reset graph context stack	;false	value	WINDOWS_STARTED?: start_windows			\ Ready for window/graphics activity.	\ check to see if windows are already started:	windows_started?  if	\ already started		exit	then	<init_windows>			\ operating system initialize	reset_vars				\ initialize things	pixel_space				\ default to pixel space	degree_angles			\ default to degrees	rgb_colors				\ default to RGB colors	$ F5FF  set: fEvent		\ get mouse-up as well as mouse-down	['] mouse-evt  2 to: fEvent	\ and install handler for mouse-up	0 -> sleepticks			\ we seem to need this for good response	true -> windows_started?	;: end_windows				\ Stop window/graphics activity.	\ check to see if already ended:	windows_started?  not if	\ already started		exit	then	\ delete all the windows	begin		each: window_ptrs	while		delete_window	repeat	$ F5EF  set: fEvent		\ cancel mouse-up events	['] null-evt  2 to: fEvent	20 -> sleepticks			\ restore default sleepticks	release: window_ptrs  ;\ LOCMOUSE is a utility routine to return the current mouse coordinates\ relative to the active Mops window actW.  If no active Mops window,\ returns global coordinates.: locMouse  { \ x y -- x y }	<mouse_xy>  -> y  -> x	actW	IF		actW  set: window		x y pack  g->l  unpack	ELSE		x y	THEN	;\ User level words for fetching the current event in user handlers:: event_id  ( -- window_id )	where: fEvent  find-window	;: event_time  ( -- time )	when: fEvent	;: event_ekey  ( -- ekey )	msg: fEvent	;: event_x  ( -- mouse_x )		\ in virtual coordinates	locMouse  pixels>  drop	;: event_y  ( -- mouse_y )	locMouse  pixels>  nip	;: event_buttons  ( -- mouse_button_bitmask )	<mouse_buttons>	; \ MOUSE_XY returns the current mouse cursor position inside a window, and \ the window which the mouse is currently pointing inside.  If the mouse \ is not in any window, MOUSE_XY returns id of 0 and the current screen \ position.: mouse_xy  { \ x y id l t r b -- x y window_id }			\ Return current mouse posn & window.			\ if mouse is not in any window, return screen x,y and id of 0	<mouse_xy>				\ operating system call	to y  to x				\ screen pixel position	x y	<find_window>				\ s: sys-id  or  0	?dup if					\ s: sys-id		lookup_window			\ s: id or 0		?dup  if			\ s: id			to id			id <<wsetup>>			set: theWind			x y			\ mouse x,y  in screen pixels			pack g->l unpack	\ Make relative to window			pixels>		\ convert to user space			id			\ also return window id			<<wwindup>>		else				\ isn't a known window			x y  pixels>	\ screen posn in user coords			0			\ no window id		then	else					\ isn't in any window		x y  pixels>		0	then	;: mouse_buttons  ( -- buttons )		\ Return current mouse button state.	<mouse_buttons>	; \ The following test programs exercise almost every aspect of the graphics \ mini-standard.: test	start_windows	0 i/o_window	16K_space	16Kscreen_height 0 do		16K 0 do			i  256  16K  */			j  256  16K  */  dup  drawing_color			i 512 +  j 512 +  512  draw_filled_circle		1024 +loop		key? if  leave  then	1024 +loop	key  drop	end_windows	;window mywindowwindow mywindow2variable 'quit?variable 'last_xvariable 'last_yvariable 'drawing?: do_keys	event_ekey  $ ff and	9 =  'quit? !			\ quit when TAB is pressed	;: do_mouse	event_buttons  0<>  if		\ button has just been pressed down		event_x  'last_x !	\ start drawing at the mouse position		event_y  'last_y !		'drawing?  on	else					\ button has been released		'drawing?  off	then	;: my_update2	background_color	0 0  16K 16K  draw_filled_rect	foreground_color	1000 1000  4000 2000  draw_filled_rect	2000 4000  2000  draw_circle	5000 4000  1000  draw_filled_circle	10000 4000 1000 2000  0 60  draw_filled_arc	\ To test event_bound1 & 2: \	0  i/o_window \	0 0 at-xy \	." Upper left: "  event_bound1  swap . .  cr \	." Lower right: "  event_bound2  swap . .  cr	;: draw_mouse_trail  { \ x y -- }	mouse_xy					\ s: x y window_id	mywindow =  if				\ s: x y  ( in window? )		to y  to x		mywindow  drawing_window		foreground_color		'last_x @		'last_y  @	\ x1 y1		x			y		\ x2 y2		draw_line		x			'last_x !		y			'last_y !	else						\ s: x y		2drop	then	;: draw_random_rectangle	mywindow2  drawing_window	128 128 128  drawing_color	16K random  16K random	2dup  500 500 +point  draw_filled_rect	;variable 'last_time		\ last time displayed\ se: draw_timer\	global ticks @  'last_time @  -  abs  1second 4/ >  if\		\ every quarter second or more:\		global ticks @  'last_time !	\ wait for a new time\		mywindow  i/o_window\		6 0  at-xy\		global ticks @  .\	then	;: init_test2	start_windows	16K_space	[tok] do_keys  mywindow2  takes_window_keys	[tok] do_mouse  mywindow  takes_window_mouse	[tok] my_update2  mywindow2  updates_window	mywindow  add_window	mywindow2  add_window	" Mouse Draw"	str255  mywindow	title_window	" Shapes"		str255  mywindow2	title_window	100 1500		7000 8000  mywindow   move_window	8300 1500		7000 8000  mywindow2  move_window	mywindow2  open_window	mywindow   open_window	'quit? off	'drawing? off	global ticks @  'last_time  !	;: test2	init_test2	mywindow  i/o_window\	0 0  at-xy\	." Time: "	0  i/o_window	begin		perform_events		'drawing? @  if			\ mouse button is down?			draw_mouse_trail		else			draw_random_rectangle\		thense		then		draw_timer	'quit? @  until	0  i/o_window	mywindow  close_window	mywindow2  close_window	mywindow  delete_window	mywindow2  delete_window	end_windows	;                                                                                                          