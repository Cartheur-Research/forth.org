{\rtf1\mac\deff2 {\fonttbl{\f0\fswiss Chicago;}{\f2\froman New York;}{\f3\fswiss Geneva;}{\f4\fmodern Monaco;}{\f6\fdecor London;}{\f11\fnil Cairo;}{\f13\fnil Zapf Dingbats;}{\f14\fnil Bookman;}{\f15\fnil N Helvetica Narrow;}{\f16\fnil Palatino;}{\f18\fnil Zapf Chancery;}{\f20\froman Times;}{\f21\fswiss Helvetica;}{\f22\fmodern Courier;}{\f23\ftech Symbol;}{\f33\fnil Avant Garde;}{\f34\fnil New Century Schlbk;}{\f128\fnil Boston IIx;}{\f192\fnil Mangia;}{\f220\fnil MiniBoston IIx;}{\f221\fnil MicroBoston IIx;}{\f222\fnil Line & Lead;}{\f1024\fnil American Heritage;}{\f1025\fnil ClosedCaption2;}{\f1026\fnil XPGildedCD-IN;}{\f1133\fnil Century Cond;}{\f1148\fnil XPCompacta;}{\f1202\fnil XPOxfordText-Normal;}{\f1238\fnil XPCopperhead;}{\f1269\fnil Futena;}{\f1397\fnil XPCabotOpen;}{\f1639\fnil XPRadial;}{\f1792\fnil Lucida Bright;}{\f2000\fnil Garamond Narrow;}{\f2007\fnil Delphian;}{\f2017\fnil Lubalin Graph;}{\f2024\fnil Machine;}{\f2029\fnil Nadianne;}{\f2036\fnil Old English Text;}{\f2038\fnil Onyx;}{\f2040\fnil Oxford;}{\f2046\fnil Swing;}{\f2052\fnil Zeal;}{\f2091\fnil Cursive-Elegant;}{\f2096\fnil XPKaleph-Bold;}{\f2121\fnil Garamond;}{\f2247\fnil XPGildedCD;}{\f2385\fnil XPJasmine;}{\f2429\fnil XPSchooner;}{\f2435\fnil Fruit;}{\f2490\fnil DeltaSymbol;}{\f2503\fnil Technical;}{\f2515\fnil MT Extra;}{\f2686\fnil Caslon;}{\f2689\fnil Trade Condensed;}{\f2799\fnil XPTechno;}{\f2835\fnil XPFortunaCD;}{\f2999\fnil eWorld Tight;}{\f4950\fnil TTYFont;}{\f7715\fnil XPFortuna-XB;}{\f9840\fnil Espy Sans;}{\f9842\fnil Espy Sans Bold;}{\f10840\fnil Klang MT;}{\f10890\fnil Script MT Bold;}{\f10897\fnil Old English Text MT;}{\f10909\fnil New Berolina MT;}{\f10957\fnil Bodoni MT Ultra Bold;}{\f10967\fnil Arial MT Condensed Light;}{\f14811\fnil Helvetica Compressed;}{\f14974\fnil Helvetica Black;}{\f15011\fnil Gill Sans Condensed Bold;}{\f32525\fnil VT100;}}{\colortbl\red0\green0\blue0;\red0\green0\blue255;\red0\green255\blue255;\red0\green255\blue0;\red255\green0\blue255;\red255\green0\blue0;\red255\green255\blue0;\red255\green255\blue255;}{\stylesheet{\s228\li360\keepn\tqdec\tx12960 \i\f20\fs20 \sbasedon0\snext0 toc 6;}{\s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 \sbasedon230\snext0 toc 5;}{\s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 \sbasedon231\snext0 toc 4;}{\s231\fi-360\li360\ri540\sb240\keepn\tqdec\tx4320 \b\f20\fs20 \sbasedon232\snext0 toc 3;}{\s232\fi-360\li360\ri540\tqdec\tldot\tx4320 \f20\fs20 \sbasedon233\snext0 toc 2;}{\s233\fi-360\li360\ri540\sb720\keepn\tqdec\tx4320 \b\f20 \sbasedon0\snext0 toc 1;}{\s243\tqc\tx4320\tqr\tx8640 \f20 \sbasedon0\snext243 footer;}{\s244\brdrb\brsp80\brdrhair \tqc\tx4680\tqr\tx9360 \f20 \sbasedon0\snext244 header;}{\s250\fi-360\li360\phpg\posx20161\dxfrtext180 \f20 \sbasedon251\snext0 heading 6;}{\s251\fi-360\li360\ri5940\sb120\sbys \f20 \sbasedon252\snext0 heading 5;}{\s252\li720\sb120\keepn \f21 \sbasedon253\snext0 heading 4;}{\s253\ri5760\sb360\sa240\keepn\brdrt\brsp240\brdrth \brdrb\brsp120\brdrs \b\f21 \sbasedon254\snext0 heading 3;}{\s254\sb240\keepn \b\f21 \sbasedon255\snext0 heading 2;}{\s255\qc\sb240\keepn \b\f21\fs36 \sbasedon0\snext0 heading 1;}{\f20 \sbasedon222\snext0 Normal;}{\s2\qj\li3600\sb120\sbys \f20 \sbasedon251\snext2 method-description;}{\s3\fi-3240\li3960\tx1800\tx3600 \f20\fs20 \sbasedon4\snext3 ivar-description;}{\s4\tx3600 \f20 \sbasedon0\snext4 other-description;}{\s5\qj\li720\sb120 \f20 \sbasedon4\snext5 error-description;}{\s6\qj\sb120\sa240 \f20 \sbasedon7\snext6 class-description;}{\s7\qj\sb120 \f20 \sbasedon0\snext7 preamble;}{\s8\fi-720\li720 \f20 \sbasedon0\snext8 bullet;}{\s9\fi-2880\li3600\tx3600 \f20 \sbasedon4\snext9 system-object-description;}{\s10\keep\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 \f22\fs18 \sbasedon0\snext10 code-sample;}{\s11\sb120\keepn \b\f21 \sbasedon253\snext11 subhead (non-toc);}{\s12\qj\sb120\keepn \i\f20 \sbasedon5\snext5 error-message;}}{\info{\title Part III-predefined classes}{\*\verscomm Converted by John Robinson}}\margl1080\margr1080\margb1080\facingp\gutter720\widowctrl\ftnbj\fracwidth \sectd \pgnrestart\pgnlcrm\linemod0\linex0\cols1\colsx360\endnhere \pard\plain \qc \f20 {\b\fs96 Mops\par }\pard \qc {\b\i\fs28 Mike's Object-oriented Programming System\par }\pard \qc {\b\fs48 \par Version 2.6\par }\pard \qc\posy3601\dxfrtext180 {\b\fs96 Part III\par }\pard \qc\posy3601\dxfrtext180 {\b\fs48 Predefined Classes\par }\pard\plain \s7\qj\sb120\posyb\dxfrtext180 \f20 Mops is an object-oriented programming system, derived from the Neon language developed by Charles Duff and sold by Kriya, Inc.  Kriya have discontinued support for Neon, and have released all the source code into the public domain, retaining only the ownership of the name Neon.\par \pard \s7\qj\sb120\posyb\dxfrtext180\tx3240 Mops implemented by:\tab Michael Hore\par Able assistance from:\tab Doug Hoffman\par \pard \s7\qj\posyb\dxfrtext180\tx3240 \tab Greg Haverkamp\par \tab Xan Gregg\par \pard \s7\qj\sb120\posyb\dxfrtext180\tx3240 Documentation updated:\tab Version 2.6, June 1995\par Documentation formatted by:\tab Craig Treleaven\par \pard\plain \s11\sb120\keepn \b\f21 \page Printing this document\par \pard\plain \s7\qj\sb120 \f20 This document is in Microsoft Word Version 5.1 format and uses the fonts Times, Courier, and Helvetica, only.  It is formatted using the Laserwriter 7 driver for US Letter paper, portrait orientation, with fractional widths enabled.  If you want to print any other way, you will probably need to repaginate and regenerate the table of contents and table of predefined classes and methods.  See below.\par \pard \s7\qj\sb120 Almost every paragraph in this document is formatted using a Word style.  Formatting is consistent throughout and can be reformatted in moments this way.  \par \pard\plain \s11\sb120\keepn \b\f21 Viewing on-line\par \pard\plain \s7\qj\sb120 \f20 Of course, you can read the whole manual on-screen.  Word\rquote s Find\'c9 command can help to locate items of interest.  One other technique is useful but not well known.  Use the Outline View and click the \ldblquote 3\rdblquote  in the ruler at the top of the screen.  Word will then show the headings down to a list of all the predefined classes.  Clicking the \ldblquote 4\rdblquote  will show the groupings of each classes\rquote  methods (such as \ldblquote accessing\rdblquote ).  In either case, whichever line is at the top of the window in outline view will become the line at the top of the window when you switch back to Normal View.  By scrolling in Outline View, you can quickly find the section of interest and position the window for reading in Normal View.  \par \pard\plain \s11\sb120\keepn \b\f21 Two-sided printing\par \pard\plain \s7\qj\sb120 \f20 As shipped, this document is formattted for 2-sided printing to save paper.  If you haven\rquote t printed two-sided documents with your printer before, you might want to practise with the first few pages before sending the whole thing.  On most printers, you need to use Word\rquote s option to print first the odd numbered pages (in the Print\'c9 dialog), reload the paper and then print the even numbered pages.  \par \pard\plain \s11\sb120\keepn \b\f21 Single-sided printing\par \pard\plain \s7\qj\sb120 \f20 If you don\rquote t want to bother with two-sided printing, use the Document dialog and make the Gutter margin zero.  If you adjust the Left and Right margins so the printable width is still 6.5 inches, the page breaks should stay in the same places.  Blank pages may pop out here and there as all chapters start on an odd-numbered page.  \par \pard\plain \s11\sb120\keepn \b\f21 A4 Paper\par \pard\plain \s7\qj\sb120 \f20 If you select A4 paper in the Page Setup\'c9 dialog, the page breaks will change.  Regenerate the Methods table and the table of contents, as below.  As far as I can tell, the paragraph styles all do the right thing and ajust to the paper width.  Well, all except one:  the header on odd-numbered pages will extend a quarter inch into the margin because the tab stop is at 6.5 inches.  Redefine the Header style to set it to 6.25, if you feel the need.  \par \pard\plain \s11\sb120\keepn \b\f21 Table of Methods and Table of Contents\par \pard\plain \s7\qj\sb120 \f20 The tables at the beginning of this document employ a \lquote trick\rquote  in Word.  Headings for the Table of Contents have Heading 1 and Heading 2 styles.  The sections for the classes have Heading 3 style and groups of meth\-ods have Heading 4 style.  Each method has Heading 5 style.  We use the Table of Contents\'c9 dialog to col\-lect headings from level 1 to level 2 for the TOC.  Use the same command to collect headings from level 3 to 5 for the table of methods.  Word finds the correct table and replaces it with the newly generated table.  \par \pard\plain \qc \f20 {\b\f21\fs36 \sect }\sectd \sbkodd\pgnlcrm\linemod0\linex0\cols2\colsx360\endnhere\titlepg {\headerl \pard\plain \s244\brdrb\brsp80\brdrhair \tqc\tx4680\tqr\tx9360 \f20 III-\chpgn \~Mops Predefined Classes\par }{\headerr \pard\plain \s244\brdrb\brsp80\brdrhair \tqc\tx4680\tqr\tx9360 \f20 \tab \tab Contents\~III-\chpgn \par }{\headerf \pard\plain \s244\qc\tqc\tx4680\tqr\tx9360 \f20 {\b\f21\fs36 \par Contents\par }}\pard\plain \s233\fi-360\li360\ri540\sb720\keepn\tqdec\tx4320 \b\f20 Chapter 1\emdash Basic data structures\tab 1\par \pard\plain \s232\fi-360\li360\ri540\tqdec\tldot\tx4320 \f20\fs20 About this chapter\tab 1\par Recommended reading\tab 1\par Source files\tab 1\par Using the basic data structures\tab 1\par Using Class Object and Bytes\tab 1\par Using the scalar classes\tab 2\par Using the array classes\tab 2\par Using Collections\tab 3\par Using the Dictionary Class\tab 3\par \pard\plain \s233\fi-360\li360\ri540\sb720\keepn\tqdec\tx4320 \b\f20 Chapter 2\emdash Strings\tab 21\par \pard\plain \s232\fi-360\li360\ri540\tqdec\tldot\tx4320 \f20\fs20 About this chapter\tab 21\par Source files\tab 21\par Using strings\tab 21\par Communicating with other objects\tab 22\par \pard\plain \s233\fi-360\li360\ri540\sb720\keepn\tqdec\tx4320 \b\f20 Chapter 3\emdash Files\tab 31\par \pard\plain \s232\fi-360\li360\ri540\tqdec\tldot\tx4320 \f20\fs20 About this chapter\tab 31\par Recommended reading\tab 31\par Source files\tab 31\par Using files\tab 31\par Standard File Package\tab 32\par Hierarchical File System\tab 32\par \pard\plain \s233\fi-360\li360\ri540\sb720\keepn\tqdec\tx4320 \b\f20 Chapter 4\emdash Events\tab 37\par \pard\plain \s232\fi-360\li360\ri540\tqdec\tldot\tx4320 \f20\fs20 About this chapter\tab 37\par Recommended reading\tab 37\par Source files\tab 37\par Using events\tab 37\par Listening to events\tab 38\par Specific event handling\tab 38\par \pard\plain \s233\fi-360\li360\ri540\sb720\keepn\tqdec\tx4320 \b\f20 Chapter 5\emdash Windows\tab 43\par \pard\plain \s232\fi-360\li360\ri540\tqdec\tldot\tx4320 \f20\fs20 About this chapter\tab 43\par Recommended reading\tab 43\par Source files\tab 43\par Using windows\tab 43\par Creating windows\tab 44\par \pard\plain \s233\fi-360\li360\ri540\sb720\keepn\tqdec\tx4320 \b\f20 Chapter 6\emdash Views and Controls\tab 51\par \pard\plain \s232\fi-360\li360\ri540\tqdec\tldot\tx4320 \f20\fs20 About This Chapter\tab 51\par Recommended reading\tab 51\par Source Files\tab 51\par Using Views\tab 51\par Using Controls\tab 51\par Design issues\tab 53\par \pard\plain \s233\fi-360\li360\ri540\sb720\keepn\tqdec\tx4320 \b\f20 Chapter 7\emdash Menus\tab 65\par \pard\plain \s232\fi-360\li360\ri540\tqdec\tldot\tx4320 \f20\fs20 About This Chapter\tab 65\par Recommended Reading\tab 65\par Source Files\tab 65\par Using Menus\tab 65\par \pard\plain \s233\fi-360\li360\ri540\sb720\keepn\tqdec\tx4320 \b\f20 Chapter 8\emdash Graphics\tab 73\par \pard\plain \s232\fi-360\li360\ri540\tqdec\tldot\tx4320 \f20\fs20 About This Chapter\tab 73\par Recommended Reading\tab 73\par Source Files\tab 73\par Using the Graphics Classes\tab 73\par \pard\plain \s233\fi-360\li360\ri540\sb720\keepn\tqdec\tx4320 \b\f20 Chapter 9\emdash Dialogs\tab 77\par \pard\plain \s232\fi-360\li360\ri540\tqdec\tldot\tx4320 \f20\fs20 About This Chapter\tab 77\par Recommended Reading\tab 77\par Source Files\tab 77\par Using Dialogs\tab 77\par \pard\plain \s233\fi-360\li360\ri540\sb720\keepn\tqdec\tx4320 \b\f20 Chapter 10\emdash Floating Point\tab 83\par \pard\plain \s232\fi-360\li360\ri540\tqdec\tldot\tx4320 \f20\fs20 About This Chapter\tab 83\par Recommended Reading\tab 83\par Source Files\tab 83\par \pard \s232\fi-360\li360\ri540\tqdec\tldot\tx4320 Using Floating Point\tab 83\par \pard\plain \f20 \sect \sectd \sbkodd\pgnlcrm\linemod0\linex0\cols2\colsx360\endnhere\titlepg {\headerl \pard\plain \s244\brdrb\brsp80\brdrhair \tqc\tx4680\tqr\tx9360 \f20 III-\chpgn \~Mops Predefined Classes\par }{\headerr \pard\plain \s244\brdrb\brsp80\brdrhair \tqc\tx4680\tqr\tx9360 \f20 \tab \tab Predefined Classes and Methods\~III-\chpgn \par }{\headerf \pard\plain \s255\qc\sb240\keepn \b\f21\fs36 Predefined Classes and Methods\par \pard\plain \f20 \par }\pard\plain \s231\fi-360\li360\ri540\sb240\keepn\tqdec\tx4320 \b\f20\fs20 Object\tab 3\par \pard\plain \s228\li360\keepn\tqdec\tx12960 \i\f20\fs20 Meta\tab 4\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 class:  ( -- addr )\tab 4\par .id  ( -- )\tab 4\par .class  ( -- )\tab 4\par addr:  ( -- addr )\tab 4\par length:  ( -- #bytes )\tab 4\par copyto:  ( ^obj -- )\tab 4\par classinit:  ( -- )\tab 4\par release:  ( -- )\tab 4\par dump:  ( -- addr )\tab 4\par print:  ( -- addr )\tab 4\par \pard\plain \s231\fi-360\li360\ri540\sb240\keepn\tqdec\tx4320 \b\f20\fs20 Longword\tab 4\par \pard\plain \s228\li360\keepn\tqdec\tx12960 \i\f20\fs20 Object\tab 5\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 accessing\tab 5\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 get:  ( -- val )\tab 5\par put:  ( val  -- )\tab 5\par ->:  ( ^longword -- )\tab 5\par clear:  ( -- )\tab 5\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 initialization\tab 5\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 classinit:  ( -- )\tab 5\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 display\tab 5\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 print:  ( -- )\tab 5\par \pard\plain \s231\fi-360\li360\ri540\sb240\keepn\tqdec\tx4320 \b\f20\fs20 Var\tab 5\par \pard\plain \s228\li360\keepn\tqdec\tx12960 \i\f20\fs20 Longword, Object\tab 5\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 accessing\tab 5\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 +:  ( val -- )\tab 5\par -:  ( val -- )\tab 5\par \pard\plain \s231\fi-360\li360\ri540\sb240\keepn\tqdec\tx4320 \b\f20\fs20 Int, Uint\tab 5\par \pard\plain \s228\li360\keepn\tqdec\tx12960 \i\f20\fs20 Object\tab 6\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 accessing\tab 6\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 get:  ( -- val )\tab 6\par put:  ( val  -- )\tab 6\par ->:  ( ^int -- )\tab 6\par clear:  ( -- )\tab 6\par int:  ( -- int )\tab 6\par +:  ( val -- )\tab 6\par -:  ( val -- )\tab 6\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 display\tab 6\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 print:  ( -- )\tab 6\par \pard\plain \s231\fi-360\li360\ri540\sb240\keepn\tqdec\tx4320 \b\f20\fs20 Byte, Ubyte\tab 6\par \pard\plain \s228\li360\keepn\tqdec\tx12960 \i\f20\fs20 Object\tab 6\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 accessing\tab 7\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 get:  ( -- val )\tab 7\par put:  ( val  -- )\tab 7\par ->:  ( ^int -- )\tab 7\par clear:  ( -- )\tab 7\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 display\tab 7\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 print:  ( -- )\tab 7\par \pard\plain \s231\fi-360\li360\ri540\sb240\keepn\tqdec\tx4320 \b\f20\fs20 Bool\tab 7\par \pard\plain \s228\li360\keepn\tqdec\tx12960 \i\f20\fs20 Byte, Object\tab 7\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 accessing\tab 7\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 put:  ( val  -- )\tab 7\par get:  ( -- true | -- false )\tab 7\par set:  ( -- )\tab 7\par clear:  ( -- )\tab 7\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 display\tab 7\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 print:  ( -- )\tab 7\par \pard\plain \s231\fi-360\li360\ri540\sb240\keepn\tqdec\tx4320 \b\f20\fs20 Handle\tab 8\par \pard\plain \s228\li360\keepn\tqdec\tx12960 \i\f20\fs20 Var, Longword, Object\tab 8\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 accessing\tab 8\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 ptr:  ( -- ptr )\tab 8\par nptr:  ( -- ptr )\tab 8\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 manipulation\tab 8\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 clear:  ( -- )\tab 8\par setSize:  ( len -- )\tab 8\par size:  ( -- len )\tab 8\par new:  ( #bytes -- )\tab 8\par release:  ( -- )\tab 8\par lock:  ( -- )\tab 8\par unlock:  ( -- )\tab 8\par locked?:  ( -- b )\tab 8\par getState:  ( -- n )\tab 8\par setState:  ( n -- )\tab 8\par moveHi:  ( -- )\tab 8\par ->:  ( ^handle -- )\tab 9\par \pard\plain \s231\fi-360\li360\ri540\sb240\keepn\tqdec\tx4320 \b\f20\fs20 ObjHandle\tab 9\par \pard\plain \s228\li360\keepn\tqdec\tx12960 \i\f20\fs20 Handle, Var, Longword, Object\tab 9\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 accessing\tab 9\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 obj:  ( -- ^obj )\tab 9\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 manipulation\tab 9\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 newObj:  ( [#elts] ^class -- )\tab 9\par releaseObj:  ( -- )\tab 9\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 display\tab 9\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 print:  ( -- )\tab 9\par dump:  ( -- )\tab 9\par \pard\plain \s231\fi-360\li360\ri540\sb240\keepn\tqdec\tx4320 \b\f20\fs20 Ptr\tab 9\par \pard\plain \s228\li360\keepn\tqdec\tx12960 \i\f20\fs20 Longword, Object\tab 10\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 manipulation\tab 10\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 new:  ( len -- )\tab 10\par release:  ( -- )\tab 10\par clear:  ( -- )\tab 10\par nil?:  ( -- b )\tab 10\par \pard\plain \s231\fi-360\li360\ri540\sb240\keepn\tqdec\tx4320 \b\f20\fs20 DicAddr\tab 10\par \pard\plain \s228\li360\keepn\tqdec\tx12960 \i\f20\fs20 Longword, Object\tab 10\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 access\tab 10\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 get:  ( -- addr )\tab 10\par put:  ( addr -- )\tab 10\par print:  ( -- )\tab 10\par \pard\plain \s231\fi-360\li360\ri540\sb240\keepn\tqdec\tx4320 \b\f20\fs20 X-Addr\tab 11\par \pard\plain \s228\li360\keepn\tqdec\tx12960 \i\f20\fs20 Longword, Object\tab 11\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 access\tab 11\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 exec:  ( -- various )\tab 11\par put:  ( xt -- )\tab 11\par \pard\plain \s231\fi-360\li360\ri540\sb240\keepn\tqdec\tx4320 \b\f20\fs20 Indexed-Obj\tab 11\par \pard\plain \s228\li360\keepn\tqdec\tx12960 \i\f20\fs20 Object\tab 11\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 accessing\tab 11\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 ^elem:  ( index -- addr )\tab 11\par limit:  ( -- maxIndex+1 )\tab 12\par width:  ( -- #bytes )\tab 12\par ixAddr:  ( -- addr )\tab 12\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 manipulation\tab 12\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 clearX:  ( -- )\tab 12\par \pard\plain \s231\fi-360\li360\ri540\sb240\keepn\tqdec\tx4320 \b\f20\fs20 Basic array classes\emdash bArray, wArray, Array\tab 12\par \pard\plain \s228\li360\keepn\tqdec\tx12960 \i\f20\fs20 Indexed-Obj, Object\tab 12\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 accessing\tab 12\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 at:  ( index -- val )\tab 12\par to:  ( val index -- )\tab 12\par +to:  ( increment index -- )\tab 12\par -to:  ( decrement index -- )\tab 12\par fill:  ( val -- )\tab 12\par \pard\plain \s231\fi-360\li360\ri540\sb240\keepn\tqdec\tx4320 \b\f20\fs20 X-Array\tab 12\par \pard\plain \s228\li360\keepn\tqdec\tx12960 \i\f20\fs20 Array, Indexed-Obj, Object\tab 13\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 accessing\tab 13\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 exec:  ( ind -- )\tab 13\par put:  ( xt0 ... xt(N-1)  N  -- )\tab 13\par actions:  ( xt0 ... xt(N-1)  N -- )\tab 13\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 display\tab 13\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 print:  ( -- )\tab 13\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 initialization\tab 13\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 classinit:  ( -- )\tab 13\par \pard\plain \s231\fi-360\li360\ri540\sb240\keepn\tqdec\tx4320 \b\f20\fs20 Obj_array\tab 13\par \pard\plain \s228\li360\keepn\tqdec\tx12960 \i\f20\fs20 Object\tab 13\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 select:  ( index -- )\tab 13\par current:  ( -- index )\tab 13\par \pard\plain \s231\fi-360\li360\ri540\sb240\keepn\tqdec\tx4320 \b\f20\fs20 (Col), Ordered-Col, wordCol, byteCol\tab 14\par \pard\plain \s228\li360\keepn\tqdec\tx12960 \i\f20\fs20 Object\tab 14\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 accessing\tab 14\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 size:  ( -- #elements )\tab 14\par add:  ( val -- )\tab 14\par last:  ( -- val )\tab 14\par remove:  ( ind -- )\tab 14\par clear:  ( -- )\tab 14\par indexOf:  ( val -- ind t OR -- f )\tab 14\par \pard\plain \s231\fi-360\li360\ri540\sb240\keepn\tqdec\tx4320 \b\f20\fs20 X-Col\tab 14\par \pard\plain \s228\li360\keepn\tqdec\tx12960 \i\f20\fs20 (Col), X-Array, Array, Indexed-Obj, Object\tab 15\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 removeXt:  ( xt --  )\tab 15\par print:  ( -- )\tab 15\par \pard\plain \s231\fi-360\li360\ri540\sb240\keepn\tqdec\tx4320 \b\f20\fs20 Sequence\tab 15\par \pard\plain \s228\li360\keepn\tqdec\tx12960 \i\f20\fs20 Object\tab 15\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 each:  ( (varies) -- true  OR  -- false )\tab 15\par uneach:  ( --  )\tab 15\par \pard\plain \s231\fi-360\li360\ri540\sb240\keepn\tqdec\tx4320 \b\f20\fs20 HandleArray\tab 15\par \pard\plain \s228\li360\keepn\tqdec\tx12960 \i\f20\fs20 ObjHandle, Array, Obj-array, Handle, Var, Longword, Indexed-Obj, Object\tab 16\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 accessing\tab 16\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 size:  ( -- size )\tab 16\par setSize:  ( size -- )\tab 16\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 manipulation\tab 16\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 release:  ( --  )\tab 16\par push:  ( handle -- )\tab 16\par top:  ( --  )\tab 16\par drop:  ( --  )\tab 16\par pushNewObj:  ( ^class -- )\tab 16\par clearX:  ( -- )\tab 16\par \pard\plain \s231\fi-360\li360\ri540\sb240\keepn\tqdec\tx4320 \b\f20\fs20 HandleList\tab 16\par \pard\plain \s228\li360\keepn\tqdec\tx12960 \i\f20\fs20 ObjHandle, Sequence, Handle, Var, Longword, Object\tab 17\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 accessing\tab 17\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 select:  ( index -- )\tab 17\par selectLast:  ( -- )\tab 17\par current:  ( -- index )\tab 17\par size:  ( -- size )\tab 17\par setSize:  ( size -- )\tab 17\par first?:  ( -- b )\tab 17\par next?:  ( -- )\tab 17\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 manipulation\tab 17\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 newObj:  ( ^class -- )\tab 17\par releaseObj:  ( -- )\tab 17\par removeObj:  ( --  )\tab 17\par release:  ( -- )\tab 17\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 display\tab 17\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 dumpAll:  ( --  )\tab 17\par printAll:  ( --  )\tab 17\par \pard\plain \s231\fi-360\li360\ri540\sb240\keepn\tqdec\tx4320 \b\f20\fs20 PtrList\tab 17\par \pard\plain \s228\li360\keepn\tqdec\tx12960 \i\f20\fs20 Ptr, Sequence, Longword, Object\tab 18\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 accessing\tab 18\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 select:  ( index -- )\tab 18\par selectLast:  ( -- )\tab 18\par current:  ( -- index )\tab 18\par size:  ( -- size )\tab 18\par first?:  ( -- b )\tab 18\par next?:  ( -- )\tab 18\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 manipulation\tab 18\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 add:  ( ptr -- )\tab 18\par remove:  ( -- )\tab 18\par dumpAll:  ( --  )\tab 18\par printAll:  ( --  )\tab 18\par \pard\plain \s231\fi-360\li360\ri540\sb240\keepn\tqdec\tx4320 \b\f20\fs20 Dic-Mark\tab 18\par \pard\plain \s228\li360\keepn\tqdec\tx12960 \i\f20\fs20 Object\tab 19\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 accessing\tab 19\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 current:  ( -- addr )\tab 19\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 manipulation\tab 19\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 set:  ( addr -- )\tab 19\par setToTop:  ( -- )\tab 19\par next:  ( -- addr )\tab 19\par \pard\plain \s231\fi-360\li360\ri540\sb240\keepn\tqdec\tx4320 \b\f20\fs20 Resource\tab 19\par \pard\plain \s228\li360\keepn\tqdec\tx12960 \i\f20\fs20 Handle, Var, Longword, Object\tab 19\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 accessing\tab 19\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 set:  ( type ID -- )\tab 19\par getNew:  ( -- index )\tab 19\par getXstr:  ( index -- addr length )\tab 19\par \pard\plain \s231\fi-360\li360\ri540\sb240\keepn\tqdec\tx4320 \b\f20\fs20 String\tab 22\par \pard\plain \s228\li360\keepn\tqdec\tx12960 \i\f20\fs20 Handle, Var, Longword, Object\tab 22\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 accessing\tab 22\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 handle:  ( -- handle )\tab 22\par pos:  ( -- n )\tab 22\par >pos: ( n -- )\tab 22\par lim:  ( -- n )\tab 22\par >lim: ( n -- )\tab 22\par len:  ( -- n )\tab 22\par >len: ( n -- )\tab 22\par skip:  ( n -- )\tab 22\par more: ( n -- )\tab 22\par start:  ( -- )\tab 23\par begin:  ( -- )\tab 23\par end:  ( -- )\tab 23\par nolim:  ( -- )\tab 23\par reset:  ( -- )\tab 23\par step:  ( -- )\tab 23\par <step:  ( -- )\tab 23\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 manipulation\tab 23\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 new:  ( -- )\tab 23\par ?new:  ( -- )\tab 23\par size:  ( -- n )\tab 23\par setSize:  ( n -- )\tab 23\par clear:  ( -- )\tab 23\par get:  ( -- addr len )\tab 23\par 1st:  ( -- c )\tab 23\par ^1st:  ( -- addr )\tab 23\par uc:  ( -- addr len )\tab 23\par put:  ( addr len -- )\tab 23\par ->:  ( str -- )\tab 23\par insert:  ( addr len -- )\tab 23\par $insert:  ( str -- )\tab 23\par add:  ( addr len )\tab 24\par $add  ( str -- )\tab 24\par +:  ( c -- )\tab 24\par fill:  ( c -- )\tab 24\par search  ( addr len -- b )\tab 24\par chsearch:  ( c -- b )\tab 24\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 object interaction\tab 24\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 copyto:  ( ^string-obj -- )\tab 24\par mark_original:  ( -- )\tab 24\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 display\tab 24\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 print:  ( -- )\tab 24\par dump:  ( -- )\tab 24\par rd:  ( -- )\tab 24\par \pard\plain \s231\fi-360\li360\ri540\sb240\keepn\tqdec\tx4320 \b\f20\fs20 TrTbl\tab 25\par \pard\plain \s228\li360\keepn\tqdec\tx12960 \i\f20\fs20 Object\tab 25\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 accessing\tab 25\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 tbl:  ( -- addr )\tab 25\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 selection\tab 25\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 clear:  ( -- )\tab 25\par put:  ( addr len -- )\tab 25\par selchars:  ( addr len -- )\tab 26\par selchar:  ( c -- )\tab 26\par selcharNC:  ( c -- )\tab 26\par selRange:  ( lo hi -- )\tab 26\par invert:  ( -- )\tab 26\par >uc:  ( -- )\tab 26\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 operations\tab 26\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 transc: ( c -- c' )\tab 26\par \pard\plain \s231\fi-360\li360\ri540\sb240\keepn\tqdec\tx4320 \b\f20\fs20 String+\tab 26\par \pard\plain \s228\li360\keepn\tqdec\tx12960 \i\f20\fs20 String, Handle, Var, Longword, Object\tab 27\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 accessing\tab 27\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 swapPos:  ( n -- n' )\tab 27\par save:  ( -- handle pos lim )\tab 27\par restore:  ( handle pos lim -- )\tab 27\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 character fetching\tab 27\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 2nd: ( -- c )\tab 27\par last:  ( -- c )\tab 27\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 comparisons\tab 27\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 compare:  ( addr len -- n )\tab 27\par ?:  ( addr len -- n )\tab 27\par =?:  ( addr len -- b )\tab 27\par ch=?:  ( c -- b )\tab 27\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 searching\tab 27\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 search:  ( addr len -- b )\tab 27\par <search:  ( addr len -- b )\tab 27\par sch&skip:  ( addr len -- b )\tab 27\par chsearch:  ( c -- b )\tab 27\par <chsearch:  ( c -- b )\tab 27\par chsch&skip:  ( c -- b )\tab 28\par chskip?:  ( c -- b )\tab 28\par chskip:  ( c -- )\tab 28\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 scanning\tab 28\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 scan:  ( trtbl -- n )\tab 28\par <scan:  ( trtbl -- n )\tab 28\par scax:  ( trtbl -- n )\tab 28\par <scax:  ( trtbl -- n )\tab 28\par translate:  ( trtbl -- )\tab 28\par trans1st:  ( trtbl -- n )\tab 28\par >uc:  ( -- )\tab 28\par ch>uc:  ( -- )\tab 28\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 insertion, deletion, replacement\tab 28\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 chinsert:  ( c -- )\tab 28\par ovwr:  ( addr len -- )\tab 28\par chovwr:  ( c -- )\tab 28\par $ovwr:  ( str -- )\tab 29\par repl:  ( addr len -- )\tab 29\par $repl:  ( str -- )\tab 29\par sch&repl:  ( addr1 len1 addr2 len2 -- b )\tab 29\par replAll:  ( addr1 len1 addr2 len2 -- )\tab 29\par delete:  ( -- )\tab 29\par deleteN:  ( n -- )\tab 29\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 line-oriented methods\tab 29\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 line>:  ( -- )\tab 29\par nextline?:  ( -- b )\tab 29\par <nextline?:  ( -- b )\tab 29\par addline:  ( addr len -- )\tab 29\par $addline:  ( str -- )\tab 29\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 I/O methods\tab 30\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 readN: ( file n -- )\tab 30\par readLine?:  ( file n -- b )\tab 30\par readRest:  ( file -- )\tab 30\par readAll:  ( file -- )\tab 30\par readTop:  ( -- )\tab 30\par $write:  ( file -- )\tab 30\par send:  ( file -- )\tab 30\par bring:  ( file -- )\tab 30\par draw:  ( theRect justification -- )\tab 30\par printAll:  ( -- )\tab 30\par \pard\plain \s231\fi-360\li360\ri540\sb240\keepn\tqdec\tx4320 \b\f20\fs20 File\tab 33\par \pard\plain \s228\li360\keepn\tqdec\tx12960 \i\f20\fs20 Object\tab 33\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 getting file information\tab 34\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 size:  ( -- #bytes )\tab 34\par bytesRead:  ( -- #bytes )\tab 34\par result:  ( -- rc )\tab 34\par getName:  ( -- addr len )\tab 34\par getFref:  ( -- fileRefNum )\tab 34\par getVref:  ( -- volRefNum )\tab 34\par getDirID:  ( -- DirID )\tab 34\par getType:  ( -- fType )\tab 34\par getFileInfo:  ( -- rc )\tab 34\par print:  ( -- )\tab 34\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 setting file characteristics\tab 34\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 stdget:  ( type0 \'c9 typeN #types -- bool )\tab 34\par stdput:  ( addr1 len1 addr2 len2 -- bool )\tab 34\par name:  ( addr len -- )\tab 34\par setName:  ( -- )\tab 34\par rename:  ( addr len -- rc )\tab 34\par mode:  ( mode -- )\tab 34\par set:  ( fType sig -- )\tab 34\par setFref:  (fileRefNum -- )\tab 34\par setVRef:  ( volRefNum -- )\tab 34\par setDirID:  ( DirID -- )\tab 34\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 file operations\tab 34\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 create:  ( -- rc )\tab 34\par open:  ( -- rc )\tab 34\par openReadOnly:  ( -- rc )\tab 34\par new:  ( -- rc )\tab 34\par read:  ( addr len -- rc )\tab 34\par write:  ( addr len -- rc )\tab 34\par readLine:  ( addr len -- rc )\tab 35\par moveTo:  ( pos -- rc )\tab 35\par last:  ( -- )\tab 35\par close:  ( -- rc )\tab 35\par delete:  ( -- rc )\tab 35\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 volume-level operations\tab 35\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 flushVol:  ( -- rc )\tab 35\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 parameter block access\tab 35\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 fcb:  ( -- addr )\tab 35\par clear:  ( -- )\tab 35\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 interpretation\tab 35\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 accept:  ( addr len -- #chrs eof? )\tab 35\par \pard\plain \s231\fi-360\li360\ri540\sb240\keepn\tqdec\tx4320 \b\f20\fs20 FileList\tab 35\par \pard\plain \s228\li360\keepn\tqdec\tx12960 \i\f20\fs20 HandleArray, ObjHandle, Array, Obj-array, Handle, Var, Longword, Indexed-Obj, Object\tab 35\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 accessing\tab 36\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 pushNew:  ( -- )\tab 36\par drop:  ( -- )\tab 36\par clear:  ( -- )\tab 36\par \pard\plain \s231\fi-360\li360\ri540\sb240\keepn\tqdec\tx4320 \b\f20\fs20 Event\tab 39\par \pard\plain \s228\li360\keepn\tqdec\tx12960 \i\f20\fs20 X-Array, Array, Indexed-Obj, Object\tab 39\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 accessing\tab 39\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 type:  ( -- evt )\tab 39\par mods:  ( -- mods )\tab 40\par msg:  ( -- msg )\tab 40\par where:  ( -- point )\tab 40\par msgID:  ( -- msgID )\tab 40\par when:  ( -- ticks )\tab 40\par set:  ( mask -- )\tab 40\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 polling\tab 40\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 next:  ( -- \'c9 b )\tab 40\par key:  ( -- key )\tab 40\par \pard\plain \s231\fi-360\li360\ri540\sb240\keepn\tqdec\tx4320 \b\f20\fs20 Mouse\tab 40\par \pard\plain \s228\li360\keepn\tqdec\tx12960 \i\f20\fs20 Object\tab 40\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 accessing\tab 40\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 get:  ( -- x y but )\tab 40\par where:  ( -- x y )\tab 40\par click:  ( -- b )\tab 40\par put:  ( ticks -- )\tab 40\par \pard\plain \s231\fi-360\li360\ri540\sb240\keepn\tqdec\tx4320 \b\f20\fs20 Window\tab 45\par \pard\plain \s228\li360\keepn\tqdec\tx12960 \i\f20\fs20 GrafPort, Object\tab 46\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 setting characteristics\tab 46\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 setContRect:  ( -- )\tab 46\par setGrow:  ( l t r b T or F -- )\tab 46\par setDrag:  ( l t r b T or F -- )\tab 46\par setScroll  ( b -- )\tab 46\par setIdle:  ( xt -- )\tab 46\par set:  ( -- )\tab 46\par select:  ( -- )\tab 46\par size:  ( w h -- )\tab 46\par setSize:  ( w h -- )\tab 46\par move:  ( x y -- )\tab 46\par center:  ( -- )\tab 46\par show:  ( -- )\tab 46\par hide:  ( -- )\tab 46\par actions:  ( close enact draw content 4 -- )\tab 47\par setAct:  ( enact deact -- )\tab 47\par setDraw:  ( drawXt -- )\tab 47\par title:  ( addr len -- )\tab 47\par name:  ( addr len -- )\tab 47\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 querying\tab 47\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 getName:  ( -- addr len )\tab 47\par getRect:  ( -- l t r b )\tab 47\par getVSRect:  ( -- l t r b )\tab 47\par getHSRect:  ( -- l t r b )\tab 47\par maxX:  ( -- x )\tab 47\par maxY:  ( -- y )\tab 47\par active:  ( -- b )\tab 47\par alive:  ( -- b )\tab 47\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 event handling\tab 47\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 draw:  ( -- )\tab 47\par idle:  ( -- )\tab 47\par enable:  ( -- )\tab 47\par disable:  ( -- )\tab 48\par update:  ( -- )\tab 48\par close:  ( -- )\tab 48\par release:  ( -- )\tab 48\par drag:  ( -- )\tab 48\par zoom:  ( part -- )\tab 48\par grow:  ( -- )\tab 48\par content:  ( -- )\tab 48\par key:  ( -- )\tab 48\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 object creation\tab 48\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 new:  ( ^rect tAddr tLen procID visible goAway -- )\tab 48\par \pard \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 getNew:  ( resID -- )\tab 48\par classinit:  ( -- )\tab 48\par test:  ( -- )\tab 48\par \pard\plain \s231\fi-360\li360\ri540\sb240\keepn\tqdec\tx4320 \b\f20\fs20 Window+\tab 49\par \pard\plain \s228\li360\keepn\tqdec\tx12960 \i\f20\fs20 Window, Grafport, Object\tab 49\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 accessing\tab 49\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 setZoom:  ( b -- )\tab 49\par getView:  ( -- ^view )\tab 49\par setView:  ( ^view -- )\tab 49\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 event handling\tab 49\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 grow:  ( -- )\tab 49\par zoom:  ( -- )\tab 49\par enable:  ( -- )\tab 49\par disable:  ( -- )\tab 49\par content:  ( -- )\tab 49\par draw:  ( -- )\tab 49\par idle:  ( -- )\tab 49\par close:  ( -- )\tab 49\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 object creation\tab 50\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 new:  ( ^rect tAddr tLen procID vis goAway ^view -- )\tab 50\par \pard \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 getnew:  ( resID ^view -- )\tab 50\par test:  ( -- )\tab 50\par \pard\plain \s231\fi-360\li360\ri540\sb240\keepn\tqdec\tx4320 \b\f20\fs20 View\tab 53\par \pard\plain \s228\li360\keepn\tqdec\tx12960 \i\f20\fs20 Object\tab 54\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 accessing\tab 54\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 getViewRect:  ( -- l t r b )\tab 54\par ^viewRect:  ( -- addr )\tab 54\par bounds:  ( -- l t r b )\tab 54\par getBounds:  ( -- l t r b )\tab 54\par getJust:  ( -- lj tj rj bj )\tab 54\par enabled?:  ( -- b )\tab 54\par window:  ( -- ^wind )\tab 54\par setWindow:  ( ^wind -- )\tab 54\par wantsClicks:  ( b -- )\tab 54\par setClick:  ( xt -- )\tab 54\par setDraw:  ( ??? -- )\tab 54\par setParent:  ( ^view -- )\tab 54\par clear:  ( ??? )\tab 54\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 View positioning\tab 54\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 bounds>viewRect:  ( ??? )\tab 54\par childrenMoved:  ( ??? )\tab 54\par moved:  ( ??? )\tab 54\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 object creation\tab 54\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 setJust:  ( lj tj rj bj -- )\tab 54\par setBounds:  ( l t r b -- )\tab 54\par measureFrom:  ( b -- )\tab 55\par addview:  ( ^view -- )\tab 55\par new:  ( ^view -- )\tab 55\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 manipulation\tab 55\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 release:  ( -- )\tab 55\par classinit:  ( -- )\tab 55\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 display\tab 55\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 draw:  ( -- )\tab 55\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 event handling\tab 55\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 idle:  ( -- )\tab 55\par click:  ( -- b )\tab 55\par key:  ( c -- )\tab 55\par enable:  ( -- )\tab 55\par disable:  ( -- )\tab 55\par drawX:  ( ??? )\tab 55\par \pard\plain \s231\fi-360\li360\ri540\sb240\keepn\tqdec\tx4320 \b\f20\fs20 Control\tab 56\par \pard\plain \s228\li360\keepn\tqdec\tx12960 \i\f20\fs20 View, Object\tab 56\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 accessing\tab 56\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 putResID:  ( resID -- )\tab 56\par get:  ( -- val )\tab 56\par put:  ( val -- )\tab 56\par handle:  ( -- hndl )\tab 56\par setTitle:  ( addr len -- )\tab 56\par getTitle:  (  -- addr len )\tab 56\par exec:  ( part# -- )\tab 56\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 manipulation\tab 56\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 moved:  ( -- )\tab 56\par hilite:  ( hiliteState -- )\tab 56\par enable:  ( -- )\tab 56\par disable:  ( -- )\tab 56\par hide:  ( -- )\tab 56\par show:  ( -- )\tab 56\par click:  ( -- )\tab 56\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 object creation\tab 56\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 new:  ( -- )\tab 56\par getnew:  ( -- )\tab 57\par release:  ( -- )\tab 57\par classinit:  ( -- )\tab 57\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 display\tab 57\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 draw:  ( -- )\tab 57\par \pard\plain \s231\fi-360\li360\ri540\sb240\keepn\tqdec\tx4320 \b\f20\fs20 TitledCtl\tab 57\par \pard\plain \s228\li360\keepn\tqdec\tx12960 \i\f20\fs20 Control, View, Object\tab 57\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 object creation\tab 57\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 init:  ( x y addr len -- )\tab 57\par \pard\plain \s231\fi-360\li360\ri540\sb240\keepn\tqdec\tx4320 \b\f20\fs20 Button, RadioButton, CheckBox\tab 57\par \pard\plain \s228\li360\keepn\tqdec\tx12960 \i\f20\fs20 TitledCtl, Control, View, Object\tab 58\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 classinit:  ( -- )\tab 58\par \pard\plain \s231\fi-360\li360\ri540\sb240\keepn\tqdec\tx4320 \b\f20\fs20 Vscroll, Hscroll\tab 58\par \pard\plain \s228\li360\keepn\tqdec\tx12960 \i\f20\fs20 Control, View, Object\tab 58\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 accessing\tab 58\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 actions:  ( up dn pgUp pgDn thumb 5 -- )\tab 58\par put:  ( val -- )\tab 58\par putMax:  ( val -- )\tab 58\par putMin:  ( val -- )\tab 58\par putRange:  ( lo hi -- )\tab 58\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 object creation\tab 58\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 init:  ( top left len -- )\tab 58\par new:  ( ^view -- )\tab 58\par getNew:  ( resID ^view -- )\tab 58\par classinit:  ( -- )\tab 59\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 display\tab 59\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 disable:  ( -- )\tab 59\par enable:  ( -- )\tab 59\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 execution\tab 59\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 exec:  ( part# -- )\tab 59\par \pard\plain \s231\fi-360\li360\ri540\sb240\keepn\tqdec\tx4320 \b\f20\fs20 Scroller\tab 59\par \pard\plain \s228\li360\keepn\tqdec\tx12960 \i\f20\fs20 View, Object\tab 60\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 accessing\tab 60\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 Vscroll:  ( b -- )\tab 60\par Hscroll:  ( b -- )\tab 60\par putPanRect:  ( l t r b -- )\tab 60\par >Hunit:  ( n -- )\tab 60\par >Vunit:  ( n -- )\tab 60\par >Hrange:  ( lo hi -- )\tab 60\par >Vrange:  ( lo hi -- )\tab 60\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 object creation\tab 60\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 new:  ( -- )\tab 60\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 manipulation\tab 60\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 ?Venable:  ( -- )\tab 60\par ?Henable:  ( -- )\tab 60\par enable:  ( -- )\tab 60\par disable:  ( -- )\tab 60\par moved:  ( left top -- )\tab 60\par pan:  ( dx dy -- )\tab 61\par panRight:  ( dx -- )\tab 61\par panLeft:  ( dx -- )\tab 61\par panUp:  ( dy -- )\tab 61\par panDown  ( dy -- )\tab 61\par Hpage:  ( -- #pixels )\tab 61\par Vpage:  ( -- #pixels )\tab 61\par 1right:  ( -- )\tab 61\par 1left:  ( -- )\tab 61\par 1up:  ( -- )\tab 61\par 1down:  ( -- )\tab 61\par pgRight:  ( -- )\tab 61\par pgLeft:  ( -- )\tab 61\par pgUp:  ( -- )\tab 61\par pgDown:  ( ??? )\tab 61\par Hdrag:  ( -- )\tab 61\par Vdrag:  ( -- )\tab 61\par classinit:  ( -- )\tab 61\par \pard\plain \s231\fi-360\li360\ri540\sb240\keepn\tqdec\tx4320 \b\f20\fs20 TEScroller\tab 62\par \pard\plain \s228\li360\keepn\tqdec\tx12960 \i\f20\fs20 Scroller, View, Object\tab 62\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 accessing\tab 62\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 textHandle:  ( -- hndl )\tab 62\par handle:  ( -- TEhndl )\tab 62\par size:  ( -- n )\tab 62\par getSelect:  ( -- start end )\tab 62\par selStart:  ( -- n )\tab 62\par selEnd:  ( -- n )\tab 62\par getLine:  ( -- start end )\tab 62\par lineEnd:  ( -- n )\tab 62\par ?scroll:  ( x y -- )\tab 62\par setSelect:  ( start end -- )\tab 62\par caretLoc:  ( -- x y )\tab 62\par caretIntoView: ( ??? )\tab 62\par key:  ( c -- )\tab 62\par insert:  ( addr len -- )\tab 62\par $insert:  ( ^str -- )\tab 63\par cut:  ( ??? )\tab 63\par copy:  ( ??? )\tab 63\par paste:  ( ??? )\tab 63\par clear:  ( ??? )\tab 63\par \pard\plain \s231\fi-360\li360\ri540\sb240\keepn\tqdec\tx4320 \b\f20\fs20 Menu\tab 66\par \pard\plain \s228\li360\keepn\tqdec\tx12960 \i\f20\fs20 X-Array, Array, Indexed-Obj, Object\tab 66\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 object creation/deletion\tab 66\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 putResID:  ( resID -- )\tab 66\par init:  ( xt1 ... xtN N resID -- )\tab 66\par new:  ( addr len -- )\tab 66\par getNew:  ( -- )\tab 66\par insert:  ( -- )\tab 66\par addRes:  ( type -- )\tab 66\par release:  ( -- )\tab 66\par normal:  ( -- )\tab 66\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 operations on individual items\tab 66\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 getItem:  ( item# -- addr len )\tab 66\par putItem:  ( item# addr len -- )\tab 66\par insertItem:  ( item# addr len -- )\tab 67\par deleteItem:  ( item# -- )\tab 67\par addItem:  ( addr len -- )\tab 67\par add:  ( addr len -- )\tab 67\par enableItem:  ( item# -- )\tab 67\par disableItem:  ( item# -- )\tab 67\par openDesk:  ( item# -- )\tab 67\par exec:  ( item# -- )\tab 67\par check:  ( item# -- )\tab 67\par unCheck:  ( item# -- )\tab 67\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 accessing\tab 67\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 ID:  ( -- resID )\tab 67\par handle:  ( -- hndl )\tab 67\par \pard\plain \s231\fi-360\li360\ri540\sb240\keepn\tqdec\tx4320 \b\f20\fs20 AppleMenu\tab 67\par \pard\plain \s228\li360\keepn\tqdec\tx12960 \i\f20\fs20 Menu, X-Array, Array, Indexed-Obj, Object\tab 68\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 getNew:  ( item# -- )\tab 68\par \pard\plain \s231\fi-360\li360\ri540\sb240\keepn\tqdec\tx4320 \b\f20\fs20 EditMenu\tab 68\par \pard\plain \s228\li360\keepn\tqdec\tx12960 \i\f20\fs20 Menu, X-Array, Array, Indexed-Obj, Object\tab 68\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 exec:  ( -- )\tab 68\par \pard\plain \s231\fi-360\li360\ri540\sb240\keepn\tqdec\tx4320 \b\f20\fs20 PopupMenu\tab 68\par \pard\plain \s228\li360\keepn\tqdec\tx12960 \i\f20\fs20 Menu, X-Array, Array, Indexed-Obj, Object\tab 69\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 accessing\tab 69\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 getText:  ( -- addr len )\tab 69\par putText:  ( addr len -- )\tab 69\par item#:  ( -- item# )\tab 69\par putItem#:  ( item# -- )\tab 69\par putTitle#:  ( title# -- )\tab 69\par put^dlg:  ( ^dlg -- )\tab 69\par f-link:  ( -- ptr )\tab 69\par set-f-link:  ( ptr -- )\tab 69\par box#:  ( -- n )\tab 69\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 object creation\tab 69\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 init:  ( xt-list resID box# title# -- )\tab 69\par getNew:  ( -- )\tab 69\par link:  ( ^dlg -- )\tab 69\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 operations\tab 69\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 normal:  ( -- )\tab 69\par drawText:  ( -- )\tab 69\par drawBox:  ( -- )\tab 69\par hit:  ( -- )\tab 70\par \pard\plain \s231\fi-360\li360\ri540\sb240\keepn\tqdec\tx4320 \b\f20\fs20 Mbar\tab 70\par \pard\plain \s228\li360\keepn\tqdec\tx12960 \i\f20\fs20 Object\tab 70\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 accessing\tab 70\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 clear:  ( -- )\tab 70\par add:  ( men0 \'c9 menN #menus -- )\tab 70\par new:  ( -- )\tab 70\par init:  ( men0 \'c9 menN #menus -- )\tab 70\par draw:  ( -- )\tab 70\par enable:  ( -- )\tab 70\par disable:  ( -- )\tab 70\par exec:  ( item# menuID -- )\tab 70\par click:  ( -- )\tab 70\par key:  ( chr -- )\tab 71\par \pard\plain \s231\fi-360\li360\ri540\sb240\keepn\tqdec\tx4320 \b\f20\fs20 Point\tab 73\par \pard\plain \s228\li360\keepn\tqdec\tx12960 \i\f20\fs20 Object\tab 74\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 accessing\tab 74\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 get:  ( --  x  y  )\tab 74\par getX:  ( --  x  )\tab 74\par getY:  ( --  y  )\tab 74\par int:  ( -- x:y )\tab 74\par put:  ( x  y  --  )\tab 74\par putX:  ( x -- )\tab 74\par putY:  ( y -- )\tab 74\par \pard\plain \s231\fi-360\li360\ri540\sb240\keepn\tqdec\tx4320 \b\f20\fs20 Rect\tab 74\par \pard\plain \s228\li360\keepn\tqdec\tx12960 \i\f20\fs20 Object\tab 74\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 accessing\tab 74\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 get:  ( -- l t r b )\tab 74\par getTop:  ( --  x y )\tab 74\par topInt:  ( -- x:y )\tab 74\par getTopX:  ( --  x )\tab 75\par getTopY:  ( --  y )\tab 75\par getBot:  ( --  x y )\tab 75\par botInt:  ( -- x:y )\tab 75\par getBotX:  ( --  x )\tab 75\par getBotY:  ( --  y )\tab 75\par put:  ( l t r b -- )\tab 75\par putTop:  ( x y -- )\tab 75\par putTopX:  ( x -- )\tab 75\par putTopY:  ( y -- )\tab 75\par putBot:  ( x y -- )\tab 75\par putBotX:  ( x -- )\tab 75\par putBotY:  ( y -- )\tab 75\par size:  ( -- w h )\tab 75\par setSize:  ( w h -- )\tab 75\par getCenter:  ( --  x y )\tab 75\par inset:  ( dx dy -- )\tab 75\par shift:  ( dx dy -- )\tab 75\par offset:  ( dx dy -- )\tab 75\par stretch:  ( dx dy -- )\tab 75\par ->:  ( ^rect -- )\tab 75\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 drawing\tab 75\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 draw:  ( -- )\tab 75\par dropShadow:  ( -- )\tab 75\par disp:  ( l t r b -- )\tab 75\par clear:  ( -- )\tab 75\par paint:  ( -- )\tab 75\par fill:  ( pattern -- )\tab 76\par invert:  ( -- )\tab 76\par clip:  ( -- )\tab 76\par update:  ( -- )\tab 76\par \pard\plain \s231\fi-360\li360\ri540\sb240\keepn\tqdec\tx4320 \b\f20\fs20 GrafPort\tab 76\par \pard\plain \s228\li360\keepn\tqdec\tx12960 \i\f20\fs20 Object\tab 76\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 accessing\tab 76\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 getRect:  ( -- l t r b )\tab 76\par putRect:  ( l t r b -- )\tab 76\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 drawing\tab 76\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 set:  ( -- )\tab 76\par \pard\plain \s231\fi-360\li360\ri540\sb240\keepn\tqdec\tx4320 \b\f20\fs20 Dialog\tab 78\par \pard\plain \s228\li360\keepn\tqdec\tx12960 \i\f20\fs20 X-Array, Array, Indexed-Obj, Object\tab 78\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 object creation\tab 79\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 init:  ( <xt list> resID -- )\tab 79\par setBold:  ( item# -- )\tab 79\par setProc:  ( xt -- )\tab 79\par putResID:  ( resID -- )\tab 79\par getNew:  ( -- )\tab 79\par show:  ( -- )\tab 79\par hide:  ( -- )\tab 79\par modal:  ( -- )\tab 79\par close:  ( -- )\tab 79\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 accessing items\tab 79\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 getItem:  ( item# -- val )\tab 79\par putItem:  ( val item# -- )\tab 79\par getText:  ( item# -- addr len )\tab 79\par putText:  ( addr len item# -- )\tab 79\par setSelect:  ( start end item# -- )\tab 79\par dlgPtr:  ( -- ^dlg )\tab 79\par itemHandle:  ( item# -- hndl )\tab 79\par open?:  ( -- b )\tab 79\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 drawing\tab 79\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 draw:  ( -- )\tab 79\par set:  ( -- )\tab 79\par drawBold:  ( -- )\tab 80\par setUserProc:  ( ^proc item# -- )\tab 80\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 manipulating individual items\tab 80\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 hideItem:  ( item# -- )\tab 80\par showItem:  ( item# -- )\tab 80\par disableItem:  ( item# -- )\tab 80\par enableItem:  ( item# -- )\tab 80\par hitBold:  ( -- )\tab 80\par key:  ( -- b )\tab 80\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 manipulating the dialog\rquote s window\tab 80\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 title:  ( addr len -- )\tab 80\par maxX:  ( -- x )\tab 80\par maxY:  ( -- y )\tab 80\par move:  ( x y -- )\tab 80\par select:  ( -- )\tab 80\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 global parameters\tab 80\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 ParamText  ( addr0 len0 addr1 len1 addr2 len2 addr3 len3 -- )\tab 80\par \pard \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 theItem, itemHandle, itemType\tab 80\par \pard\plain \s231\fi-360\li360\ri540\sb240\keepn\tqdec\tx4320 \b\f20\fs20 Dialog+\tab 81\par \pard\plain \s228\li360\keepn\tqdec\tx12960 \i\f20\fs20 Dialog, X-Array, Array, Indexed-Obj, Object\tab 81\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 object creation\tab 81\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 getNew:  ( -- )\tab 81\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 manipulation\tab 81\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 close:  ( -- )\tab 81\par disable:  ( -- )\tab 81\par enable:  ( -- )\tab 81\par exec:  ( item# -- )\tab 81\par enabled?:  ( -- b )\tab 81\par \pard\plain \s231\fi-360\li360\ri540\sb240\keepn\tqdec\tx4320 \b\f20\fs20 Alert\tab 81\par \pard\plain \s228\li360\keepn\tqdec\tx12960 \i\f20\fs20 X-Array, Array, Indexed-Obj, Object\tab 81\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 object creation\tab 82\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 init:  ( resID type -- )\tab 82\par show:  ( -- )\tab 82\par disp:  ( resId type -- )\tab 82\par \pard\plain \s231\fi-360\li360\ri540\sb240\keepn\tqdec\tx4320 \b\f20\fs20 fArray\tab 85\par \pard\plain \s228\li360\keepn\tqdec\tx12960 \i\f20\fs20 Indexed-Obj, Object\tab 85\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 accessing\tab 85\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 ^elem:  ( index -- addr )\tab 85\par at:  ( index --  fval )\tab 85\par to:  ( fval index -- )\tab 85\par fill:  ( fval -- )\tab 85\par print:  ( -- )\tab 86\par classinit:  ( -- )\tab 86\par \pard\plain \s231\fi-360\li360\ri540\sb240\keepn\tqdec\tx4320 \b\f20\fs20 FltHeap\tab 86\par \pard\plain \s228\li360\keepn\tqdec\tx12960 \i\f20\fs20 Object\tab 86\par \pard\plain \s230\fi-360\li1080\ri540\sb80\keepn\tqdec\tldot\tx4320 \f21\fs20 object creation\tab 86\par \pard\plain \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 \f20\fs20 init:  ( --  )\tab 86\par new:  ( -- fPtr )\tab 86\par release:  ( fPtr -- )\tab 86\par \pard \s229\fi-360\li720\ri540\tqdec\tldot\tx4320 room:  ( -- #free )\tab 86\par \pard\plain \f20 {\b\f21 \sect }\sectd \pgnrestart\linemod0\linex0\cols1\endnhere\titlepg {\headerl \pard\plain \s244\brdrb\brsp80\brdrhair \tqc\tx4680\tqr\tx9360 \f20 III-\chpgn \~Mops Predefined Classes\par }{\headerr \pard\plain \s244\brdrb\brsp80\brdrhair \tqc\tx4680\tqr\tx9360 \f20 \tab \tab Chapter 1\emdash Basic Data Structures\~III-\chpgn \par }\pard\plain \s255\qc\sb240\keepn \b\f21\fs36 Chapter 1\emdash Basic data structures\par \pard\plain \s254\sb240\keepn \b\f21 About this chapter\par \pard\plain \s7\qj\sb120 \f20 This chapter describes the Mops classes and words providing you with the fundamental structures that are nec\-essary for programming in Mops.  Most of these correspond to well-established data structures that are familiar to computer scientists, and some of them are unique to Mops on the Macintosh.  \par \pard\plain \s254\sb240\keepn \b\f21 Recommended reading \par \pard\plain \f20 IM -  Memory Manager\par IM -  Programming in Assembly Language\par \pard\plain \s254\sb240\keepn \b\f21 Source files\par \pard\plain \f20 Class\par Struct \par \pard\plain \s254\sb240\keepn \b\f21 Using the basic data structures\par \pard\plain \s7\qj\sb120 \f20 This chapter will discuss the primitive classes that Mops provides as building blocks out of which you can assemble the data structures necessary to build your application.  These classes are useful both as instance variables of more complex classes and as general classes from which you can derive more specialized sub\-classes.  The classes that will be covered here include:\par \trowd \trgaph80\trleft-80 \clshdng0\cellx2800\clshdng0\cellx5680\clshdng0\cellx8560\pard\plain \intbl \f20 Object\cell DicAddr\cell Ordered-Col\cell \pard \intbl \row \trowd \trgaph80\trleft-80 \clshdng0\cellx2800\clshdng0\cellx5680\clshdng0\cellx8560\pard \intbl Bytes\cell X-Addr\cell WordCol\cell \pard \intbl \row \pard \intbl Int\cell Indexed-Obj\cell ByteCol\cell \pard \intbl \row \pard \intbl Uint\cell bArray\cell X-Col\cell \pard \intbl \row \pard \intbl Longword\cell wArray\cell Sequence\cell \pard \intbl \row \pard \intbl Var\cell Array\cell HandleArray\cell \pard \intbl \row \pard \intbl Handle\cell X-Array\cell HandleList\cell \pard \intbl \row \pard \intbl ObjHandle\cell Obj_array\cell Dic-Mark\cell \pard \intbl \row \trowd \trgaph80\trleft-80 \clshdng0\cellx2800\clshdng0\cellx5680\clshdng0\cellx8560\pard \intbl Ptr\cell (Col)\cell Resource\cell \pard \intbl \row \pard\plain \s254\sb240\keepn \b\f21 Using Class Object and Bytes\par \pard\plain \s7\qj\sb120 \f20 The root of all classes is class Object.  It has no data, but does have a set of behaviors that are generally appli\-cable to any object, regardless of its format.  A class that has no particular inheritance path should make Object its superclass, which will cause it to inherit the general properties that all objects should have.  Addr: returns the base address of an object.  This is less useful with Mops 2.5, however, since just naming an object without sending it a message will cause its address to be pushed, and this works for both public objects and ivars (it used to only work for public objects).  Other methods in Object provide a hex dump of an object\rquote s data and access to an object\rquote s class pointer.\par Bytes is not really a class, but rather is a Mops word that enables you to allocate a certain number of bytes as an instance variable within a class definition.  Bytes is chiefly useful when mapping parts of Toolbox data structures that only need to be allocated but not accessed.  Bytes actually creates an ivar of class Object, so you can use Object\rquote s methods, such as Addr:, on an ivar created with Bytes.  As an example, class Window uses Bytes to allocate portions of the window record that Mops doesn\rquote t need  direct access to.  Remember, however, that Bytes is not an indexed type like barray\emdash its an Object.  If you send it a length: message you\rquote ll always get zero, which is the length of Object\emdash this surely won\rquote t be what you want!\par \pard\plain \s254\sb240\keepn \b\f21 Using the scalar classes\par \pard\plain \s7\qj\sb120 \f20 Scalar classes represent non-indexed objects which hold simple integer or pointer data.  A Byte, Int or Var can hold an 8,16, or 32-bit signed integer respectively.  A UByte or Uint can hold an 8 or 16-bit unsigned integer.  Bool is a 1-byte boolean class.  A Ptr is a simple pointer or address.  A DicAddr holds the address of a word in the dictionary.  An X-addr holds the address of an executable word.  A Handle has methods for allocating, sizing, locking and releasing relocatable blocks of heap.  ObjHandle is a subclass intended for dealing with dynamic objects on the heap.  For all of the scalar classes, Get: and Put: fetch and store the object\rquote s private data with an operation of the appropriate width. \par \pard\plain \s254\sb240\keepn \b\f21 Using the array classes\par \pard\plain \s7\qj\sb120 \f20 There are three basic array classes in Mops - bArray, wArray and Array, having 1, 2 and 4-byte indexed cells.  We have defined a basic set of array methods that are shared by these classes, and must be redefined if you create array classes with different indexed widths.  Most array messages require that an index be on the stack that reflects which cell of the array the operation refers to (indexes begin with 0).\par \pard \s7\qj\sb120 We have defined a generic superclass for all arrays, called Indexed-Obj.  This class defines some general methods which are independent of the indexed width.  These are ^Elem:, which returns the address of an indexed cell of any width, using a run-time lookup, Limit:, which tells you the maximum number of elements allocated to an object;  Width:, which tells you the width of an object\rquote s indexed cells;  ClearX:, which sets all of an array\rquote s cells to 0;  and IXAddr:, which leaves the address of the 0th indexed cell.\par \pard \s7\qj\sb120 There is also a group of methods that must be redefined for each array class having a different width.  These include: At:, which fetches the contents of the cell at an index; To: which stores to the indexed cell at an index, +To:, which increments an indexed cell by a value; -To:, which decrements an indexed cell, and Fill:, which fills an array with a value.  This group is shared by the three array classes that are predefined in Mops, and is documented later in this section.  We also override ^Elem: in these three classes to give greater speed, since we know the indexed width at compile time.\par \pard \s7\qj\sb120 Because class Array has 4-byte cells, it can be used to hold pointers to various kinds of structures in a way that the other array classes cannot.\par \pard \s7\qj\sb120 We have defined several classes which make it easy to handle groups of objects.   By multiply inheriting Obj_array with any other class, you create an array of objects of that class.  You then use the select: method to make one of those objects \ldblquote current\rdblquote , and can then access the \ldblquote current\rdblquote  object exactly as if it were a normal object, i.e. not part an array at all.\par \pard \s7\qj\sb120 HandleArray and HandleList are both for sets of heap-based objects, accessed through ObjHandles.  HandleArray uses ObjArray as one of its superclasses, so it uses the select: method to make a particular one of its ObjHandles \ldblquote current\rdblquote .\par \pard \s7\qj\sb120 Here\rquote s an example of how a HandleArray could be used to implement four windows accessible by index:\par \pard\plain \s10\keep\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 \f22\fs18 4 HandleArray Windows\par \pard \s10\keep\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 : CreateWindows\line \tab 4 0 DO  i select: windows  ['] window  newObj: windows  LOOP  ;\par \\ Resize window at index 2:\line \tab 2 select: windows   300 100  size: [ obj: windows ] \par \pard\plain \s7\qj\sb120 \f20 Notice how once we have used select: to choose which ObjHandle in the HandleArray we are referring to, we can then send other methods to the HandleArray exactly as if it were a single ObjHandle.  We can send late-bound messages to one of the windows, as in the size: message at the bottom, by using the obj: method defined for the ObjHandle class.  Actually, the objects in Windows could be of any class that accepted a size: message, due to the late binding.\par \pard \s7\qj\sb120 When you are finished with Windows, you can release all its heap storage simply by sending the message\par \pard\plain \s10\keep\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 \f22\fs18 \tab release: windows\par \pard\plain \s7\qj\sb120 \f20 If you look at the source for the HandleArray class, you will see that release: causes each of the ObjHandles to be selected in turn, and releaseObj: sent to each one.  If you now look at the source for ObjHandle, you will see that releaseObj: causes release: to be sent to the object pointed to by the handle, so that it will release any heap storage it has allocated, then finally release: super is called, which releases the heap block pointed to by the handle (that is, the object itself).  Thus, by simply sending release: to a HandleArray, we are releasing all the heap storage it owns.  Incidentally, if you want to just release one of the handles in a HandleArray, use select: followed by releaseObj:\emdash this is the reason we have defined releaseObj: separately from release:.\par \pard \s7\qj\sb120 Class X-Array adds to the basic Array the ability to execute one of its indexed cells, assuming that it holds the xt of a Mops word.  X-Array is a very important class in Mops, because its behavior is used throughout the system itself to provide control dispatching by index, as in Menu and Event.  The classinit: method in X-Array sets each indexed cell to Null so the object will behave gracefully if you fail to initialize it in your appli\-cation.  Use X-Array whenever you need to execute one of a group of Mops words based on a series of con\-tiguous indices.\par \pard\plain \s254\sb240\keepn \b\f21 Using Collections\par \pard\plain \s7\qj\sb120 \f20 Class Ordered-Col is another important class in Mops.  It is implemented by multiply inheriting the (Col) class with one of the array classes.  It adds to the array class the concept of a current length and the ability to add to and remove from the list.  This list also has many of the properties of a stack, which are exploited in such classes as FileList (see Chapter III.3).  When you create an Ordered-Col (O-C), you must specify, as with all indexed classes, the number of elements to allocate in the dictionary (or the heap).  O-C uses this as a maxi\-mum up to which its variable-length list will grow via the Add: method.  The advantage of an O-C is that you can add values to the end of the list without maintaining the index yourself, only the sequence in which to add.  You might want to utilize the O-C\rquote s  properties only while initializing the object, after which it is simply used as an Array.  WordCol is an Ordered-Col with 16-bit cells rather than 32-bit.\par \pard\plain \s254\sb240\keepn \b\f21 Using the Dictionary Class\par \pard\plain \s7\qj\sb120 \f20 Class Dictionary is a piece of code written for use with the assembler.  It is used to hold the symbol table, and allows strings (labels in the case of the assembler) to be dynamically added as the program is running, and associated with any object.  Dictionary is a subclass of HandleArray, and each element in the array can be the be\-ginning of a chain of dictionary elements (instances of class DictElt).  Class dictionary has two accessing methods, they are enter: and query:. When a label is encountered in the assembler, it is entered in the sym\-bol table.  If it is a definition, then the code position is stored with it, so:\par \pard\plain \s10\keep\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 \f22\fs18 : ENTERLABEL\line \tab token  query: symtab\line \tab nilP <> IF  253 asmError  THEN\tab \\ Error if already defined\line \tab ['] var  newObj: tempH\line \tab codePos 2*  here +  obj: tempH  put: **\line \tab tempH token  enter: symtab  unlock: tempH  ;\par \pard\plain \s7\qj\sb120 \f20 (Note: token is an instance of class String.)\par \pard\plain \s253\ri5760\sb360\sa240\keepn\brdrt\brsp240\brdrth \brdrb\brsp120\brdrs \b\f21 Object\par \pard\plain \s6\qj\sb120\sa240 \f20 Object contains behavior appropriate to all objects in the system. Every superclass chain ultimately traces back to Object.\par \pard\plain \s4\tx3600 \f20 Superclass\tab Meta\par Source file\tab Class\par Status\tab Core\par Instance variables\tab None\par Indexed data\tab None\par System objects\tab None\par \pard\plain \s250\fi-360\li360\phpg\posx20161\dxfrtext180 \f20 Meta\par \pard\plain \s11\sb120\keepn \b\f21 Methods\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 class:  ( -- addr )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns a pointer to the object\rquote s class.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 .id  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Types the object\rquote s name.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 .class  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Types the name of the object\rquote s class.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 addr:  ( -- addr )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the base address of an object\rquote s data.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 length:  ( -- #bytes )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the length of the object\rquote s ivar data area.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 copyto:  ( ^obj -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 ^obj is a pointer to another object.  This method copies that object\rquote s ivar data to this object.  Be careful using this method\emdash no check is done that the objects are of the same class.  However this method can be very useful in some situations.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 classinit:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 This a very special method\emdash whenever an object is created, Mops sends it a classinit: message so that it will initialize itself to reason\-able values, or whatever the programmer desires all objects of that class to do when created.  This method corresponds to a construc\-tor method in C++.  In class Object, it is a do-nothing method, allowing any subclass to override it as appropri\-ate.  By convention, init: is used for explicit programmatic initialization and cus\-tomiza\-tion thereafter, and new: is used to set up the toolbox-interface por\-tion of toolbox objects (such as making a window known to the Macintosh window manager).\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 release:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 This method does nothing in class Object itself.  However, in gen\-eral you should send release: to an object before you FORGET it or deallocate its memory.  release: will cause an object to release any heap memory it has allocated and do any other cleaning up which may be necessary.  This method corresponds to a destructor method in C++.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 dump:  ( -- addr )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Dumps the dictionary entry for the object in a hex format.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 print:  ( -- addr )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Dumps the dictionary entry for the object in a hex format.  This provides a default  print: method for objects that don\rquote t have a more sophisticated form of displaying their data.\par \pard\plain \s11\sb120\keepn \b\f21 Error messages\par \pard\plain \s5\qj\li720\sb120 \f20 None\par \pard\plain \s253\ri5760\sb360\sa240\keepn\brdrt\brsp240\brdrth \brdrb\brsp120\brdrs \b\f21 Longword\par \pard\plain \s6\qj\sb120\sa240 \f20 Longword provides storage for 32-bit quantities.  It is not intended to be used directly, but is a generic super\-class for Var , Handle, Ptr and DicAddr.\par \pard\plain \s4\tx3600 \f20 Superclass\tab Object\par Source file\tab Struct\par Status\tab Core\par Instance variables\par \pard\plain \s3\fi-3240\li3960\tx1800\tx3600 \f20\fs20 4 bytes\tab data\tab Allocates 32 bits of data.\par \pard\plain \s4\tx3600 \f20 Indexed data\tab None\par System objects\tab None\par \pard\plain \s250\fi-360\li360\phpg\posx20161\dxfrtext180 \f20 Object\par \pard\plain \s11\sb120\keepn \b\f21 Methods\par \pard\plain \s252\li720\sb120\keepn \f21 accessing\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 get:  ( -- val )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the value in the data area as a signed number.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 put:  ( val  -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Stores a new value in the data area.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 ->:  ( ^longword -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Copies the passed-in Longword\rquote s data to this Longword.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 clear:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Stores 0 in the data area.\par \pard\plain \s252\li720\sb120\keepn \f21 initialization\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 classinit:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Calls clear:.\par \pard\plain \s252\li720\sb120\keepn \f21 display\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20  print:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Prints the data in the current number base on the screen.\par \pard\plain \s11\sb120\keepn \b\f21 Error messages\par \pard\plain \s5\qj\li720\sb120 \f20 None\par \pard\plain \s253\ri5760\sb360\sa240\keepn\brdrt\brsp240\brdrth \brdrb\brsp120\brdrs \b\f21 Var\par \pard\plain \s6\qj\sb120\sa240 \f20 Var provides storage for 32-bit numeric quantities.\par \pard\plain \s4\tx3600 \f20 Superclass\tab Longword\par Source file\tab Struct\par Status\tab Core\par Instance variables\tab None (see Longword)\par Indexed data\tab None\par System objects\tab None\par \pard\plain \s250\fi-360\li360\phpg\posx20161\dxfrtext180 \f20 Longword, Object\par \pard\plain \s11\sb120\keepn \b\f21 Methods\par \pard\plain \s252\li720\sb120\keepn \f21 accessing\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 +:  ( val -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Adds val to the contents of the Var\rquote s data area.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 -:  ( val -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Subtracts val from the contents of the Var\rquote s data area.\par \pard\plain \s11\sb120\keepn \b\f21 Error messages\par \pard\plain \s5\qj\li720\sb120 \f20 None\par \pard\plain \s253\ri5760\sb360\sa240\keepn\brdrt\brsp240\brdrth \brdrb\brsp120\brdrs \b\f21 Int, Uint\par \pard\plain \s6\qj\sb120\sa240 \f20 Provides storage for 16-bit quantities\emdash signed (Int) and unsigned (Uint ).\par \pard\plain \s4\tx3600 \f20 Superclass\tab Object\par Source file\tab Struct\par Status\tab Core\par Instance variables\par \pard\plain \s3\fi-3240\li3960\tx1800\tx3600 \f20\fs20 2 bytes\tab data\tab Room for 16 bits of data.\par \pard\plain \s4\tx3600 \f20 Indexed data\tab None \par System objects\tab None\par \pard\plain \s250\fi-360\li360\phpg\posx20161\dxfrtext180 \f20 Object\par \pard\plain \s11\sb120\keepn \b\f21 Methods\par \pard\plain \s252\li720\sb120\keepn \f21 accessing\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 get:  ( -- val )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the value in the data area.  For class Int, this is a signed number\emdash if bit 15 is on, this bit will be extended into the high-order 16 bits of the stack cell.  For class Uint, the number is unsigned\emdash the high-order 16 bits of the stack cell will be set to zero.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 put:  ( val  -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Stores a new value in the data area.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 ->:  ( ^int -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Copies the passed-in Int/Uint\rquote s value to this Int/Uint.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 clear:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Stores 0 in the data area.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 int:  ( -- int )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the value in the data area as a 16-bit stack cell.  This is use\-ful for Toolbox calls that require parameters of type Int.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 +:  ( val -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Adds val to the contents of the Int/Uint\rquote s data area.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 -:  ( val -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Subtracts val from the contents of the Int/Uint\rquote s data area.\par \pard\plain \s252\li720\sb120\keepn \f21 display\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20  print:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Types the data in the current base on the screen.\par \pard\plain \s11\sb120\keepn \b\f21 Error messages\par \pard\plain \s5\qj\li720\sb120 \f20 None\par \pard\plain \s253\ri5760\sb360\sa240\keepn\brdrt\brsp240\brdrth \brdrb\brsp120\brdrs \b\f21 Byte, Ubyte\par \pard\plain \s6\qj\sb120\sa240 \f20 Provides storage for 8-bit quantities\emdash signed (Byte) and unsigned (Ubyte).\par \pard\plain \s4\tx3600 \f20 Superclass\tab Object\par Source file\tab Struct\par Status\tab Core\par Instance variables\par \pard\plain \s3\fi-3240\li3960\tx1800\tx3600 \f20\fs20 1 bytes\tab data\tab Room for 8 bits of data.\par \pard\plain \s4\tx3600 \f20 Indexed data\tab None \par System objects\tab None\par \pard\plain \s250\fi-360\li360\phpg\posx20161\dxfrtext180 \f20 Object\par \pard\plain \s11\sb120\keepn \b\f21 Methods\par \pard\plain \s252\li720\sb120\keepn \f21 accessing\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 get:  ( -- val )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the value in the data area.  For class Byte, this is a signed number\emdash if bit 7 is on, this bit will be extended into the high-order 24 bits of the stack cell.  For class Ubyte, the number is un\-signed\emdash the high-order 24 bits of the stack cell will be set to zero.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 put:  ( val  -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Stores a new value in the data area.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 ->:  ( ^int -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Copies the passed-in Byte/Ubyte\rquote s value to this Byte/Ubyte.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 clear:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Stores 0 in the data area.\par \pard\plain \s252\li720\sb120\keepn \f21 display\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20  print:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Types the data in the current base on the screen.\par \pard\plain \s11\sb120\keepn \b\f21 Error messages\par \pard\plain \s5\qj\li720\sb120 \f20 None\par \pard\plain \s253\ri5760\sb360\sa240\keepn\brdrt\brsp240\brdrth \brdrb\brsp120\brdrs \b\f21 Bool\par \pard\plain \s6\qj\sb120\sa240 \f20 Provides storage for boolean values (true or false).  These are stored in 8 bits.\par \pard\plain \s4\tx3600 \f20 Superclass\tab Byte\par Source file\tab Struct\par Status\tab Core\par Instance variables\tab None  (see Byte) \par Indexed data\tab None \par System objects\tab None\par \pard\plain \s250\fi-360\li360\phpg\posx20161\dxfrtext180 \f20 Byte, Object\par \pard\plain \s11\sb120\keepn \b\f21 Methods\par \pard\plain \s252\li720\sb120\keepn \f21 accessing\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 put:  ( val  -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Stores a new value in the data byte.  If val is non-zero, a \ldblquote proper\rdblquote  true is stored (all ones).  If val is zero, false (zero) is stored.  Thus val isn\rquote t just copied, but is converted to a \ldblquote proper\rdblquote  boolean value.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 get:  ( -- true | -- false )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 This method is inherited from Byte, but it is worth mentioning here that since it sign-extends, and we have either all zeros or all ones in the data byte, get: returns a \ldblquote proper\rdblquote  boolean flag value on the stack (all zeros or all ones).\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 set:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets the data byte to true (all ones).\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 clear:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets the data byte to false (zero).\par \pard\plain \s252\li720\sb120\keepn \f21 display\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20  print:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Types the data as \ldblquote true\rdblquote  or \ldblquote false\rdblquote .\par \pard\plain \s11\sb120\keepn \b\f21 Error messages\par \pard\plain \s5\qj\li720\sb120 \f20 None\par \pard\plain \s253\ri5760\sb360\sa240\keepn\brdrt\brsp240\brdrth \brdrb\brsp120\brdrs \b\f21 Handle\par \pard\plain \s6\qj\sb120\sa240 \f20 Handle adds to Longword methods useful for manipulating relocatable blocks of heap.\par \pard\plain \s4\tx3600 \f20 Superclass\tab Var\par Source file\tab Struct\par Status\tab Core\par Instance variables\tab None  (see Longword) \par Indexed data\tab None\par System objects\tab None\par \pard\plain \s250\fi-360\li360\phpg\posx20161\dxfrtext180 \f20 Var, Longword, Object\par \pard\plain \s11\sb120\keepn \b\f21 Methods\par \pard\plain \s252\li720\sb120\keepn \f21 accessing\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 ptr:  ( -- ptr )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns a dereferenced pointer from the handle.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 nptr:  ( -- ptr )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns a dereferenced pointer from the handle, and masks out any flag bits.  If your Mac is running in 24-bit mode, handles may have flag information in the high-order byte.  nptr: zeros these bits, so that you may compare or do arithmetic on the resulting pointer without problems.  But if you just want to access the data via the pointer, use ptr: which is slightly faster.\par \pard\plain \s252\li720\sb120\keepn \f21 manipulation\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 clear:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Stores nilH in the handle.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 setSize:  ( len -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets a new size for the heap block corresponding to the handle.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 size:  ( -- len )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the current size of the handle.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 new:  ( #bytes -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Allocates a block of relocatable heap via the Memory Manager, and stores the handle in this object\rquote s data.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 release:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Releases the heap block pointed to by the handle and stores nilH in the handle.  Does nothing if the handle already contains nilH.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 lock:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Locks the block corresponding to the handle.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 unlock:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Unlocks the block corresponding to the handle.  Does nothing if the handle contains nilH.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 locked?:  ( -- b )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns a boolean; true if the block is locked.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 getState:  ( -- n )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the state of the handle, via the system call _HGetState. Prior to locking a handle, it is best to get the state of the handle, perform the operation that needed the handle locked, then reset the state of the handle with setState:\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 setState:  ( n -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets the state of the handle.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 moveHi:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Calls the system to move the heap block high in memory.  It is gen\-erally a good idea to do this prior to locking the handle, to minimize heap fragmentation, unless you are going to unlock the handle again very quickly.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 ->:  ( ^handle -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Copies the heap data pointed to by the passed-in handle to this handle\rquote s heap block, and sets the size of this handle\rquote s block appropriately.\par \pard\plain \s11\sb120\keepn \b\f21 Error messages\par \pard\plain \s12\qj\sb120\keepn \i\f20 "Set handle size failed\rdblquote \par \pard\plain \s5\qj\li720\sb120 \f20 Non-0 return from memory manager on a SetHSize system call, probably resulting from a  setSize:  or  ->:  call with insufficient memory available.\par \pard\plain \s253\ri5760\sb360\sa240\keepn\brdrt\brsp240\brdrth \brdrb\brsp120\brdrs \b\f21 ObjHandle\par \pard\plain \s6\qj\sb120\sa240 \f20 ObjHandle adds to Handle methods for manipulating heap-based objects.\par \pard\plain \s4\tx3600 \f20 Superclass\tab Handle\par Source file\tab Struct\par Status\tab Core\par Instance variables\tab None\par Indexed data\tab None\par System objects\tab Many and various\par \pard\plain \s250\fi-360\li360\phpg\posx20161\dxfrtext180 \f20 Handle, Var, Longword, Object\par \pard\plain \s11\sb120\keepn \b\f21 Methods\par \pard\plain \s252\li720\sb120\keepn \f21 accessing\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 obj:  ( -- ^obj )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Locks the handle and returns a pointer to the addressed object.  You should normally unlock: when you\rquote re through operating on the object.\par \pard\plain \s252\li720\sb120\keepn \f21 manipulation\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 newObj:  ( [#elts] ^class -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Creates a new object of the given class on the heap and sets the handle.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 releaseObj:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Releases the handle, first sending release: to the object it points to.  Does nothing if the handle is nil.\par \pard\plain \s252\li720\sb120\keepn \f21 display\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 print:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Types both the handle and the object it points to, in the latter case sending a late-bound print: to the object.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 dump:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Likewise dumps both the handle and the object.\par \pard\plain \s11\sb120\keepn \b\f21 Error messages\par \pard\plain \s5\qj\li720\sb120 \f20 None\par \pard\plain \s253\ri5760\sb360\sa240\keepn\brdrt\brsp240\brdrth \brdrb\brsp120\brdrs \b\f21 Ptr\par \pard\plain \s6\qj\sb120\sa240 \f20 Ptr adds to Longword methods useful for manipulating non-relocatable blocks of heap.  Note: it is normally better to use Handles rather than Ptrs, to avoid the heap becoming fragmented with blocks which cannot be moved.\par \pard\plain \s4\tx3600 \f20 Superclass\tab Longword\par Source file\tab Struct\par Status\tab Core\par Instance variables\tab None  (see Longword) \par Indexed data\tab None\par System objects\tab None\par \pard\plain \s250\fi-360\li360\phpg\posx20161\dxfrtext180 \f20 Longword, Object\par \pard\plain \s11\sb120\keepn \b\f21 Methods\par \pard\plain \s252\li720\sb120\keepn \f21 manipulation\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 new:  ( len -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Allocates a block of non-relocatable heap, and stores the pointer in the object\rquote s data.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 release:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Deallocates the memory pointed to by the Ptr, and stores nilP in the Ptr.  Does nothing if the Ptr already contains nilP.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 clear:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Stores nilP in the Ptr.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 nil?:  ( -- b )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns True if the Ptr contains nilP.\par \pard\plain \s11\sb120\keepn \b\f21 Error messages\par \pard\plain \s12\qj\sb120\keepn \i\f20 "new: on a pointer couldn\rquote t get enough heap\rdblquote \par \pard\plain \s5\qj\li720\sb120 \f20 \par \pard\plain \s253\ri5760\sb360\sa240\keepn\brdrt\brsp240\brdrth \brdrb\brsp120\brdrs \b\f21 DicAddr\par \pard\plain \s6\qj\sb120\sa240 \f20 Dicaddr is used for storing the address of a location within the dictionary.  If the dictionary is saved and reloaded in a subsequent run, the address will still be valid.  This is accomplished by storing the address in a relocatable format.  Don\rquote t depend on details of this format, in case it changes.\par \pard\plain \s4\tx3600 \f20 Superclass\tab Longword\par Source file\tab Struct\par Status\tab Core\par Instance variables\tab None  (see Longword) \par Indexed data\tab None\par System objects\tab None\par \pard\plain \s250\fi-360\li360\phpg\posx20161\dxfrtext180 \f20 Longword, Object\par \pard\plain \s11\sb120\keepn \b\f21 Methods\par \pard\plain \s252\li720\sb120\keepn \f21 access\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 get:  ( -- addr )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Overrides get: in Longword.  Fetches the object\rquote s data (a relocat\-able address), converts it to absolute and returns it.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 put:  ( addr -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Stores the passed-in address in the object\rquote s data, using our relocat\-able format.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 print:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Types the word name corresponding to the stored address, or (no name) if the address isn\rquote t the address of a Mops word.\par \pard\plain \s11\sb120\keepn \b\f21 Error messages\par \pard\plain \s12\qj\sb120\keepn \i\f20 "you can\rquote t store a module address outside the module\rdblquote \par \pard\plain \s5\qj\li720\sb120 \f20 You attempted to put: the address of a location in a module, into a DicAddr located outside the mod\-ule.  This is illegal, since the module may have moved or been purged from memory when the DicAddr is next accessed.\par \pard\plain \s253\ri5760\sb360\sa240\keepn\brdrt\brsp240\brdrth \brdrb\brsp120\brdrs \b\f21 X-Addr\par \pard\plain \s6\qj\sb120\sa240 \f20 An X-Addr is almost the same as a DicAddr.  The only difference is that it is intended for dictionary addresses which are the execution tokens of Mops words, and so may be executed.  (Note that in Mops an execution token is an address of a word, whereas in other Forth systems it may not be an actual address.)  Thus we again use our relocatable format.  The only difference to a DicAddr is that there is an exec: method, and no get: method.\par \pard\plain \s4\tx3600 \f20 Superclass\tab Longword\par Source file\tab Struct\par Status\tab Core\par Instance variables\tab None  (see Longword) \par Indexed data\tab None\par System objects\tab None\par \pard\plain \s250\fi-360\li360\phpg\posx20161\dxfrtext180 \f20 Longword, Object\par \pard\plain \s11\sb120\keepn \b\f21 Methods\par \pard\plain \s252\li720\sb120\keepn \f21 access\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 exec:  ( -- various )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Executes the word whose xt has been stored in the X-Addr.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 put:  ( xt -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Stores the xt in the object\rquote s data, using our relocatable format.\par \pard\plain \s11\sb120\keepn \b\f21 Error messages\par \pard\plain \s12\qj\sb120\keepn \i\f20 "you can\rquote t store a module address outside the module\rdblquote \par \pard\plain \s5\qj\li720\sb120 \f20 See DicAddr.\par \pard\plain \s253\ri5760\sb360\sa240\keepn\brdrt\brsp240\brdrth \brdrb\brsp120\brdrs \b\f21 Indexed-Obj\par \pard\plain \s6\qj\sb120\sa240 \f20 This class is the generic superclass for all arrays.   It defines the general indexed methods, which apply regardless of indexed width.\par \pard\plain \s4\tx3600 \f20 Superclass\tab Object\par Source file\tab Struct,Struct1\par Status\tab Core\par Instance variables\tab None\par Indexed data\tab None (supplied by subclasses)\par System objects\tab None\par \pard\plain \s250\fi-360\li360\phpg\posx20161\dxfrtext180 \f20 Object\par \pard\plain \s11\sb120\keepn \b\f21 Methods\par \pard\plain \s252\li720\sb120\keepn \f21 accessing\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 ^elem:  ( index -- addr )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the address for the element at index.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 limit:  ( -- maxIndex+1 )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the allocated size of an indexed object.  The maximum usable index for an indexed object is this value minus 1.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 width:  ( -- #bytes )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the width of each indexed element.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 ixAddr:  ( -- addr )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the relative address for the 0th element.\par \pard\plain \s252\li720\sb120\keepn \f21 manipulation\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 clearX:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets each indexed element to 0.\par \pard\plain \s11\sb120\keepn \b\f21 Error messages\par \pard\plain \s12\qj\sb120\keepn \i\f20 "Index or value out of range\rdblquote \par \pard\plain \s5\qj\li720\sb120 \f20 One of the methods taking an index found the index to be out of range for this array.\par \pard\plain \s253\ri5760\sb360\sa240\keepn\brdrt\brsp240\brdrth \brdrb\brsp120\brdrs \b\f21 Basic array classes\emdash bArray, wArray, Array\par \pard\plain \s6\qj\sb120\sa240 \f20 These basic access methods are implemented for the three array classes predefined in Mops.\par \pard\plain \s4\tx3600 \f20 Superclass\tab Indexed-Obj\par Source file\tab Struct,Struct1\par Status\tab Core\par Instance variables\tab None\par Indexed data\tab 1,2,4-byte cells \par System objects\tab None\par \pard\plain \s250\fi-360\li360\phpg\posx20161\dxfrtext180 \f20 Indexed-Obj, Object\par \pard\plain \s11\sb120\keepn \b\f21 Methods\par \pard\plain \s252\li720\sb120\keepn \f21 accessing\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 at:  ( index -- val )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the data at a given indexed cell.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 to:  ( val index -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Stores data at a given indexed cell.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 +to:  ( increment index -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Increments data at a given indexed cell.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 -to:  ( decrement index -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Decrements data at a given indexed cell.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 fill:  ( val -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Stores val in each cell of the array.\par \pard\plain \s11\sb120\keepn \b\f21 Error messages\par \pard\plain \s12\qj\sb120\keepn \i\f20 "Index or value out of range\rdblquote \par \pard\plain \s5\qj\li720\sb120 \f20 As for Indexed-Obj.\par \pard\plain \s253\ri5760\sb360\sa240\keepn\brdrt\brsp240\brdrth \brdrb\brsp120\brdrs \b\f21 X-Array\par \pard\plain \s6\qj\sb120\sa240 \f20 X-Array is an Array with the ability to execute its indexed data as xts of Mops words.\par \pard\plain \s4\tx3600 \f20 Superclass\tab Array\par Source file\tab Struct\par Status\tab Core\par Instance variables\tab None\par Indexed data\tab 4-byte cells \par System objects\tab ???\par \pard\plain \s250\fi-360\li360\phpg\posx20161\dxfrtext180 \f20 Array, Indexed-Obj, Object\par \pard\plain \s11\sb120\keepn \b\f21 Methods\par \pard\plain \s252\li720\sb120\keepn \f21 accessing\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 exec:  ( ind -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Executes the xt in the indexed cell at ind.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 put:  ( xt0 ... xt(N-1)  N  -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Stores the N xts into the indexed elements of this object.  xt0 goes into element 0, xt1 into element 1, and so on.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 actions:  ( xt0 ... xt(N-1)  N -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 A synonym for put:.  A more appropriate name to use in subclasses such as dialogs.\par \pard\plain \s252\li720\sb120\keepn \f21 display\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 print:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Types the name of the word whose xt is in each element.\par \pard\plain \s252\li720\sb120\keepn \f21 initialization\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 classinit:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets all indexed elements to the null xt.\par \pard\plain \s11\sb120\keepn \b\f21 Error messages\par \pard\plain \s12\qj\sb120\keepn \i\f20 "Wrong number of xts in list\rdblquote \par \pard\plain \s5\qj\li720\sb120 \f20 For put:, the value N did not match the number of indexed elements for this object.\par \pard\plain \s253\ri5760\sb360\sa240\keepn\brdrt\brsp240\brdrth \brdrb\brsp120\brdrs \b\f21 Obj_array\par \pard\plain \s6\qj\sb120\sa240 \f20 This class is a generic superclass which makes it easy to generate an array of objects of a given class.  Just define a new class which multiply inherits from the given class (or classes) and Obj_array (which must come last).  This will add an indexed section to each object of the new class, with elements wide enough to contain objects of the original class(es).  Then select: \ldblquote switches in\rdblquote  the selected element to be the \ldblquote current\rdblquote  element, and all the normal methods of the class(es) can then be used.\par \pard\plain \s4\tx3600 \f20 Superclass\tab Object\par Source file\tab Struct\par Status\tab Core\par Instance variables\par \pard\plain \s3\fi-3240\li3960\tx1800\tx3600 \f20\fs20 Int\tab current\tab The number of the element currently \ldblquote switched in\rdblquote .\par \pard\plain \s4\tx3600 \f20 Indexed data\tab Any width\emdash the actual width is determined by the other class(es).\par \pard \s4\tx3600 System objects\tab None\par \pard\plain \s250\fi-360\li360\phpg\posx20161\dxfrtext180 \f20 Object\par \pard\plain \s11\sb120\keepn \b\f21 Methods\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 select:  ( index -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Makes the indexed element current.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 current:  ( -- index )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the index of the current element.\par \pard\plain \s11\sb120\keepn \b\f21 Error messages\par \pard\plain \s12\qj\sb120\keepn \i\f20 "Index or value out of range"\par \pard\plain \s5\qj\li720\sb120 \f20 An out-of-range index value was used for select:.\par \pard\plain \s253\ri5760\sb360\sa240\keepn\brdrt\brsp240\brdrth \brdrb\brsp120\brdrs \b\f21 (Col), Ordered-Col, wordCol, byteCol\par \pard\plain \s7\qj\sb120 \f20 Collections are ordered lists with a current size, that can also behave like a stack.  We implement them by multiply inheriting the generic (Col) class with an array class of the appropriate width.  (Col) adds the concept of a current size to the array methods.\par \pard\plain \s6\qj\sb120\sa240 \f20 Note: class Ordered-Col, wordCol and ByteCol are 32, 16 and 8 bit collections respectively.  All methods are identical to (Col).\par \pard\plain \s4\tx3600 \f20 Superclass\tab Object\par Source file\tab Struct\par Status\tab Core\par Instance variables\par \pard\plain \s3\fi-3240\li3960\tx1800\tx3600 \f20\fs20 int\tab Size\tab # elements currently held in the list.\par \pard\plain \s4\tx3600 \f20 Indexed data\tab None (supplied by the array class) \par System objects\tab None\par \pard\plain \s250\fi-360\li360\phpg\posx20161\dxfrtext180 \f20 Object\par \pard\plain \s11\sb120\keepn \b\f21 Methods\par \pard\plain \s252\li720\sb120\keepn \f21 accessing\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 size:  ( -- #elements )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the number of elements currently held in the list.  This must always be less than or equal to limit:.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 add:  ( val -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Appends value in the next available cell, and increments size by 1.  An error occurs if size=limit before the operation (list full).\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 last:  ( -- val )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Fetches the contents of the cell last added to the list.  Error if list is empty.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 remove:  ( ind -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Deletes the element at ind from the list, and reduces size by 1.  Error if the list is empty.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 clear:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets list to empty.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 indexOf:  ( val -- ind t OR -- f )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Searches for val within the current list, and returns the index and a True boolean if it was found, and False boolean if not found.\par \pard\plain \s11\sb120\keepn \b\f21 Error messages\par \pard\plain \s12\qj\sb120\keepn \i\f20 "My list is empty"\par \pard\plain \s5\qj\li720\sb120 \f20 A remove: or last: was attempted on an empty list.\par \pard\plain \s12\qj\sb120\keepn \i\f20 "My list is full\rdblquote \par \pard\plain \s5\qj\li720\sb120 \f20 An add: was attempted with size=limit.\par \pard\plain \s253\ri5760\sb360\sa240\keepn\brdrt\brsp240\brdrth \brdrb\brsp120\brdrs \b\f21 X-Col\par \pard\plain \s6\qj\sb120\sa240 \f20 This class is a collection of execution tokens.  It adds one new method, and overrides one method of X-Array.\par \pard\plain \s4\tx3600 \f20 Superclass\tab (Col)  X-Array\par Source file\tab Struct\par Status\tab Core\par Instance variables\tab None\par Indexed data\tab None (supplied by the X-Array) \par System objects\tab None\par \pard\plain \s250\fi-360\li360\phpg\posx20161\dxfrtext180 \f20 (Col), X-Array, Array, Indexed-Obj, Object\par \pard\plain \s11\sb120\keepn \b\f21 Methods\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 removeXt:  ( xt --  )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Removes the xt equal to the passed-in xt  Does nothing if no match is found.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 print:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 As for print: in class X-Array, but only types the xt names that are actually in the collection.\par \pard\plain \s11\sb120\keepn \b\f21 Error messages\par \pard\plain \s5\qj\li720\sb120 \f20 As for (Col).\par \pard\plain \s253\ri5760\sb360\sa240\keepn\brdrt\brsp240\brdrth \brdrb\brsp120\brdrs \b\f21 Sequence\par \pard\plain \s7\qj\sb120 \f20 Sequence is a generic superclass for classes which have multiple items which frequently need to be looked at in sequence.  At present the main function of Sequence is to implement the each: method, which makes it very simple to deal with each element.  The usage is\par \pard\plain \s10\keep\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 \f22\fs18 \tab BEGIN  each: <obj>  WHILE  <do something to the element>   REPEAT\par \pard\plain \s6\qj\sb120\sa240 \f20 Sequence can be multiply inherited with any class which implements the first?: and next: methods.  The actual implementation details are quite irrelevant, as long as these methods are supported.\par \pard\plain \s4\tx3600 \f20 Superclass\tab Object\par Source file\tab Struct\par Status\tab Core\par Instance variables\par \pard\plain \s3\fi-3240\li3960\tx1800\tx3600 \f20\fs20 Var\tab nxt_xt\tab Saves the xt for the next: method of the other class.\par Var\tab ^self\tab Saves the address of Self as required for BIND_WITH.\par \pard\plain \s4\tx3600 \f20 Indexed data\tab None\par System objects\tab None\par \pard\plain \s250\fi-360\li360\phpg\posx20161\dxfrtext180 \f20 Object\par \pard\plain \s11\sb120\keepn \b\f21 Methods\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 each:  ( (varies) -- true  OR  -- false\~)\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Initiates processing of a sequence as in the example above.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 uneach:  ( --  )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Terminates processing of a sequence before the normal end.  Use prior to an EXIT out of an each: loop.\par \pard\plain \s11\sb120\keepn \b\f21 Error messages\par \pard\plain \s5\qj\li720\sb120 \f20 None\par \pard\plain \s253\ri5760\sb360\sa240\keepn\brdrt\brsp240\brdrth \brdrb\brsp120\brdrs \b\f21 HandleArray\par \pard\plain \s6\qj\sb120\sa240 \f20 HandleArray provides for an array of handles to heap-based objects.  This array may be addressed as a stack, similarly to Ordered-Col.\par \pard\plain \s4\tx3600 \f20 Superclass\tab ObjHandle  Array  Obj_array\par Source file\tab Struct\par Status\tab Core   \par Instance variables\par \pard\plain \s3\fi-3240\li3960\tx1800\tx3600 \f20\fs20 Int\tab size\tab number of elements currently held in the array.\par \pard\plain \s4\tx3600 \f20 Indexed data\tab 4-byte cells (handles)\par System objects\tab None\par \pard\plain \s250\fi-360\li360\phpg\posx20161\dxfrtext180 \f20 ObjHandle, Array, Obj-array, Handle, Var, Longword, Indexed-Obj, Object\par \pard\plain \s11\sb120\keepn \b\f21 Methods\par \pard\plain \s252\li720\sb120\keepn \f21 accessing\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 size:  ( -- size )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the current  size.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 setSize:  ( size -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets the current  size.\par \pard\plain \s252\li720\sb120\keepn \f21 manipulation\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 release:  ( --  )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Releases the current handle.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 push:  ( handle -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Stores the handle in the next free position in the array\emdash the \ldblquote top of the stack\rdblquote  of handles.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 top:  ( --  )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Makes the \ldblquote top\rdblquote  handle current.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 drop:  ( --  )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Removes the \ldblquote top\rdblquote  handle, releasing it, and selects the next handle.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 pushNewObj:  ( ^class -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Creates a new object of the given class on the heap, and pushes the resulting handle on to the \ldblquote top of the stack\rdblquote  of handles.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 clearX:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets all the handles to nilH.\par \pard\plain \s11\sb120\keepn \b\f21 Error messages\par \pard\plain \s12\qj\sb120\keepn \i\f20 "My list is empty\rdblquote \par "My list is full"\par \pard\plain \s5\qj\li720\sb120 \f20 See (Col).\par \pard\plain \s253\ri5760\sb360\sa240\keepn\brdrt\brsp240\brdrth \brdrb\brsp120\brdrs \b\f21 HandleList\par \pard\plain \s6\qj\sb120\sa240 \f20 HandleList allows the implementation of a list of heap-based objects.  Unlike HandleArray, the list can be of indefinite length.  We use a heap block to store the handles to the objects contiguously, rather than have a sep\-arate block for each handle and link them together.  This saves on memory overhead and reduces the number of Memory Manager calls.  It also reflects the assumption that insertions and deletions into the middle of the list will be infrequent, as these could be more inefficient than with a linked scheme.  We expect that elements will normally be added to the end, and probably not removed at all, or not very often.\par \pard\plain \s4\tx3600 \f20 Superclass\tab ObjHandle  Sequence\par Source file\tab Struct\par Status\tab Core   \par Instance variables\par \pard\plain \s3\fi-3240\li3960\tx1800\tx3600 \f20\fs20 handle\tab TheList\tab Points to the memory block containing the handles.\par var\tab Size\tab The current size of the block, in bytes.\par var\tab Pos\tab The (byte) offset in that block of the current handle.\par \pard\plain \s4\tx3600 \f20 Indexed data\tab None\par System objects\tab None\par \pard\plain \s250\fi-360\li360\phpg\posx20161\dxfrtext180 \f20 ObjHandle, Sequence, Handle, Var, Longword, Object\par \pard\plain \s11\sb120\keepn \b\f21 Methods\par \pard\plain \s252\li720\sb120\keepn \f21 accessing\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 select:  ( index -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Makes the indexed handle current.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 selectLast:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Makes the last indexed handle current.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 current:  ( -- index )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the index of the current handle.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 size:  ( -- size )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the number of handles in the list.  (This is in fact the ivar Size divided by 4).\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 setSize:  ( size -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets the current  size.\par \pard\plain \s7\qj\sb120 \f20 The next two methods are needed by each:, but may be called directly as well.  Note that next:  ASSUMES that the list is allocated in the heap and that a valid element is selected as the current element.  each: ensures this, since if first?: returns false, next?: is never called.  But if you call it directly, make sure this condition holds.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 first?:  ( -- b )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 If the list isn\rquote t empty, makes the first handle current and returns True.  If the list is empty, returns False.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 next?:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 If the current handle isn\rquote t the last one, makes the next handle cur\-rent and returns True.  If the current handle is the last one, returns False.\par \pard\plain \s252\li720\sb120\keepn \f21 manipulation\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 newObj:  ( ^class -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Creates a new object of the passed-in class on the heap, and adds its handle to the list.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 releaseObj:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Releases the current handle, first sending release: to the object it points to.  Does nothing if the handle is nil.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 removeObj:  ( --  )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Releases the current handle as in releaseObj:, and removes it altogether from the list.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 release:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Releases the whole list.  Every handle is released as in releaseObj:, and the whole block containing the handles is released as well.\par \pard\plain \s252\li720\sb120\keepn \f21 display\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 dumpAll:  ( --  )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Gives a dump of the whole list, including sending dump: to each of the objects.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 printAll:  ( --  )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Displays the whole list, including sending print: to each of the objects.\par \pard\plain \s11\sb120\keepn \b\f21 Error messages\par \pard\plain \s5\qj\li720\sb120 \f20 None\par \pard\plain \s253\ri5760\sb360\sa240\keepn\brdrt\brsp240\brdrth \brdrb\brsp120\brdrs \b\f21 PtrList\par \pard\plain \s6\qj\sb120\sa240 \f20 PtrList allows the implementation of a list of pointers which point to objects.  The objects can be anywhere.  Similarly to HandleList, we use a heap block to store the pointers.\par \pard\plain \s4\tx3600 \f20 Superclass\tab Ptr  Sequence\par Source file\tab Struct\par Status\tab Core\par Instance variables\par \pard\plain \s3\fi-3240\li3960\tx1800\tx3600 \f20\fs20 handle\tab TheList\tab Points to the memory block containing the pointers.\par var\tab Size\tab The current size of the block, in bytes.\par var\tab Pos\tab The (byte) offset in that block of the current pointer.\par \pard\plain \s4\tx3600 \f20 Indexed data\tab None\par System objects\tab None\par \pard\plain \s250\fi-360\li360\phpg\posx20161\dxfrtext180 \f20 Ptr, Sequence, Longword, Object\par \pard\plain \s11\sb120\keepn \b\f21 Methods\par \pard\plain \s252\li720\sb120\keepn \f21 accessing\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 select:  ( index -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Makes the indexed pointer current.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 selectLast:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Makes the last pointer current.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 current:  ( -- index )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the index of the current pointer.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 size:  ( -- size )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the number of pointer in the list.  (This is in fact the ivar Size divided by 4).\par \pard\plain \s7\qj\sb120 \f20 The next two methods are needed by each:, but may be called directly as well.  Note that next:  ASSUMES that the list is allocated in the heap and that a valid element is selected as the current element.  each: ensures this, since if first?: returns false, next?: is never called.  But if you call it directly, make sure this condition holds.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 first?:  ( -- b )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 If the list isn\rquote t empty, makes the first pointer current and returns True.  If the list is empty, returns False.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 next?:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 If the current pointer isn\rquote t the last one, makes the next handle cur\-rent and returns True.  If the current pointer is the last one, returns False.\par \pard\plain \s252\li720\sb120\keepn \f21 manipulation\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 add:  ( ptr -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Adds the pointer to the end of the list.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 remove:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Removes the current pointer from the list.\par \pard\plain \s252\li720\sb120\keepn \f21 display\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 dumpAll:  ( --  )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Gives a dump of the whole list, including sending dump: to the objects pointed to by all the pointers.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 printAll:  ( --  )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Displays the whole list, including sending print: to the objects pointed to by all the pointers.\par \pard\plain \s11\sb120\keepn \b\f21 Error messages\par \pard\plain \s5\qj\li720\sb120 \f20 None\par \pard\plain \s253\ri5760\sb360\sa240\keepn\brdrt\brsp240\brdrth \brdrb\brsp120\brdrs \b\f21 Dic-Mark\par \pard\plain \s6\qj\sb120\sa240 \f20 Dic-Mark marks a dictionary position, and includes methods for traversing the dictionary.\par \pard\plain \s4\tx3600 \f20 Superclass\tab Object\par Source file\tab Struct\par Status\tab Core   \par Instance variables\par \pard\plain \s3\fi-3240\li3960\tx1800\tx3600 \f20\fs20 array\tab Links\tab Stores the set of dictionary addresses which point to the various entries on the various threads corresponding to the current position.\par \pard \s3\fi-3240\li3960\tx1800\tx3600 int\tab Current\tab The index in Links of the current position itself.\par \pard\plain \s4\tx3600 \f20 Indexed data\tab None\par System objects\tab TheMark\par \pard\plain \s250\fi-360\li360\phpg\posx20161\dxfrtext180 \f20 Object\par \pard\plain \s11\sb120\keepn \b\f21 Methods\par \pard\plain \s252\li720\sb120\keepn \f21 accessing\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 current:  ( -- addr )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the current position.\par \pard\plain \s252\li720\sb120\keepn \f21 manipulation\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 set:  ( addr -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets the current position to addr (setting the array Links appropri\-ately).\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 setToTop:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets the current position to the top of the dictionary.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 next:  ( -- addr )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Moves the current position to the preceding dictionary word, and returns the address of the link field of that word.  Returns zero if we were already at the base of the dictionary.\par \pard\plain \s11\sb120\keepn \b\f21 Error messages\par \pard\plain \s5\qj\li720\sb120 \f20 None\par \pard\plain \s253\ri5760\sb360\sa240\keepn\brdrt\brsp240\brdrth \brdrb\brsp120\brdrs \b\f21 Resource\par \pard\plain \s6\qj\sb120\sa240 \f20 Resource implements Macintosh Resources.\par \pard\plain \s4\tx3600 \f20 Superclass\tab Handle\par Source file\tab Struct\par Status\tab Core\par Instance variables\par \pard\plain \s3\fi-3240\li3960\tx1800\tx3600 \f20\fs20 Var\tab Type\tab 4-byte code for the resource type of this resource.\par Int\tab ID\tab The resource\rquote s ID.\par \pard\plain \s4\tx3600 \f20 Indexed data\tab None\par System objects\tab Some\par \pard\plain \s250\fi-360\li360\phpg\posx20161\dxfrtext180 \f20 Handle, Var, Longword, Object\par \pard\plain \s11\sb120\keepn \b\f21 Methods\par \pard\plain \s252\li720\sb120\keepn \f21 accessing\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 set:  ( type ID -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Stores the passed-in type and ID in this object\rquote s data.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 getNew:  ( -- index )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Accesses the resource with the current type and ID via a GetResource call, and stores the handle in this object\rquote s data.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 getXstr:  ( index -- addr length )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 This resource object must have type STR# (string list).  Accesses the indexed string and returns its address and length.\par \pard\plain \s11\sb120\keepn \b\f21 Error messages\par \pard\plain \s12\qj\sb120\keepn \i\f20 "We couldn\rquote t find this resource\rdblquote \par \pard\plain \s5\qj\li720\sb120 \f20 A call to getnew: resulted in the Mac system not being able to locate a resource with the current type and ID.  Possibly the type or ID are wrong, or the correct resource file isn\rquote t open.\par \pard\plain \s255\qc\sb240\keepn \b\f21\fs36 \sect \sectd \sbkodd\linemod0\linex0\cols1\endnhere\titlepg {\headerl \pard\plain \s244\brdrb\brsp80\brdrhair \tqc\tx4680\tqr\tx9360 \f20 III-\chpgn \~Mops Predefined Classes\par }{\headerr \pard\plain \s244\brdrb\brsp80\brdrhair \tqc\tx4680\tqr\tx9360 \f20 \tab \tab Chapter 2\emdash Strings\~III-\chpgn \par }{\headerf \pard\plain \f20 \par }\pard\plain \s255\qc\sb240\keepn \b\f21\fs36 Chapter 2\emdash Strings\par \pard\plain \s254\sb240\keepn \b\f21 About this chapter\par \pard\plain \s7\qj\sb120 \f20 This chapter describes Mops\rquote s string-handling classes.  Strings are objects that contain variable-length sequences of text, with methods for deletion, insertion etc.  Mops\rquote  powerful string-handling facility provides an excellent base on which you can build various text-based utilities.  \par \pard\plain \f20 Recommended reading \par IM -  Toolbox Utilities\par IM -  OS Utilities\par Mops - II.4, \ldblquote Using Strings in Mops"\par \pard\plain \s254\sb240\keepn \b\f21 Source files\par \pard\plain \f20 String\par StrUtilities\par String+\par \pard\plain \s254\sb240\keepn \b\f21 Using strings\par \pard\plain \s7\qj\sb120 \f20 Mops strings are implemented as relocatable blocks of heap that can expand and contract as their contents change.  A string object itself contains a handle to the heap block that contains the string\rquote s data.  It also con\-tains three other ivars which we will describe below.\par \pard \s7\qj\sb120 Strings can be useful for a wide variety of programming needs.  They can serve as file buffers, staging areas for text to be printed on the screen, dictionaries, or vehicles for parsing user input.  You should consider using strings for any run of bytes whose length and/or contents are likely to change in the course of your pro\-gram\rquote s execution.  Strings are not restricted to ASCII text, although that will probably be their most common use.  Note, however, that text constants can more efficiently be implemented as SCONs or string literals (see II.4 for more information).\par \pard \s7\qj\sb120 Using strings is somewhat like using files, in that you must open the string before you use it and close it when you\rquote re through.  This is done by sending a New: message to each string before you use it, to allocate the string\rquote s heap storage, and then sending a Release: message when you no longer need the string.  Release: is actually inherited from String\rquote s superclass, Handle, and calls the Toolbox routine DisposeHandle.\par \pard \s7\qj\sb120 There are two classes of strings in Mops.  String supports basic string operations, such as Get:, Put: , Insert: and Add:.  Class String+, a subclass of String, adds more methods, such as searching.  Both classes are in the precompiled Mops.dic, and are really only split into two classes since String+ has some code methods, which require the Assembler for compilation, whereas we do require some string operations at an earlier point in the building of the full system, before the Assembler is available.  But for all practical purposes you can treat the two classes as a single class.\par \pard \s7\qj\sb120 Many of the String methods are built around the Toolbox Utilities routine Munger, which is a general-purpose string-processing primi\-tive.  You might read the IM Toolbox Utilities section on Munger to gain a deeper understanding of what characteristics it contributes to Mops string handling.\par \pard \s7\qj\sb120 Strings have a current size, which is the same as the length of the relocatable block of heap containing the string\rquote s data.  Strings also have two offets into the string data, called POS and LIM.  POS marks the \ldblquote current\rdblquote  position, and LIM the \ldblquote current\rdblquote  end.  Most string operations operate on the substring delimited by POS and LIM, which we call the active part of the string, rather than the whole string.  We also keep the size of the string (the real size, that is) in an ivar, so that we can get it quickly without a system call.\par \pard\plain \s254\sb240\keepn \b\f21 Communicating with other objects\par \pard\plain \s7\qj\sb120 \f20 While most of the method descriptions below should be self-explanatory, several are worth additional com\-ment.  One group of String+\rquote s methods takes the address of another String or String+ object as one of its parameters, and accesses the active part of this second string.\par \pard \s7\qj\sb120 String+ also has several methods that simplify its use as a file buffer.  ReadN:, ReadRest:, ReadAll: and ReadLine?: all accept a File object as one of the parameters, and will request that the File perform a read into the string, setting the size of the string to the number of bytes actually read.  Doing things this way is very convenient, especially as the file data is left in  a String+ object, and is therefore subject to all of the various manipulations that String+ can perform.\par \pard \s7\qj\sb120 Finally, String+\rquote s Draw: method accepts a rectangle object and a justification parameter, and draws the con\-tents of the string as justified text within the box specified by the rectangle.\par \pard\plain \s253\ri5760\sb360\sa240\keepn\brdrt\brsp240\brdrth \brdrb\brsp120\brdrs \b\f21 String\par \pard\plain \s6\qj\sb120\sa240 \f20 String defines a variable-length string object with basic access methods whose data exists as a relocat\-able block of heap.  Size is limited only by available memory.   \par \pard\plain \s4\tx3600 \f20 Superclass\tab Handle\par Source file\tab String\par Status\tab Core\par \pard\plain \f20 Instance variables\par \pard\plain \s3\fi-3240\li3960\tx1800\tx3600 \f20\fs20 Var\tab pos\tab Offset into the string of the beginning of the active part.\par \pard \s3\fi-3240\li3960\tx1800\tx3600 Var\tab lim\tab One plus the offset of the last char in the active part.  Note that if pos = lim, the active part is empty.  Some methods signal an error if pos > lim, or if either is negative or greater than the size of the string.\par \pard \s3\fi-3240\li3960\tx1800\tx3600 Var\tab size\tab The size of the heap block containing the string data.\par Int\tab flags\tab Various flags are stored here.\par \pard\plain \s4\tx3600 \f20 Indexed data\tab None\par System objects\tab ???\par \pard\plain \s250\fi-360\li360\phpg\posx20161\dxfrtext180 \f20 Handle, Var, Longword, Object\par \pard\plain \s11\sb120\keepn \b\f21 Methods\par \pard\plain \s252\li720\sb120\keepn \f21 accessing\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 handle:  ( -- handle )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the handle to the string\emdash replaces get: in the superclass Handle, since we will be redefining get: here with a different meaning.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 pos:  ( -- n )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the value of Pos.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 >pos: ( n -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Stores n in Pos.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 lim:  ( -- n )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the value of Lim.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 >lim: ( n -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Stores n in Lim.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 len:  ( -- n )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the value of Lim - Pos, i.e. the length of the active part.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 >len: ( n -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Adds n and Pos, and stores the result in Lim.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 skip:  ( n -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Adds n to Pos.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 more: ( n -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Adds n to Lim.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 start:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Clears Pos, so that the active part now starts at the \ldblquote real\rdblquote  start of the string.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 begin:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Clears both Pos and Lim.  Useful for setting up for an iterative operation on the string.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 end:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets both Pos and Lim to the size (i.e. the end) of the string.  Useful for setting up for an iterative operation which has to go backwards through the string.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 nolim:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets Lim to the end of the string.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 reset:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Clears Pos, and sets Lim to the end of the string.  The active part will now be the whole string.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 step:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Steps forward in the string, setting Pos to Lim and then setting Lim to the end of the string.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 <step:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Steps backward in the string, setting Lim to Pos and then clearing Pos.\par \pard\plain \s252\li720\sb120\keepn \f21 manipulation\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 new:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Creates a heap block for the string\rquote s data, and sets the handle.  The initial size is zero.  new: must be done before the string can be used.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 ?new:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Ensures a heap block is allocated, by calling new: if necessary (indicated by the handle being nilH).  If a block is already allocated, does nothing.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 size:  ( -- n )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the size of the (whole) string.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 setSize:  ( n -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets the size of the (whole) string to n, then does a reset:.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 clear:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Ensures a heap block is allocated, calling new: if necessary, then sets its size to zero.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 get:  ( -- addr len )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the address and length of the active part of the string.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 1st:  ( -- c )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the character at Pos.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 ^1st:  ( -- addr )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the address of the character at Pos.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 uc:  ( -- addr len )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Converts the active part to upper case and does a get:.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 put:  ( addr len -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Ensures a heap block is allocated, calling new: if necessary, then replaces it with passed-in string, and does reset: as well.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 ->:  ( str -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Replaces the whole of this string (as in put:) with the active part of str, which may be a String or String+ (we use early binding, and assume the class).\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 insert:  ( addr len -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Ensures a heap block is allocated, calling new: if necessary, then inserts the string given by (addr len) at Pos.  Increments both Pos and Lim by len (thus the bytes at the Pos and Lim position will be the same as before, and the byte immediately preceding the Pos position will be the last of the inserted bytes).\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 $insert:  ( str -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Inserts the active part of str, as for insert:.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 add:  ( addr len )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Inserts (addr len) at the end of this string.  Pos and Lim are then set to the (updated) end position.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 $add  ( str -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Inserts the active part of str at the end of this string.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 +:  ( c -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Appends the character c to the end of the string, and sets Pos and Lim to the (updated) end position.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 fill:  ( c -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Overwrites each character in the active part of the string with the character c.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 search  ( addr len -- b )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Searches the active part of this string, starting from the left (i.e. the Pos position), for the string (addr len).  If a match is found, Lim is set to indicate the first of the matching characters and true is returned.  If no match is found, Lim is unchanged and false is returned.\par \pard \s2\qj\li3600\sb120\sbys Note 1: an improved version with case control is provided in String+.  \par \pard \s2\qj\li3600\sb120\sbys Note 2:  We use Lim rather than Pos, since it often happens after a search that some operation needs to be done on the part of the string preceding the matching substring.  If this isn\rquote t needed, step: is con\-venient for updating Pos to the matching substring position and preparing for another search.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 chsearch:  ( c -- b )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Searches the active part of this string for the character c.  If it is found, Lim is set there and true is returned.  If it isn\rquote t found, Lim is unchanged and false is returned.\par \pard\plain \s252\li720\sb120\keepn \f21 object interaction\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 copyto:  ( ^string-obj -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Overrides copyto: in class Object.  The only change is that we set a flag in this object, marking it as a copy.  This will mean that any future operation which would change the size of this object will be blocked with an error message.  You will be able to alter Pos and Lim freely, but not insert or delete.  It is frequently useful to have several copies of the same string object, in order to manipulate sev\-eral active parts at once.  But I have found that it\rquote s important to keep one as the \ldblquote original\rdblquote  object, and only insert/delete on this one.  Failure to do this led to crashes.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 mark_original:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Overrides the above check, by clearing the flag, so that this string becomes \ldblquote original\rdblquote .  Only use this method if you\rquote re quite sure what you\rquote re doing.  The idea of the long name is that you won\rquote t type it accidentally!\par \pard\plain \s252\li720\sb120\keepn \f21 display\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 print:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Displays the active part of the string, assuming it to be ASCII characters.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 dump:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Gives a dump of the string, displaying various useful quantities such as Pos and Lim, and displaying the contents of the string as ASCII characters and in hex.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 rd:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 "Reset and dump\rdblquote .  Does reset:. then dump:.  Short to type when debugging!\par \pard\plain \s11\sb120\keepn \b\f21 Error messages\par \pard\plain \s12\qj\sb120\keepn \i\f20 "String pointer(s) out of bounds\rdblquote \par \pard\plain \s5\qj\li720\sb120 \f20 Pos was found to be greater than Lim, or either was negative or greater than the size of the string.  Pos and Lim are also displayed when this message is given.  We check for this error condition when\-ever we access the actual characters of the string.  Operations such as >pos: don\rquote t perform the check\emdash this is for speed, and also because when we are doing manipulations on Pos and Lim we don\rquote t want to put any restriction on intermediate values.\par \pard\plain \s12\qj\sb120\keepn \i\f20 "Can\rquote t do that on a string copy\rdblquote \par \pard\plain \s5\qj\li720\sb120 \f20 You attempted to insert, delete, or change the size of a string object which was flagged as a \ldblquote copy\rdblquote .  See above under copyto:.\par \pard\plain \s253\ri5760\sb360\sa240\keepn\brdrt\brsp240\brdrth \brdrb\brsp120\brdrs \b\f21 TrTbl\par \pard\plain \s6\qj\sb120\sa240 \f20  Translate tables allow very fast searching of strings for specified sets of characters.  In effect we are separat\-ing the specification of what we are searching for from the actual search operation itself.  This allows an uncluttered and extremely fast search operation (the scan: and <scan: methods of class String+), and it also allows a very flexible (and easily extensible) choice of what to search for.  The setup time for translate tables can generally be factored out of inner loops, or done at compile time, and is quite fast, anyway.  We first define a class (trtbl) which is needed to define the table mapping lower case letters to upper case.  This table is then used by some of the methods in the Trtbl class proper.  However this is just an implementation conven\-ience\emdash these classes really should be thought of as one class, so we put all the methods together here.\par \pard\plain \s4\tx3600 \f20 Superclass\tab (TrTbl), whose superclass is Object\par Source file\tab StrUtilities\par Status\tab Core\par \pard\plain \f20 Instance variables \par \pard\plain \s3\fi-3240\li3960\tx1800\tx3600 \f20\fs20 int\tab count\tab Used internally in counting characters selected, so the table bytes can be set correctly.\par \pard \s3\fi-3240\li3960\tx1800\tx3600 256 bytes\tab TheTbl\tab The table itself.\par \pard\plain \s4\tx3600 \f20 Indexed data\tab None\par System objects\par \pard\plain \s9\fi-2880\li3600\tx3600 \f20 UCtbl\tab A table which maps lower case letters to upper case, and leaves everything else unchanged.\par \pard\plain \s250\fi-360\li360\phpg\posx20161\dxfrtext180 \f20 Object\par \pard\plain \s11\sb120\keepn \b\f21 Methods\par \pard\plain \s252\li720\sb120\keepn \f21 accessing\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 tbl:  ( -- addr )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the address of TheTbl.\par \pard\plain \s252\li720\sb120\keepn \f21 selection\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 clear:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Clears all bytes of the table to zero.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 put:  ( addr len -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Copies the bytes given by (addr len) into the table.  If len is greater than 256, only the first 256 bytes are copied.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 selchars:  ( addr len -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Selects each of the bytes given by (addr len).  The table byte corre\-sponding to each byte in the list will be set non-zero.  The actual value used will be n, where this is the nth byte which has been selected since the last clear:.  If two or more bytes in the list are the same (which means they select the same table position), the first will be used in determining the value of the table byte.  The count\-ing of n will nevertheless still continue for all the bytes in the passed-in list.  Note that this rule only applies within one selchars: operation\emdash if a character is selected by selchars: (or selchar: below) which has already been selected in a previous selection operation, and it is the nth character selected since the last clear:, the corre\-sponding table byte will still be set to n even though it was already non-zero.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 selchar:  ( c -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Selects the single character c.  The value of the table byte is deter\-mined as in selchars:.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 selcharNC:  ( c -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 "Select char, no case\rdblquote .  Selects a character, and if it is a letter, en\-ters the same value in the lower case and upper case positions of the table, so that case will in effect be ignored when the table is used.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 selRange:  ( lo hi -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Selects all characters with values from lo to hi inclusive.  The selected table bytes will all be set to 1\emdash when a range is selected, there isn\rquote t usually a need to distinguish the individual characters.  Does nothing if hi < lo.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 invert:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Reverses the current selection.  All non-zero table bytes are cleared, and all zero bytes are set to -1.  (There is no special significance in this value; it was just the simplest to do quickly, thanks to the SEQ machine instruction.)\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 >uc:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Copies the 26 bytes corresponding to A-Z into the a-z positions.  Subsequently any translate operation using this table object will give identical results for upper and lower case letters.  Note the direction of the copy\emdash you need to first set up the UPPER case letter positions, then use >uc:.\par \pard\plain \s252\li720\sb120\keepn \f21 operations\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 transc: ( c -- c' )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Translates the single character c using the table, and returns the cor\-responding byte c' from the table.\par \pard\plain \s7\qj\sb120 \f20 All other translate table operations are methods of class String+.\par \pard\plain \s11\sb120\keepn \b\f21 Error messages\par \pard\plain \s5\qj\li720\sb120 \f20 None\par \pard\plain \s253\ri5760\sb360\sa240\keepn\brdrt\brsp240\brdrth \brdrb\brsp120\brdrs \b\f21 String+\par \pard\plain \s6\qj\sb120\sa240 \f20 String+ adds many useful methods to String.\par \pard\plain \s4\tx3600 \f20 Superclass\tab String\par Source file\tab String+\par Status\tab Core\par Instance variables \tab None (see String)\par Indexed data\tab None\par \pard\plain \s250\fi-360\li360\phpg\posx20161\dxfrtext180 \f20 String, Handle, Var, Longword, Object\par \pard\plain \s11\sb120\keepn \b\f21 Methods\par \pard\plain \s252\li720\sb120\keepn \f21 accessing\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 swapPos:  ( n -- n' )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Swaps Pos with the top of the stack.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 save:  ( -- handle pos lim )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Saves the current string parameters.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 restore:  ( handle pos lim -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Restores the string parameters.  Must match a save:.\par \pard\plain \s252\li720\sb120\keepn \f21 character fetching\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 2nd: ( -- c )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the second char in the active part, or 0 if the active part\rquote s length is 1.  Gives an error if the active part is empty.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 last:  ( -- c )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the last char in the active part.  Gives an error if the active part is empty.\par \pard\plain \s252\li720\sb120\keepn \f21 comparisons\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 compare:  ( addr len -- n )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Compares the string ( addr len ) with the active part of this string.  Comparison is by CMPSTR, with the ( addr len ) string as the first operand.  Case is significant if CASE? is set to true. Returns: -1 if the first string is low, 0 if strings are equal, 1 if the first string is high. We assume the lengths are both less than 64K.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 ?:  ( addr len -- n )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 As for compare:, except that if the the ( addr len ) string is shorter than the active part of this string, only the first len chars in the active part are used.  Note that this only makes a differ\-ence if an \ldblquote equal\rdblquote  result is obtained.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 =?:  ( addr len -- b )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Compares as for ?:, but only tests for equal/not equal.  Returns true on equal.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 ch=?:  ( c -- b )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Compares the given single character against the character at Pos.  Returns true on equal.  If the active part of the string is empty, always returns false.\par \pard\plain \s252\li720\sb120\keepn \f21 searching\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 search:  ( addr len -- b )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Similar to search: in String, but has full case control, according to the setting of the value Case?.  This also applies to all the following searching operations.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 <search:  ( addr len -- b )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Backwards search.  Searches the active part of this string, starting from the right (i.e. the Lim position), for the string (addr len).  If a match is found, Pos is set to indicate the first (leftmost) of the matching characters and true is returned.  If no match is found, Pos is unchanged and false is returned.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 sch&skip:  ( addr len -- b )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Searches for the string ( addr len ) and if found, sets Pos to the character following the found substring.  Leaves Lim unchanged.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 chsearch:  ( c -- b )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Searches for the single character c.  If found, returns true and leaves Lim pointing there.  If not found returns false and leaves Lim unchanged.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 <chsearch:  ( c -- b )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Backward search for the character c.  If found, sets Pos.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 chsch&skip:  ( c -- b )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 What you\rquote d expect.  Searches as for chsearch:, and if the char is found, Pos is set pointing to the next character.  Lim is unchanged.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 chskip?:  ( c -- b )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Searches for the first character NOT equal to c.  This method has a couple of differences to the other searching methods, dictated by what we normally need it for.  If it suceeds, Pos (not Lim) is set to that position, and it is always case sensitive, regardless of CASE?.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 chskip:  ( c -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 As for chskip?:, but returns no boolean result.\par \pard\plain \s252\li720\sb120\keepn \f21 scanning\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 scan:  ( trtbl -- n )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Searches for a single character, using a translate table.  \ldblquote Success\rdblquote  is defined as a character which yields a non-zero value from the table.  The return result is this non-zero value, or zero if none was found.  On success, as usual, Lim is set to point to the found character.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 <scan:  ( trtbl -- n )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Backward scan.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 scax:  ( trtbl -- n )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 "Scan excluding\rdblquote .  As for scan:, but \ldblquote success\rdblquote  is defined as a char\-acter which yields a zero value from the table.  The return result is the last byte fetched from the table, which will be zero on success, or otherwise it will be whatever table byte corresponds to the last char in the active part of the string\emdash something non-zero, in any case.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 <scax:  ( trtbl -- n )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Backward scax.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 translate:  ( trtbl -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Translates the whole active part of the string, using the table.  Replaces each byte in the string with the looked-up value from the table.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 trans1st:  ( trtbl -- n )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Translates the first char in the active part of the string, and returns the looked-up value.  The char in the string isn\rquote t changed.  Returns zero if the active part is empty.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 >uc:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Converts any letters in the active part to upper case.  This is done by\par \pard \s2\qj\li3600\sb120\sbys UCtbl  translate: self\par This is faster than UPPER, and not limited to 64K.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 ch>uc:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Converts the first char of the active part to upper case.\par \pard\plain \s252\li720\sb120\keepn \f21 insertion, deletion, replacement\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 chinsert:  ( c -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Inserts the char c at Pos.  Pos and Lim are incremented by 1.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 ovwr:  ( addr len -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Overwrites the active part of this string with the string ( addr len ).  Copying stops at the end of the active part, or when len characters have been transferred.  Pos is incremented by the number of chars transferred.  This operation is faster than normal replacement, as the length of this string cannot change, so we don\rquote t need to call Munger.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 chovwr:  ( c -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Overwrites the char at Pos with c.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 $ovwr:  ( str -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Overwrites the active part of this string with the active part of str.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 repl:  ( addr len -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Replaces the active part of this string with the string (addr len).  Pos and Lim are both set pointing just past the newly inserted char\-acters.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 $repl:  ( str -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Replaces the active part of this string with the active part of str.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 sch&repl:  ( addr1 len1 addr2 len2 -- b )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Searches for the string (addr1 len1) in the active part of this string, using search:.  If a match is found, the matching substring is replaced by the string (addr2 len2), Pos and Lim are both set pointing just past the newly inserted characters, and true is returned.  If no match is found, Pos and Lim are unchanged and false is returned.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 replAll:  ( addr1 len1 addr2 len2 -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Replaces all occurrences of (addr1 len1) by (addr2 len2) in the WHOLE of this string (i.e. ignoring Pos and Lim).  After the operation, a reset: is done.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 delete:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Deletes the active part.  Lim is then set equal to Pos.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 deleteN:  ( n -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 From Pos, deletes n characters or up to Lim, whichever comes first.  Lim is reduced by the number of characters deleted.\par \pard\plain \s252\li720\sb120\keepn \f21 line-oriented methods\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 line>:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 sets Lim to the end of the current line (i.e. starting from Pos, the next Return character or the end of the string).  Pos is unchanged.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 nextline?:  ( -- b )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets Pos and Lim to delimit the next line.  This means Pos will point to the char after the Return character, and Lim to the next Return, or the end of the string.  If Lim initially does not point to a Return character, the \ldblquote next\rdblquote  line will actually be the rest of the cur\-rent one, starting from where Lim pointed.  This behaviour means that if Pos and Lim are initially zero, calling nextline?: will actually yield the first line.   This can be useful.  The returned boolean is true if we actually get another line, and false if we don\rquote t, that is, if Lim was initially at the end of the string.  Note that if the string ends with a Return character, and Lim points to this character when nextline?: is called, this is not the same as Lim pointing to the end of the string.  Lim will actually be one less than its \ldblquote end of string\rdblquote  value.  Thus nextline?: will return true with an empty line.  The next call will return false. \par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 <nextline?:  ( -- b )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 The backwards equivalent.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 addline:  ( addr len -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Adds the (addr len) string to this string as for add:.  Also adds a Return at the end, if (addr len) doesn\rquote t already end with a Return.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 $addline:  ( str -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Adds the active part of str to this string, as for addline:.\par \pard\plain \s252\li720\sb120\keepn \f21 I/O methods\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 readN: ( file n -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Reads n bytes using the passed-in file object.  The file must already be open.  The bytes read completely replace the WHOLE string (that is, Pos and Lim are ignored).  A reset: is done at the end.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 readLine?:  ( file n -- b )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Reads the next line up to a max of n chars into this string (as for readN:).  Returns false if end of file.  Reads a final Return character (if any) from the file, but doesn\rquote t include it in the bytes transferred to the string.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 readRest:  ( file -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Reads all the rest of the file from its current position into the string.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 readAll:  ( file -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Reads all the file into the string.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 readTop:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Reads all of Topfile into the string, then closes and drops Topfile (see class FileList).  Topfile must already be open.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 $write:  ( file -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Writes the active part to the file.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 send:  ( file -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Writes the whole string object to the file.  See under class File for a full description of the standard methods send: and bring:, which can be implemented by any classes which need them.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 bring:  ( file -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Reads back the string object from the file, assuming that it was written by send:.\par \pard\plain \f20 display\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 draw:  ( theRect justification -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Draws the active part in rect theRect, using the Toolbox TextBox routine.   justification  =\par \pard \s2\qj\li3600\sb120\sbys 0\tab Left justification\par 1\tab Center justification\par -1\tab Right justification\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 printAll:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Displays the whole string via TYPE.  Handles any embedded Return characters by starting a new line for each one.\par \pard\plain \s11\sb120\keepn \b\f21 Error messages\par \pard\plain \s5\qj\li720\sb120 \f20 None\par \pard\plain \s255\qc\sb240\keepn \b\f21\fs36 \sect \sectd \sbkodd\linemod0\linex0\cols1\endnhere\titlepg {\headerl \pard\plain \s244\brdrb\brsp80\brdrhair \tqc\tx4680\tqr\tx9360 \f20 III-\chpgn \~Mops Predefined Classes\par }{\headerr \pard\plain \s244\brdrb\brsp80\brdrhair \tqc\tx4680\tqr\tx9360 \f20 \tab \tab Chapter 3\emdash Files\~III-\chpgn \par }\pard\plain \s255\qc\sb240\keepn \b\f21\fs36 Chapter 3\emdash Files\par \pard\plain \s254\sb240\keepn \b\f21 About this chapter\par \pard\plain \s7\qj\sb120 \f20 This chapter describes the Mops classes and words that provide an interface to the  Macintosh file system.  Class File combines a Toolbox parameter block with methods for reading, writing,  interpreting and getting information about files; including Standard File I/O.  FileList provides a mechanism for dynamic allocation of File objects instead of having to create them statically in the dictionary.\par \pard\plain \s254\sb240\keepn \b\f21 Recommended reading \par \pard\plain \f20 IM -  File Manager\par IM -  OS\par IM -  Device Manager\par IM -  Package Manager\par IM -  Standard File Package\par IM -  Structure of a Macintosh Application\par \pard\plain \s254\sb240\keepn \b\f21 Source files\par \pard\plain \f20 Files\par PathMod.txt\par \pard\plain \s254\sb240\keepn \b\f21 Using files\par \pard\plain \s7\qj\sb120 \f20 All file access in Mops is done through an object of class File.  For instance, when you request that a source file be loaded, Mops creates a new File object, gives it a filename, opens it, and interprets from the file rather than from the keyboard.  File has as part of its data a parameter block, also called a File Control Block or FCB, which holds the data about the file that is needed by the Device Manager and the File Manager.  Appended to this is a 64-byte area that holds the name of the file that is associated with the File object.  To create an access path to a file, you must first create an object of class File, give it a name, and open it:  \par \pard\plain \s10\keep\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 \f22\fs18 \tab File  myFile\line \tab " someFilename" name:  myFile\line \tab open: myFile  abort" open failed"\par \pard\plain \s7\qj\sb120 \f20 The Name: message first clears the parameter block so that fields won\rquote t be left over from a previous open.  (This implies that you must set information other than the file name, like setVref:, after sending the Name: message.)  When you open the file, a unique IORefNum is assigned to it and placed in the parameter block.  You may then use any of the I/O methods to access the file, most of which return a code that reflects the result code from the Macintosh File Manager.  If this code is non-0, it means that an error occurred during the I/O.  You should check for EOF (-39) on reads, which should not always be treated as an error.\par \pard \s7\qj\sb120 Because File objects are almost 150 bytes in length, it is useful to be able to allocate them dynamically rather than have them locked into a static dictionary.  Class FileList, which is a subclass of HandleArray, provides this function by maintaining a \ldblquote stack\rdblquote  of handles to file objects in the heap.  Mops has a single 6-element object of class FileList, called LoadFile, that it uses internally to provide a nested load facility.  You can request that LoadFile allocate a new temporary File with the message pushNew: LoadFile.  The objPtr Topfile is maintained to always point to the last File object allocated, which is the \ldblquote top\rdblquote  of the file stack.  Thus, you can use phrases like:\par \pard\plain \s10\keep\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 \f22\fs18 \tab open: topfile\line \tab myBuf 100  read: topfile \par \pard\plain \s7\qj\sb120 \f20 After you are through using a dynamically allocated File object, you must close it and remove it from the file stack:\par \pard\plain \s10\keep\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 \f22\fs18 \tab drop: loadFile\par \pard\plain \s7\qj\sb120 \f20 Drop: automatically ensures that topFile is closed, but if you need to see the \lquote close\rquote  return code you will want to issue  close: topfile  before  drop: loadfile.\par The  Clear: method in FileList closes and removes any currently allocated files in the list, and is called by Mops\rquote s default Abort routine.\par \pard \s7\qj\sb120 There is a word, LOADTOP, which will open topfile, then invoke the Mops interpreter to interpret from that file rather than the keyboard, then close topfile when it reaches the end.  Interpretation will echo loaded text to the screen if the system Value echo? is true, and will end immediately if there is  an error.   There is also an Accept: method in File that simulates a Mops ACCEPT, but reads from a file.\par \pard\plain \s254\sb240\keepn \b\f21 Standard File Package \par \pard\plain \s7\qj\sb120 \f20 The StdGet: and StdPut: methods give easy access to the Macintosh Standard File Package.  This code is called by most applications when the user needs to select a file to open, or a \ldblquote Save As\rdblquote  name.  StdGet: and StdPut: set up and execute the various calls to the package manager.  StdGet: calls SFGetFile,  which dis\-plays the familiar scrollable list of files to open within a rectangle, and returns with a boolean on the top of the stack that tells you whether the user actually picked a file or hit the Cancel button.  If the boolean is true, your file object will have been set up with the parameters obtained by SFGetFile.\par \pard \s7\qj\sb120 StdPut: is used when you need to get a name from the user for a Save.  You need to provide two strings\emdash the first is a prompt, such as \ldblquote Save file as:\rdblquote , and the second is the default filename that will appear within the text edit item of the dialog.  The user is free to edit the text, and the method will return if the user hits Save, Cancel or the Return key.  Again, a boolean is returned and if it is true, your file object will have been set up with the parameters obtained by SFPutFile.\par \pard \s7\qj\sb120 With the StdGet: message, you provide a list of up to four file types to be filtered by SFGetFile.   Only the file types that you have listed will be included in the list of files to select.  For instance, \par \pard\plain \s10\keep\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 \f22\fs18 \tab 'type TEXT 1  stdGet: topfile\par \pard\plain \s7\qj\sb120 \f20 causes the Standard File Package to include only files of type \ldblquote TEXT\rdblquote  in its list, (the 1 indicates the number of types specified).  If you want all file types to be shown, do it thus:\par \pard\plain \s10\keep\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 \f22\fs18 \tab -1  stdGet: topfile\par \pard\plain \s7\qj\sb120 \f20 Keep in mind that neither StdGet: nor StdPut: ever actually open the chosen file.  They are identical in func\-tion to sending Name: & SetVref: to the file object.  You must subsequently send a Create:, Open: or OpenReadOnly: before you can access the file.\par \pard\plain \s254\sb240\keepn \b\f21 Hierarchical File System\par \pard\plain \s7\qj\sb120 \f20 Mac folders are the equivalent of MS-DOS or Unix directories.  This means that to find a file, the system needs not only its name but the names of all the nested folders in which it is located.  The names of these fold\-ers, from the top level down, is called the path to the file.  If you need to, you can in fact specify a file with a full pathname, which takes the form\par \pard\plain \s10\keep\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 \f22\fs18 \tab volumeName:folder1:folder2:folder3:filename\par \pard\plain \s7\qj\sb120 \f20 This is not normally a good idea, at least not in an installed application, since a user might rename or move a folder at any time, which would render the full pathname invalid.  Apple recommend that you use Standard File calls whenever possible to locate files.\par However in some situations you may know that some files are always in particular places, and in these situa\-tions you may use a full pathname.  Probably you will always keep your Mops source files in the same place, for example.\par \pard \s7\qj\sb120 To make the management of full pathnames easier in such situations, we provide a mechanism which is inte\-grated into the Open: method of class File, whereby a set of possible pathnames can be prepended to the file\-name, one at a time, until the file is found.  We use this system in the running of the Mops development sys\-tem itself, so that Mops source files can be stored in a number of different folders without requiring you to have to provide full pathnames or answer many Standard File dialogs.  We call this set of pathnames a pathlist.\par \pard \s7\qj\sb120 You specify a pathlist in an ordinary text file.  The format is, for example,\par \pard\plain \s10\keep\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 \f22\fs18 \tab ::System source:\line \tab ::Module source:\line \tab ::Toolbox Classes:\line \tab ::Mops folder:\par \pard\plain \s7\qj\sb120 \f20 Each line specifies the exact string which will in turn be prepended to the unqualified filename in the file object in an attempt to find the file on the disk.   Note however, that whatever you specify in the pathlist, the first folder searched will be the \ldblquote default folder\rdblquote , which is the folder from which the application started up, (the folder in which the Mops nucleus resides until the application is \ldblquote installed").  If the file isn\rquote t found in the default folder, the path specified in the top line of the pathlist file will be used, then the second, and so on, until either the file is found or the list is exhausted.  If the file still isn\rquote t found, a \ldblquote file not found\rdblquote  error will be returned.\par \pard \s7\qj\sb120 In this example all the paths start with two colons.  This says to step out of the folder in which the applica\-tion resides then step down into the specified folder.  You may also specify one colon which says to step down into the specific folder immediately within the application folder; or you might use three colons which say to step out of two folder levels then step down.  You may also begin with no colon which specifies a disk name.\par \pard \s7\qj\sb120 To load a pathlist file, type e.g.:\par \pard\plain \s10\keep\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 \f22\fs18 \tab " myPath" getPaths\par \pard\plain \s7\qj\sb120 \f20 This loads the list from the file named myPath into a string which is maintained by the PathsMod module, which is called by Open:.  From then on any Open: will search this pathlist to find the file to be opened; unless the file name is already fully qualified.  This technique gives you a degree of transparency since the specific code which issues the Open: never needs to know the particular paths which are being searched.\par \pard \s7\qj\sb120 You may disable the use of any pathlist by setting the value use_paths? false.  This is the initial default in installed applications.  When you call getPaths, this value is set true, so you don\rquote t need to do it yourself.\par \pard\plain \s253\ri5760\sb360\sa240\keepn\brdrt\brsp240\brdrth \brdrb\brsp120\brdrs \b\f21 File\par \pard\plain \s6\qj\sb120\sa240 \f20 File provides object-oriented access to the Macintosh File Manager.  An object of class File should be created for each separate access path required in your application.  File objects can be allocated dynamically by using a FileList, described below.\par \pard\plain \s4\tx3600 \f20 Superclass\tab Object\par Source file\tab Files\par Status\tab Core\par Instance variables\par \pard\plain \s3\fi-3240\li3960\tx1800\tx3600 \f20\fs20 134 bytes\tab FCB\tab max parameter block (108 but for hgetvinfo)\par record\tab FSSpec\par \{\tab int\tab FSvRefNum\par \tab var\tab FSDirID\par \tab 64 bytes\tab FileName\par \}\par \pard\plain \s4\tx3600 \f20 Indexed data\tab None \par \pard\plain \f20 System objects\par \pard\plain \s9\fi-2880\li3600\tx3600 \f20 fFcb \tab Used by Mops for system file access.\par \pard\plain \s250\fi-360\li360\phpg\posx20161\dxfrtext180 \f20 Object\par \pard\plain \s11\sb120\keepn \b\f21 Methods\par \pard\plain \s252\li720\sb120\keepn \f21 getting file information\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 size:  ( -- #bytes )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the logical size in bytes of the currently open file.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 bytesRead:  ( -- #bytes )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the actual byte count from the last operation.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 result:  ( -- rc )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the File Manager\rquote s result code from the last operation.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 getName:  ( -- addr len )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the name of the file.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 getFref:  ( -- fileRefNum )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the file reference number.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 getVref:  ( -- volRefNum )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the volume reference number.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 getDirID:  ( -- DirID )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the folder directory ID.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 getType:  ( -- fType )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the file type.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 getFileInfo:  ( -- rc )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Fills the parameter block with file info as outlined in the getFileInfo call in Inside Macintosh.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 print:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Prints the name of the file on the screen.\par \pard\plain \s252\li720\sb120\keepn \f21 setting file characteristics\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 stdget:  ( type0 \'c9 typeN #types -- bool )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Calls the Standard Get file routine.  If a valid file is chosen, places the information into the file object; ready for open: If you don\rquote t want to specify a type, set #types to 0 or -1.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 stdput:  ( addr1 len1 addr2 len2 -- bool )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Calls the Standard Put file routine.  If a valid file is chosen, places the information into the file object; ready for open:, or  create:\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 name:  ( addr len -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets the name of the file.  Clears the rest of the FCB.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 setName:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets the name of the file from the input stream.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 rename:  ( addr len -- rc )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets the name of  file on disk.  File does not have to be open.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 mode:  ( mode -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets the positioning mode for the currently open  file.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 set:  ( fType sig -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets the file type and signature for the file.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 setFref:  (fileRefNum -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets the file reference number.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 setVRef:  ( volRefNum -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets the volume reference number.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 setDirID:  ( DirID -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets the folder directory ID.\par \pard\plain \s252\li720\sb120\keepn \f21 file operations\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 create:  ( -- rc )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Attempts to open the file whose name is in FileName for read/write access.  If file is not found, creates it then opens it for read/write.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 open:  ( -- rc )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Opens the file whose name is in FileName for read/write access.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 openReadOnly:  ( -- rc )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Opens the file whose name is in FileName for read access.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 new:  ( -- rc )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Creates the file whose name is in FileName with 0 length.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 read:  ( addr len -- rc )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Reads len bytes into the buffer starting at addr (waited).\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 write:  ( addr len -- rc )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Writes len bytes from the buffer starting at addr (waited).\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 readLine:  ( addr len -- rc )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Reads len bytes into the buffer starting at addr (waited).  The read will terminate if a CR is received ($0D).\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 moveTo:  ( pos -- rc )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets the current position pointer in the parameter block to pos rela\-tive to the beginning of the file.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 last:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Positions to the end of the file.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 close:  ( -- rc )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Closes the currently open file.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 delete:  ( -- rc )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Deletes the file whose name is in fileName from the disk.  The file must not be open, or an error will result.\par \pard\plain \s252\li720\sb120\keepn \f21 volume-level operations\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 flushVol:  ( -- rc )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 The Mac system maintains a cache in RAM for each volume (usually a disk).  When data is written to the volume, it may not be written immediately to the actual disk, but stored in the cache.  flushVol: writes out any data which is still in the cache for the vol\-ume containing the current file.  This avoids any risk of data loss if there is a loss of power or a serious system crash.\par \pard\plain \s252\li720\sb120\keepn \f21 parameter block access\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 fcb:  ( -- addr )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the address of the parameter block associated with this File object.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 clear:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Clears the parameter block for a new Open.\par \pard\plain \s252\li720\sb120\keepn \f21 interpretation\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 accept:  ( addr len -- #chrs eof? )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Performs a Mops ACCEPT to the address provided, reading a line from the currently open file.  eof? is true if the line is the last line of the file.  #chrs is the actual number of characters read, excluding any terminating carriage return.  Lines are echoed to the screen if ECHO? is true.\par \pard\plain \s11\sb120\keepn \b\f21 Error messages\par \pard\plain \s5\qj\li720\sb120 \f20 None\emdash return codes from File Manager\par \pard\plain \s253\ri5760\sb360\sa240\keepn\brdrt\brsp240\brdrth \brdrb\brsp120\brdrs \b\f21 FileList\par \pard\plain \s6\qj\sb120\sa240 \f20 FileList is a HandleArray with specialized methods that assume the elements contain handles to File objects.  It provides dynamic allocation of File objects, keeping the handles in what is effectively a file stack.\par \pard\plain \s4\tx3600 \f20 Superclass\tab HandleArray\par Source file\tab Files\par Status\tab Core\par Instance variables \tab None (see HandleArray)\par Indexed data\tab 4-byte cells containing handles to File objects\par \pard\plain \f20 System objects\par \pard\plain \s9\fi-2880\li3600\tx3600 \f20 loadFile\tab 6-element FileList used for nested loads.\par \pard\plain \s250\fi-360\li360\phpg\posx20161\dxfrtext180 \f20 HandleArray, ObjHandle, Array, Obj-array, Handle, Var, Longword, Indexed-Obj, Object\par \pard\plain \s11\sb120\keepn \b\f21 Methods\par \pard\plain \s252\li720\sb120\keepn \f21 accessing\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 pushNew:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Allocates an object of class File on the heap and adds its handle to the end of the list.  Puts a pointer to the file object in Topfile (locking the handle).  Error if the list is full.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 drop:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Closes the top file object if it was still open, then deletes it and removes it from the list.  Topfile is set to point to the new top file.  Error if the list is empty.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 clear:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Closes and removes all files from the list.  Useful for cleaning up after an error.\par \pard\plain \s11\sb120\keepn \b\f21 Error messages\par \pard\plain \s12\qj\sb120\keepn \i\f20 "My list is empty"\par \pard\plain \s5\qj\li720\sb120 \f20 A remove: was received with an empty list.\par \pard\plain \s255\qc\sb240\keepn \b\f21\fs36 \sect \sectd \sbkodd\linemod0\linex0\cols1\endnhere\titlepg {\headerl \pard\plain \s244\brdrb\brsp80\brdrhair \tqc\tx4680\tqr\tx9360 \f20 III-\chpgn \~Mops Predefined Classes\par }{\headerr \pard\plain \s244\brdrb\brsp80\brdrhair \tqc\tx4680\tqr\tx9360 \f20 \tab \tab Chapter 4\emdash Events\~III-\chpgn \par }{\headerf \pard\plain \s244\tqc\tx4680\tqr\tx9360 \f20 \par }\pard\plain \s255\qc\sb240\keepn \b\f21\fs36 Chapter 4\emdash Events\par \pard\plain \s254\sb240\keepn \b\f21 About this chapter\par \pard\plain \s7\qj\sb120 \f20 This chapter describes the Mops classes and words that manage Macintosh events for the application.  Macintosh applications are event-driven, meaning that the program must at all times be responsive to the vari\-ous input devices available to the user, including the keyboard, the mouse and the disk.  Mops has built-in support classes that make event handling virtually invisible to the application, enabling the programmer to focus on the problems that he or she is attempting to solve.   Most of the time, you will not find it necessary to concern yourself with the Event classes, but this chapter will provide some orientation in case you would like to modify event handling to suit your specific needs.\par \pard\plain \s254\sb240\keepn \b\f21 Recommended reading \par \pard\plain \f20 IM -  Event Manager\par IM -  Window Manager\par IM -  Menu Manager\par IM - Control Manager\par Mops - Windows\par Mops - Menus\par Mops - Controls\par \pard\plain \s254\sb240\keepn \b\f21 Source files\par \pard\plain \f20 Event\par \pard\plain \s254\sb240\keepn \b\f21 Using events\par \pard\plain \s7\qj\sb120 \f20 Class Event is the core of Mops\rquote s event management.  It instantiates a single object, fEvent, which resides in the nucleus portion of Mops\rquote s dictionary.  FEvent is functionally an X-Array of 24 elements, each of which contains the xt of a Mops word corresponding to a particular event type.  The Macintosh OS maintains a first-in first-out queue of events received from various I/O devices, and the application can request that the next event be accepted from the queue at any time.  If no \lquote real\rquote  events are outstanding, the Macintosh returns to the application with a Null event, which is simply a statement that nothing else happened so that the appli\-cation can continue with its processing.\par \pard \s7\qj\sb120 Non object-oriented Macintosh programs are usually designed with a huge case statement at the highest level that processes the various types of events that can occur.  This results in a sort of inverted structure, in which the lowest-level processing is managed at the highest level of the code.  Mops avoids this by handling as many conditions as it can behind the scenes (for instance, calling the Menu Manager when the user clicks the mouse in the menu bar)  and using late binding to allow the application to provide specific processing where it is needed.  For example, each window in an application might take a unique action when the user clicks the mouse in its content region.  Mops simply sends a late-bound Content: message to the front window when a content click occurs, which results in the specific content method being executed that is appropriate for the window\rquote s class.  Late binding allows Mops\rquote  event management to be completely general and open-ended, because the programmer can always build more specific event responses into Window and Control subclasses.  Mops\rquote  basic Window and Control classes provide general behavior that will be acceptable for many situations.\par \pard \s7\qj\sb120 Macintosh events are assigned a contiguous series of type codes:\par \pard\plain \tqc\tx1440\tx2520 \f20 \tab Type Code\tab Description\par \tab 0\tab * Null event - used to provide background processing\par \tab 1\tab Mouse down - button was depressed\par \tab 2\tab * Mouse up - button was released\par \tab 3\tab Key down - key was depressed\par \tab 4\tab * Key up - key was released\par \tab 5\tab AutoKey - key is being held down\par \tab 6\tab Update - a window must redraw a portion of its contents\par \tab 7\tab Disk - a disk was inserted in a drive\par \tab 8\tab Activate - a window became active or inactive\par \tab 10\tab * Network - an AppleBus event occurred\par \tab 11\tab * IODriver - a device driver event occurred\par \tab 12-14\tab * user-definable events\par \tab 15\tab OS events, such as Suspend and Resume\par \tab 23\tab High-level events, including AppleEvents\par \pard\plain \s7\qj\sb120 \f20 Events marked with a * are events for which Mops executes its null-event code rather than code specific to the type of event.  If your application assigns significance to these event types, you will have to install your own action word in the cell of fEvent corresponding to the event\rquote s type.  You might also need to change fEvent\rquote s mask with the set: method to accommodate event types that are currently masked out.\par \pard \s7\qj\sb120 Class Event contains a set of named ivars that allocate a Toolbox event record. Event\rquote s sole object, fEvent, passes its base address to the Event Manager as the event record to use for all Mops events.  FEvent also contains 24 indexed cells, for the event types described above.  Each of these cells contains the xt of a word that handles the specific event type; you will find the source for these event handlers at the end of source file Event.  A word defined at the beginning of the source file ObjInit, called -MODELESS, initializes fEvent with the correct xts whenever Mops starts up.  This is accomplished by setting the System Vector OBJINIT to exe\-cute a word SYSINIT, which calls -MODELESS.  (The name, by the way, arises because Mops initially has no modeless dialogs.  In the source file Dialog+ there is a matching word +MODELESS which installs the event handling that is required if there is a modeless dialog active.)\par \pard\plain \s254\sb240\keepn \b\f21 Listening to events\par \pard\plain \s7\qj\sb120 \f20 The chief means by which you can cause Mops to listen to the event queue is by calling the Mops word KEY.  This causes class Event to enter a loop that requests the next event from the queue and executes the indexed cell corresponding to the event type.  Each handler word is responsible for leaving a boolean on the stack that tells class Event whether to return to the caller; currently, only Key-down and AutoKey events will trigger a return.  Other events are managed as they come, triggering menu choices, window activation or updating, and control selections.  To the original caller of KEY, all of this activity is invisible, because it will not resume ex\-ecution until a keystroke is received.  Thus, the caller of KEY enters a sort of \ldblquote suspended animation\rdblquote  while the Macintosh handles non-keystroke events.  This serves to separate the bulk of event management from the traditional, keystroke-oriented parts of your application, and was designed to simplify Macintosh program\-ming for those used to more conventional systems.\par \pard \s7\qj\sb120 As pointed out in chapter II.4, you might need to use the Mops word BECOME if you nest calls to KEY within several layers of code, because a menu or control choice could cause a new portion of the application to begin executing, and ultimately cause the system to run out of return stack.  An alternate structure is to do all keystroke processing via an infinite loop at the top of your application that calls KEY and executes the Key: method of the front window.  While less familiar to most of us, this architecture will probably result in a simpler application in the long run.\par \pard\plain \s254\sb240\keepn \b\f21 Specific event handling\par \pard\plain \s7\qj\sb120 \f20 Null events (all event types with the * above) can be used to execute the Idle: method for the front window.  The programmer should use a window\rquote s Idle: method to perform any background processing that is required for that particular window (such as call TEIdle in a text edit window).  The Idle: method should execute quickly so as not to bog down the responsiveness of the system to input.\par \pard \s7\qj\sb120 Mouse-down events are handled based on what window region the click occurred in (from FindWindow - see IM Window Manager).  Of the seven possible regions, only two are of real concern to the programmer, because Mops can take appropriate action for the others.  If the mouse is clicked in a close box, the window executes whatever action word you have installed in the window\rquote s CLOSE vector, just as a content region click will execute the window\rquote s CONTENT vector.  The Actions: method allows you to customize these two aspects of a window\rquote s mouse click handling.  You might also have to redefine the Grow: method for your windows if they require resizing of controls or other unique behavior; Grow: is executed in response to a grow-region click.\par \pard \s7\qj\sb120 The Key-down handler fetches the value of the key entered from the event record\rquote s Message field, first checking to see if the Command key was held down simultaneously.  If so, the Menu Manager is called to process a potential key-equivalent menu choice.  Key equivalents are thus managed automatically by Mops, requiring only that you specify the key equivalents in your menu item text definitions.  If the Command key was not held down, Mops returns to the word or method that called KEY with the value of the entered key on the stack.\par \pard \s7\qj\sb120 The Update handler sends a late-bound Draw: message to the corresponding window object, causing it to redraw its contents.\par \pard \s7\qj\sb120 The Disk-inserted handler takes the normal default action, which is to check if the system has already mounted the disk, which it will have attempted to do.  If the mount was unsuccessful, the handler calls the system routine DIBadMount to display the usual error message \ldblquote This disk is unreadable\rdblquote .  If you provide your own handler, put its xt in cell 7 of fEvent to process disk-inserted events.\par \pard \s7\qj\sb120 The Activate handler determines whether the event is an Activate or Deactivate, and sends the appropriate late-bound Enable: or Disable: message to the window involved.\par \pard\plain \s253\ri5760\sb360\sa240\keepn\brdrt\brsp240\brdrth \brdrb\brsp120\brdrs \b\f21 Event\par \pard\plain \s6\qj\sb120\sa240 \f20 Event associates a Toolbox event record with a dispatcher that executes a Mops word for each type of event received.   \par \pard\plain \s4\tx3600 \f20 Superclass\tab X-Array\par Source file\tab Event\par Status\tab Core\par Instance variables\par \pard\plain \s3\fi-3240\li3960\tx1800\tx3600 \f20\fs20 int\tab what\tab The named ivars comprise an eventRecord\emdash see IM.\par var\tab msg\par var\tab time\par var\tab loc\par int \tab mods\par int\tab mask\par \pard\plain \s4\tx3600 \f20 Indexed data\tab None\par System objects\par \pard\plain \s9\fi-2880\li3600\tx3600 \f20 fEvent \tab The system-wide Event object.\par \pard\plain \s250\fi-360\li360\phpg\posx20161\dxfrtext180 \f20 X-Array, Array, Indexed-Obj, Object\par \pard\plain \s11\sb120\keepn \b\f21 Methods\par \pard\plain \s252\li720\sb120\keepn \f21 accessing\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 type:  ( -- evt )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the type of the last event received.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 mods:  ( -- mods )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the value of the mods field.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 msg:  ( -- msg )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the value of the msg field.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 where:  ( -- point )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the position of the mouse as a global, packed Toolbox Point.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 msgID:  ( -- msgID )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the high-level message ID.  This is actually the same as the Loc field, but the different usage is made clear by the different name.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 when:  ( -- ticks )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the number of ticks (1/60ths of a second ) since system startup.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 set:  ( mask -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets the event mask.\par \pard\plain \s252\li720\sb120\keepn \f21 polling\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 next:  ( -- \'c9 b )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Gets next event out of event queue and executes the appropriate action vector, which leaves a boolean on the stack.  Some events (such as key events) may leave other information on the stack under the boolean, depending on the action handlers.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 key:  ( -- key )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Loops and polls the event queue (via next:) until a keystroke is received. During this time,  all other events will be handled auto\-matically as they come.\par \pard\plain \s11\sb120\keepn \b\f21 Error messages\par \pard\plain \s5\qj\li720\sb120 \f20 See messages for class X-Array.\par \pard\plain \s253\ri5760\sb360\sa240\keepn\brdrt\brsp240\brdrth \brdrb\brsp120\brdrs \b\f21 Mouse\par \pard\plain \s6\qj\sb120\sa240 \f20 Mouse integrates various Toolbox calls, providing easy access to the mouse\rquote s position in local coordi\-nates, the state of the mouse button, and whether a double-click has occurred.\par \pard\plain \s4\tx3600 \f20 Superclass\tab Object\par Source file\tab Event\par Status\tab Core\par Instance variables\par \pard\plain \s3\fi-3240\li3960\tx1800\tx3600 \f20\fs20 var\tab last\tab Ticks value when the last click occurred.\par var\tab interval\tab Ticks between this click and the last one.\par \pard\plain \s4\tx3600 \f20 Indexed data\tab None\par System objects\par \pard\plain \s9\fi-2880\li3600\tx3600 \f20 theMouse\tab ???\par \pard\plain \s250\fi-360\li360\phpg\posx20161\dxfrtext180 \f20 Object\par \pard\plain \s11\sb120\keepn \b\f21 Methods\par \pard\plain \s252\li720\sb120\keepn \f21 accessing\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 get:  ( -- x y but )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the mouse\rquote s local position and a boolean reflecting the state of the button.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 where:  ( -- x y )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the mouse\rquote s current position as a local Mops point.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 click:  ( -- b )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns 2 if last click was a double-click, 1 otherwise.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 put:  ( ticks -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Updates the click interval with the current sysTicks value.\par \pard\plain \s11\sb120\keepn \b\f21 Error messages\par \pard\plain \s5\qj\li720\sb120 \f20 None\par \pard\plain \s255\qc\li720\sb240\keepn \b\f21\fs36 \sect \sectd \sbkodd\linemod0\linex0\cols1\endnhere\titlepg {\headerl \pard\plain \s244\brdrb\brsp80\brdrhair \tqc\tx4680\tqr\tx9360 \f20 III-\chpgn \~Mops Predefined Classes\par }{\headerr \pard\plain \s244\brdrb\brsp80\brdrhair \tqc\tx4680\tqr\tx9360 \f20 \tab \tab Chapter 5\emdash Windows\~III-\chpgn \par }\pard\plain \s255\qc\li720\sb240\keepn \b\f21\fs36 Chapter 5\emdash Windows\par \pard\plain \s254\sb240\keepn \b\f21 About this chapter\par \pard\plain \s7\qj\sb120 \f20 This chapter describes the Mops classes and words that manage windows for the application.  Mops\rquote s win\-dow classes take away much of the burden of window management, providing the basis upon which you can build more detailed behavior.  Standard Macintosh window behavior, such as dragging, growing and updat\-ing, is handled automatically by Mops\rquote s Window and Window+ classes, freeing you to solve application-level problems instead of constantly having to rewrite system-level code for window management.\par \pard\plain \s254\sb240\keepn \b\f21 Recommended reading \par \pard\plain \f20 IM -  Event Manager\par IM -  Window Manager\par IM -  QuickDraw\par IM - Control Manager\par Mops - Events\par Mops - QuickDraw\par Mops - Views\par Mops - Controls\par \pard\plain \s254\sb240\keepn \b\f21 Source files\par \pard\plain \f20 Window\par WindowMod.txt\par Window+\par \pard\plain \s254\sb240\keepn \b\f21 Using windows\par \pard\plain \s7\qj\sb120 \f20 Mops provides two classes of window objects: class Window, built into the distributed Mops.dic image, provides basic behavior necessary for all windows, but does not include any management of views (or con\-trols, which are a view subclass).  Another class, Window+, adds the behavior necessary for windows with views.  Unless your application is a particularly \ldblquote quick and dirty\rdblquote  one, which just needs an extremely simple text-only output along the style of a dumb terminal, we recommend you use the Window+ class.  Lessons 18 and 19 of the Tutorial have already given an introduction to views, and how these interact with the Window+ class.\par \pard \s7\qj\sb120 Because a Macintosh window record incorporates a QuickDraw GrafPort as the first portion of its data, class Window is a sub\-class of class GrafPort, inheriting both the GrafPort data and three GrafPort-related methods (see the QuickDraw section of this manual).  \par \pard \s7\qj\sb120 Windows, like controls and certain other Toolbox objects, have a dual identity in that part of the object is known only to Mops, while another part is known both to Mops and to the Toolbox.  From the point of view of the Toolbox (and conventional languages like Pascal or C), a window is completely described by a win\-dow record.  A Mops window object packages the window record data within the larger context of the object\rquote s pri\-vate data, adding ivars to support the additional level of management that a Window object provides.  The result is that the programmer is confronted with a much simpler model using objects, because all of the \ldblquote boil\-erplate\rdblquote  kinds of behavior, such as dragging, growing, closing, updating and activation are handled within the window object itself rather than being thrown in with the application code.  That is how Mops is able to sim\-plify the logical model of the Toolbox and elevate it to a higher level, while still giving you the freedom to change any of the default behavior that occurs in such basic classes as Window.\par \pard \s7\qj\sb120 There are two ways to create a new window using the Toolbox: you can ask that the Toolbox allocate the window record on the heap, or you can provide the data area yourself.  Because a Mops window object includes a window record as its private data, it always uses the second of these methods, passing the address of its own data to the Toolbox as the storage to use for the window record.  Of course, if you have an appli\-cation in which windows come and go dynamically, so that you wish to allocate them on the heap, you can use the Mops ObjHandle mechanism to do so. \par \pard \s7\qj\sb120 The fact that an object allocates a window record as the first part of its data is important, because it simplifies the interaction between Mops and the Toolbox.  There are many cases in which Mops must determine which window is involved in event processing by calling the Toolbox, which will return a pointer to the window record.  If the window record were not part of the object, Mops would have to somehow derive the address of the object\rquote s data from the window record.  As it is, the window record is synonymous with the object\rquote s base address, making communication with the Toolbox much simpler.  Other Mops objects, such as Controls, do not have this luxury, and must take extra steps to derive the object address.\par Window objects add to the window record data a group of instance variables that keep track of the win\-dow\rquote s drag and grow characteristics, a boolean that tells whether the window is currently \ldblquote alive\rdblquote  with respect to the Toolbox, and a set of action \ldblquote hooks\rdblquote  that allow you to customize a window\rquote s behavior without necessarily having to create a subclass.  These action vectors hold the xts of Mops words to execute when the window is involved in a content click, an update event, an activate event, or selection of the close box.  The ClassInit: method of Window initializes the vectors to the xt of NULL, except for the activate vector, which is set to the xt of CLS (\ldblquote clear screen\rdblquote , which erases the viewing area of the window).\par \pard \s7\qj\sb120 For the Window+ class, which you should normally be using, you should leave the click handler and the up\-date handler set to NULL (which they will be initially anyway), since clicks and drawing are handled through our view mechanism.  You may, however, have a good reason to customize the activate or close handlers\emdash for example, you may need to change menu items depending on which windows are open or in front.\par \pard\plain \s254\sb240\keepn \b\f21 Creating windows\par \pard\plain \s7\qj\sb120 \f20 The steps involved in creating and using a window are as follows:  First, instantiate a window class (i.e. cre\-ate a window object), and then initialize the action vectors of the window using the actions: method.  For windows whose data exists in the dictionary or a module, this can occur at compile time:\par \pard\plain \s10\keep\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 \f22\fs18 \tab window  myWind\tab \tab \tab \\ create a new window object\line \tab xts\{ doClose doActivate null null \}  actions: myWind   \line \tab \tab \\  Set the close, activate, draw and content vectors\par \pard\plain \s7\qj\sb120 \f20 The Activate vector is executed when the window becomes active, and the Close vector is executed when the use clicks the Close box.  Typically, you will use both of these hooks to adjust items in your menus.\par \pard \s7\qj\sb120 The Draw vector is called when the window receives an update event, which is the Toolbox\rquote s way of telling the window to redraw itself.  Note however that drawing should now be done through our view mechanism, and not by setting the window\rquote s draw handler.  At the moment we are really only maintaining a draw handler for backward compatibility, and it will probably disappear in future.\par \pard \s7\qj\sb120 If the window is of class Window+, any views associated with the window will be redrawn automatically, since the DRAW: method for Window+, among other things, calls DRAW: on the contView, which causes DRAW: to be sent to all the views.\par Lastly, the Content vector is called when the user clicks the mouse in the window\rquote s content region.  Here again, you should now normally handle content clicks through the view mechanism\emdash the click handler may also disappear in future.\par \pard \s7\qj\sb120 You can also set the window\rquote s drag and grow characteristics at compile time, if the ClassInit: defaults do not suit your needs.  Each requires a boolean on the top of the stack reflecting whether the window is growable or draggable, and the four coordinates of a rectangle underneath the boolean if it is true.  For example:\par \pard\plain \s10\keep\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 \f22\fs18 \tab 10 10 500 300 true setDrag: myWind\line \tab false setGrow: myWind\par \pard\plain \s7\qj\sb120 \f20 causes myWind to be draggable, but not growable.  But note, in class Window, we actually ignore the rect\-angle coordinates passed in for setDrag: and setGrow:, and use a default value based on the size of the screen at the time the drag or grow is actually done.  This is probably more generally useful than using any fixed val\-ues for the drag or grow limits.  So unless you actually want fixed values and override these methods, you can just pass any four dummy values.\par When your application executes, you must send a New: message to the window to cause it to become active with the Toolbox and to draw itself on the screen.  New: requires a rectangle holding the dimensions of the window\rquote s frame, a title, a procID for the window type, and booleans reflecting whether the window should be visible when created and whether it should have a close box.  For instance:\par \pard\plain \s10\keep\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 \f22\fs18 \tab 10 10 300 200 put: tempRect\line \tab tempRect " A New Window" docWind true true new: myWind\par \pard\plain \s7\qj\sb120 \f20 would create a new document window using the dimensions stored in tempRect that would be visible and have a close box.  If you would rather define your window\rquote s characteristics using resources, you can call the GetNew: method to open the window using a template from a resource file. \par \pard \s7\qj\sb120 To get a feel for how Mops\rquote s window objects can be used, it is most instructive to look at an existing appli\-ca\-tion, such as grDemo.  Lessons 18, 19 and 20 of the Tutorial deal with grDemo, and lessons 18 and 19 in particular give a good introduction to the View and Window+ classes.\par Much of the code, as you will see, is concerned with initializing the various objects properly;  much of the actual work is accomplished internally to the methods already defined for those objects.\par \pard\plain \s253\ri5760\sb360\sa240\keepn\brdrt\brsp240\brdrth \brdrb\brsp120\brdrs \b\f21 Window\par \pard\plain \s6\qj\sb120\sa240 \f20 Window is the basic class of windows without controls.\par \pard\plain \s4\tx3600 \f20 Superclass\tab GrafPort\par Source file\tab WindowMod.txt\par Status\tab Core\par Instance variables\par \pard\plain \s3\fi-3240\li3960\tx1800\tx3600 \f20\fs20 32 bytes\tab wind1\tab Unstructured data for the window record.\par handle\tab CtlList\tab Windows control list\par 12 bytes\tab wind2\tab Unstructured data for the window record.\par rect\tab contRect\tab The rectangle defining the content region.\par rect\tab growRect\tab Contains the window\rquote s current grow limits.\par rect\tab dragRect\tab Contains the window\rquote s current drag limits.\par int\tab growFlg\tab True if the window is growable.\par int\tab dragFlg\tab True if the window is draggable.\par int\tab Alive\tab True if the window is alive in the Toolbox.\par var\tab Idle\tab The window\rquote s idle event action vector.\par var\tab Deact\tab The window\rquote s deactivate event action vector.\par var\tab Content\tab The window\rquote s content click action vector.\par var\tab Draw\tab The window\rquote s update event action vector.\par var\tab Enact\tab The window\rquote s activate event action vector.\par var\tab Close\tab The window\rquote s close box action vector.\par int \tab ResID\tab Resource id for GetNewWindow.\par \pard\plain \s4\tx3600 \f20 Indexed data\tab None\par System objects\par \pard\plain \s9\fi-2880\li3600\tx3600 \f20 fWind \tab The Mops system window used by the nucleus.\par \pard\plain \s250\fi-360\li360\phpg\posx20161\dxfrtext180 \f20 GrafPort, Object\par \pard\plain \s11\sb120\keepn \b\f21 Methods\par \pard\plain \s252\li720\sb120\keepn \f21 setting characteristics\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 setContRect:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets the content rectangle after the window has been resized.  Also sets Mops\rquote s scrolling rectangle, used by CR, equal to the content rectangle.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 setGrow:  ( l t r b T or F -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets the window\rquote s grow limits.  The old action was that if the boolean was true, the rectangle coordinates deter\-mined the mini\-mum and maximum x and y values that the window could be grown.  However the current action is to ignore these coordinates and use a SCREENBITS call instead.  If the boolean is false, the window will not be growable.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 setDrag:  ( l t r b T or F -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets the window\rquote s drag limits.  The old action was that if the boolean was true, the rectangle coordinates deter\-mined the mini\-mum and maximum x and y values that the window could be dragged.  However the current action is to ignore these coordinates and use a SCREENBITS call instead.   If the boolean is false, the window will not be draggable.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 setScroll  ( b -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 The passed-in boolean indicates whether scrolling is enabled for this window or not.  This is primarily intended for the Mops win\-dow fWind, which supports scrolling text, and uses the temporary rectangle fpRect for this purpose.  If a window doesn\rquote t support scrolling, then fpRect won\rquote t be altered when that window is active, so you can use it for your own purposes without conflict.\par \pard \s2\qj\li3600\sb120\sbys Note however, that the \ldblquote proper\rdblquote  way to support scrolling text is via a Scroller view within a Window+.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 setIdle:  ( xt -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets the word which will execute in response to idle messages to the window.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 set:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets the window\rquote s grafPort as the current grafPort, and calls setView to update the content rect.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 select:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Makes this window the frontmost, active window.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 size:  ( w h -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets the dimensions of the window to the given width and height, without moving the window\rquote s upper-left corner.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 setSize:  ( w h -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 The same as size:\emdash this is for naming consistency with Rects and Views.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 move:  ( x y -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Moves the upper-left corner of the window to global coordinates x and y without changing its size.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 center:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Centers the window on the screen.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 show:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Calls ShowWindow to make the window visible.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 hide:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Calls HideWindow to make the window invisible.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 actions:  ( close enact draw content 4 -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets action vectors with the xts provided.  We require an xt count (4 in this case) as this is standard for all actions: methods.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 setAct:  ( enact deact -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets the activate and deactivate vectors with the xts provided.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 setDraw:  ( drawXt -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets only the Draw action vector.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 title:  ( addr len -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets the title of the window to the passed-in string.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 name:  ( addr len -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 An alias for title: (above).\par \pard\plain \s252\li720\sb120\keepn \f21 querying\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 getName:  ( -- addr len )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the window\rquote s title string.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 getRect:  ( -- l t r b )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the window\rquote s port rectangle coordinates.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 getVSRect:  ( -- l t r b )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the window\rquote s default vertical scroll bar rectangle coordi\-nates.  (Does not require a scroll bar to be present, but if it were, this is where it would be).\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 getHSRect:  ( -- l t r b )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the window\rquote s default horizontal scroll bar rectangle coordinates.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 maxX:  ( -- x )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the x coordinate value which the top left corner of the win\-dow would have if the window were to be moved all the way to the right of the current screen (so the window\rquote s right hand edge would coincide with the right of the screen).  Thus it is the maximum x coordinate value which the window could have without being in any way obscured.  Doesn\rquote t actually move the window.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 maxY:  ( -- y )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Likewise, returns the y coordinate value which the top left corner of the window would have if the window were to be moved all the way to the bottom of the current screen.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 active:  ( -- b )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns true if the window is currently active.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 alive:  ( -- b )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns true if the window is currently alive in the Toolbox.\par \pard\plain \s252\li720\sb120\keepn \f21 event handling\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20  draw:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 This method is executed when an update event occurs for the win\-dow.  If the win\-dow is growable, a grow icon is drawn with scroll bar delimiters.  The window\rquote s Draw action vector is executed.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 idle:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 This method may be used for background processing.  Whenever fEvent gets a null event out of the event queue (for instance, while waiting for the user to type a char\-acter) a late-bound idle: message is sent to the front (active) window.  That win\-dow\rquote s idle: method can then do any background processing necessary (such as updat\-ing a clock picture).  The idle method defaults to a do-nothing method in class Window, and should be kept short enough to keep from bogging down responsive\-ness to user input. \par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 enable:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 This method is executed when an activate event occurs for the win\-dow.   The win\-dow\rquote s Enact action vector is executed. \par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 disable:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 This method is executed when a deactivate event occurs for the window.  Does nothing in class Window.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 update:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Forces an update event to occur that will redraw the entire window.   The window will not actually be redrawn until  KEY is called and event handling is active.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 close:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 This method is executed when the user clicks the window\rquote s close box.  The win\-dow\rquote s Close action vector is executed, and CloseWindow is called.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 release:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 The same as close:\emdash this is our standard destructor name.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 drag:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 This method is executed when a mouse-down event occurs in the window\rquote s drag region.  The Toolbox is called to pull a gray outline around with the mouse.  If inac\-tive, the window is made active after dragging.  \par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 zoom:  ( part -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 This method is executed in response to a click in the zoom box.  part is supplied by the system when the Event code calls FindWindow\emdash it will be 7 if the window is to be zoomed in, or 8 if it is to be zoomed out.  Note that although this method is included in class Window, the remainder of zoomable window support is in class Window+, so a zoomable window should therefore be a Window+.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 grow:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 This method is executed when a mouse-down event occurs in the window\rquote s grow region.  The Toolbox is called to pull a gray out\-line around with the mouse.  If inac\-tive, the window is made active after growing.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 content:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 This method is executed when a mouse-down event occurs in the window\rquote s con\-tent region.  The window\rquote s Content action vector is executed.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 key:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 This method can be used to provide window-specific keystroke handling.  The key: method in class Window simply does a DROP.  See Chapter II.4 for more informa\-tion.\par \pard\plain \s252\li720\sb120\keepn \f21 object creation\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 new:  ( ^rect tAddr tLen procID visible goAway -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Calls the Toolbox to create a new window using this object\rquote s data as the window record.  Parameters determine the window\rquote s bounds in global coordinates, the title, the type ( procID -- see dlgWind, docWind, rndWind) of window, and whether it is visible and has a close box.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 getNew:  ( resID -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Same as new:, but uses the resource template with resource id resID.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 classinit:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 All objects of class Window are initially set to non-growable, non-draggable windows with null action vectors except for Draw, which is set to the xt of CLS.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 test:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Creates a test object of class Window.\par \pard\plain \s11\sb120\keepn \b\f21 Error messages\par \pard\plain \s5\qj\li720\sb120 \f20 None\par \pard\plain \s253\ri5760\sb360\sa240\keepn\brdrt\brsp240\brdrth \brdrb\brsp120\brdrs \b\f21  Window+\par \pard\plain \s6\qj\sb120\sa240 \f20 Window+ adds support for views, and also zooming.  Unless your window is to be very basic indeed, you should use this class.\par \pard\plain \s4\tx3600 \f20 Superclass\tab Window\par Source file\tab Window+\par Status\tab Optional\par Instance variables\par \pard\plain \s3\fi-3240\li3960\tx1800\tx3600 \f20\fs20 ptr\tab ^contView\tab Pointer to the ContView\emdash  the view consisting of the whole contents of the window.\par \pard \s3\fi-3240\li3960\tx1800\tx3600 bool\tab zoomFlg\tab True if this window is to be zoomable.\par \pard\plain \s4\tx3600 \f20 Indexed data\tab None\par System objects\tab None\par \pard\plain \s250\fi-360\li360\phpg\posx20161\dxfrtext180 \f20 Window, Grafport, Object\par \pard\plain \s11\sb120\keepn \b\f21 Methods\par \pard\plain \s252\li720\sb120\keepn \f21 accessing\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 setZoom:  ( b -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Passed-in boolean indicates if this window will be zoomable.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 getView:  ( -- ^view )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns a pointer to the ContView.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 setView:  ( ^view -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets the ContView.\par \pard\plain \s252\li720\sb120\keepn \f21 event handling\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 grow:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Handles a click in the grow box.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 zoom:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Handles a click in the zoom box.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 enable:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Handles an activate event.  Sends enable: to the Contview, which causes enable: to be sent to all child views as well.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 disable:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Handles a deactivate event.  Sends disable: to the Contview, which causes disable: to be sent to all child views.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 content:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Handles a click in the content region of the window.  Checks for a hit on a control.  If it wasn\rquote t a control hit, then click: is sent to the ContView.  This causes click: to be sent to any child views, until the view is found which actually contains the clicked position.  The Click handler of this view is then executed.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 draw:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Draws the window with its controls.  draw: is sent to the ContView, which causes draw: to be sent to all child views.  Any custom drawing should be done via the Draw handlers in the views.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 idle:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 As for idle: in class Window, but also sends an idle: method to the ConView, which causes idle: to be sent to all child views. \par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 close:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Handles a click in the close box.  Sends release: to the ContView, which causes  release: to be sent to all child views.  The storage for any controls is released via a KillControls call.  Finally the window is closed and its storage released.\par \pard\plain \s252\li720\sb120\keepn \f21 object creation\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 new:  ( ^rect tAddr tLen procID vis goAway ^view -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 As for new: on class Window, except there is one additional parameter, a View pointer.  This View will become the ContView.  init: is called on this ContView, setting its ViewRect to the contents rectangle of the window.   new: is then called on the ContView, which causes new: to be called on all child views and controls.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 getnew:  ( resID ^view -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 As for new:, but the window data comes from the resource given by resID.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 test:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Creates a test window.\par \pard\plain \s11\sb120\keepn \b\f21 Error messages\par \pard\plain \s5\qj\li720\sb120 \f20 None\par \pard\plain \s255\qc\sb240\keepn \b\f21\fs36 \sect \sectd \sbkodd\linemod0\linex0\cols1\endnhere\titlepg {\headerl \pard\plain \s244\brdrb\brsp80\brdrhair \tqc\tx4680\tqr\tx9360 \f20 III-\chpgn \~Mops Predefined Classes\par }{\headerr \pard\plain \s244\brdrb\brsp80\brdrhair \tqc\tx4680\tqr\tx9360 \f20 \tab \tab Chapter 6\emdash Views and Controls\~III-\chpgn \par }\pard\plain \s255\qc\sb240\keepn \b\f21\fs36 Chapter 6\emdash Views and Controls\par \pard\plain \s254\sb240\keepn \b\f21 About This Chapter\par \pard\plain \s7\qj\sb120 \f20 This chapter describes views, which are also used by MacApp, TCL, PowerPlant, the Newton, and most other OOP development systems for GUI (graphical user interface) platforms.  A view basically defines a rectangular area within a window, within which drawing may take place.  For those familiar with MacApp or TCL, there is a small difference in that in those systems a window is itself a view.  In Mops, a window isn\rquote t a view, but contains a view or views.\par \pard \s7\qj\sb120 Our basic Window class doesn\rquote t support views at all; for this you will need the Window+ class.  Although you may draw directly in a Window via its Draw handler, we are now trying to discourage this.  We don\rquote t even guarantee that in future windows will continue to have their own Draw handlers\emdash in fact they probably won\rquote t!\par \pard \s7\qj\sb120 You should now use a view within a Window+, and draw either by overriding the DRAW: method for the view, or by using its draw handler.  This will give you much greater flexibility as to what you can do within the window.  This comes about because a view can contain any number of child views.  A child view is another view, but is constrained to be drawn within its parent view.\par \pard \s7\qj\sb120 Class Control, which in earlier versions of Mops was an independent class, is now a subclass of View.\par \pard\plain \s254\sb240\keepn \b\f21 Recommended reading \par \pard\plain \f20 Mops - Windows\par \pard\plain \s254\sb240\keepn \b\f21 Source Files\par \pard\plain \f20 View\par \pard\plain \s254\sb240\keepn \b\f21 Using Views\par \pard\plain \s7\qj\sb120 \f20 A view must have an owning window.  A view has an associated rectangular area within which anything owned by a view is drawn, including any child views.\par \pard \s7\qj\sb120 A Window+ contains one special view (the ContView) which covers the whole drawing area of the window (excluding any scroll bars).  All other views within the Window+ must be child views of the ContView (or child views of those child views, etc.).\par \pard \s7\qj\sb120 The rectangular area of a view is defined in an ivar which is a rect, ViewRect.  To be precise, this rectangle defines the outer boundary of this view, relative to the current grafPort.  This rect is used by its owning view to set the clip region and the coordinate origin before calling any method on the view.\par \pard \s7\qj\sb120 However, as we saw in the Tutorial in lesson 18, you will normally specify the size and position of a view by setting the bounds and justification for the four sides.  Please see that Tutorial lesson for a full rundown of the various options you have.\par \pard\plain \s254\sb240\keepn \b\f21 Using Controls\par \pard\plain \s7\qj\sb120 \f20 Mops defines a generic Control class, which is a subclass of View, and then has subclasses for the different kinds of standard control\emdash Button, Checkbox, RadioButton, Vscroll and Hscroll.\par Since a control is a view, in order to use controls within your application, you must use a Window+ or a subclass of Window+, since these are necessary to support views.\par \pard \s7\qj\sb120 As is the case with other Toolbox objects (such as Windows) control objects have a dual identity.  Part of the control\rquote s data is maintained by the Toolbox on the heap, and can be accessed by the application via a handle.  If you were writing in a conventional language, such as C or Pascal, you would consider the handle to be the control, and you would have to build a lot of structure into your code to support the user\rquote s selec\-tion of the various parts of the control.  Mops, on the other hand, combines the control\rquote s Toolbox-related data with its own View-related data to comprise a single object that contains all it needs to know about managing the vari\-ous actions that can occur.  You need only instantiate and initialize the object properly, and it takes care of the rest.  Even much of the initialization is handled automatically via the View class.\par \pard \s7\qj\sb120 Controls store the xts of Mops words as action vectors that will be executed when the various parts of the control are selected.  Simple controls (class Control) have a single action vector, while scroll bars have 5.  You can use these classes as a model for defining your own control classes if you wish to define new types.\par When you click in a control, the control object receives a click: message as part of the normal view handling.  The click: method in class Control then calls the Toolbox routine FindControl to identify which part of the control has been clicked.  After that, two different things may happen, depending on the control type and part number affected.\par \pard \s7\qj\sb120 For  buttons, check boxes and scroll bar thumbs, the control is high\-lighted while the button remains de\-pressed, but no other action is taken.  The Toolbox routine TrackControl takes care of highlighting the correct control part while the mouse is in its proximity and the button is down.  When the button is released, a late-bound exec: message is sent to the control object, causing it to execute its action handler for the correct part.\par \pard \s7\qj\sb120 For the other parts of a scroll bar, however, it is desirable that a custom routine be executed while the button is held down in the part.  For instance, while you hold down the button in the up arrow of a scroll bar, an edi\-tor should gradually scroll the document in small increments until the button is released.  This can be accom\-plished by passing a procedural argument to the TrackControl routine, but the procedure must look like a Pascal procedure rather than a Mops word.  Mops contains a special compiler that packages Mops words in a way that makes them look like Pascal procedures (:PROC ... ;PROC).  We have created one of these proce\-dures to execute the action vector of a control repeatedly while the mouse button is down, and Mops passes this procedure to TrackControl in the case of the non-thumb scroll bar parts.  Whatever actions you have defined for these parts will be executed while the part is being selected.\par \pard \s7\qj\sb120 We have also provided a subclass of View named Scroller, which provides for a vertical and horizontal scroll bar along the edges of the view, with action vectors already defined for you.\par \pard\plain \s11\sb120\keepn \b\f21 Creating control objects\par \pard\plain \s7\qj\sb120 \f20 Defining a control object requires three steps.  First, instantiate the object with a phrase like:\par \pard\plain \s10\keep\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 \f22\fs18 \tab button saveBtn\par \pard\plain \s7\qj\sb120 \f20 You should then initialize the newly created object to assign it a position and a title.  For example: \par \pard\plain \s10\keep\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 \f22\fs18 \tab 100 250 " Save"  init: saveBtn\line \tab ' doSave  actions: saveBtn\par \pard\plain \s7\qj\sb120 \f20 Here we define saveBtn as a Button, specify that its top left corner will be be at coordinates (100, 250) rela\-tive to the view that it will appear in, and give it a title.  Then we set doSave as its action word.  DoSave will be executed if the user releases the mouse button while the mouse is within saveBtn\rquote s control rectangle.  Finally, when the program executes, we must use addView: to add the control to its parent view\rquote s list of child views.  Then when we fire up the window with new: or getNew:, the control will automatically receive a new: message which will cause it to create a Toolbox Control record on the heap and draw itself.\par \pard \s7\qj\sb120 Control action words often need a way to determine which control they have been dispatched from.  For example, a common action taken in scroll bar arrows is to get the control\rquote s value, add some increment to it, and put the new value in the control.  This could be done in the following manner:\par \pard\plain \s10\keep\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 \f22\fs18 \tab : doUpArrow   get: thisCtl  1-  put: thisCtl  -1 scroll: theText ;\par \pard\plain \s7\qj\sb120 \f20 In this example, the word thisCtl is actually a Value that Mops provides as a simple way for a control action word to derive its owning control object.  Mops automatically compiles a late-bound reference when a Value is used as the receiver of a message, and in this case thisCtl contains the control object\rquote s address.  This allows you to write very general action words that can be assigned to several different control objects simultaneously.\par \pard\plain \s254\sb240\keepn \b\f21 Design issues\par \pard\plain \s7\qj\sb120 \f20 Because late-bound messages must be sent to controls and windows, these objects cannot be defined as nor\-mal named ivars, because to do so would fail to provide a class pointer for the runtime method lookup.  If you wish to make a control or window an ivar, you will need to define a subclass with the General attribute, then use that class.  However you don\rquote t need to do this with Vscroll or Hscroll, since these have already been defined as General.\par \pard \s7\qj\sb120 Late binding is necessary because there are cases in which the Toolbox returns the address of an object to the application, but is is undesirable to make any assumptions about the actual class of the object.  For instance, when you click the mouse button, the Toolbox call FindWindow tells you in which window the click occurred.  This requires that a Content: message be sent to the object, but because the programmer is free to define subclasses of class Window, there is no way to know ahead of time what class the window object belongs to.\par \pard\plain \s11\sb120\keepn \b\f21 Dialogs\par \pard\plain \s7\qj\sb120 \f20 Mops implements controls in dialogs differently than in normal windows.  Since dialogs rely heavily upon resource definitions and don\rquote t usually occasion much interaction with the items themselves other than getting or setting values,  Mops does not build dialog control items as objects, but rather accesses them through methods in the Dialog class itself.  This saves a lot of space, and actually simplifies the interface for the pro\-grammer.\par \pard\plain \s253\ri5760\sb360\sa240\keepn\brdrt\brsp240\brdrth \brdrb\brsp120\brdrs \b\f21 View\par \pard\plain \s6\qj\sb120\sa240 \f20 description ???\par \pard\plain \s4\tx3600 \f20 Superclass\tab Object\par Source file\tab View\par Status\tab Optional\par Instance variables\par \pard\plain \s3\fi-3240\li3960\tx1800\tx3600 \f20\fs20 rect\tab viewRect\tab Bounding rectangle, rel to grafport.\par rect\tab bounds\tab We use this to set the viewRect\par ptr\tab ^parent\tab Points to parent (containing) view\par ptr\tab ^myWind\tab Points to owning window\par ptrList\tab children\tab List of child views \par x-addr\tab draw\tab Draw handler\par x-addr\tab clickHndlr\tab Click handler\par bool\tab alive?\par bool\tab enabled?\par bool\tab wantsClicks?\tab True if we can accept clicks\par bool\tab setClip?\tab True if we need to set the clip (default)\par \pard \s3\fi-3240\li3960\tx1800\tx3600 bool\tab measureFromMe?\tab True if other siblings are to use this view for sibling relative justification modes\par \pard \s3\fi-3240\li3960\tx1800\tx3600 byte\tab #updates\tab Counts number of pending updates\par byte\tab Ljust\tab Left justification\par byte\tab Tjust\tab Top\par byte\tab Rjust\tab Right\par byte\tab Bjust\tab Bottom\par \pard\plain \s4\tx3600 \f20 Indexed data\tab None\par System objects\tab None\par \pard\plain \s250\fi-360\li360\phpg\posx20161\dxfrtext180 \f20 Object\par \pard\plain \s11\sb120\keepn \b\f21 Methods\par \pard\plain \s252\li720\sb120\keepn \f21 accessing\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 getViewRect:  ( -- l t r b )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the viewRect coordinates.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 ^viewRect:  ( -- addr )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the address of the viewRect object.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 bounds:  ( -- l t r b )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the bounds coordinates.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 getBounds:  ( -- l t r b )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 A synonym.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 getJust:  ( -- lj tj rj bj )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the current justification values for the four sides in the usual order.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 enabled?:  ( -- b )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns true if this view is enabled.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 window:  ( -- ^wind )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the address of the owning window object.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 setWindow:  ( ^wind -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets the owning window to the window whose address is passed in.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 wantsClicks:  ( b -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets the wantsClicks? ivar to the passed-in boolean value.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 setClick:  ( xt -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets the click action vector, and sets wantsClicks? to true.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 setDraw:  ( ??? -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets the draw action vector.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 setParent:  ( ^view -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets the parent view address (which is stored in the ivar ^parent).\par update:  ( ??? ) \tab Generates an update event for the view.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 clear:  ( ??? )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Clears the view.\par \pard\plain \s252\li720\sb120\keepn \f21 View positioning\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 bounds>viewRect:  ( ??? )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Used internally by the view mechanism.  Uses the current bounds and justification values to set the viewRect.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 childrenMoved:  ( ??? )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Used internally by the view mechanism.  Signals this view that its children\rquote s positions have to be recomputed.  Causes this view to send moved: to all its children (see below).\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 moved:  ( ??? )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Called when something has happened to change the position of this view (such as the parent view moving, or the bounds or justifica\-tion parameters changing), requiring the viewRect to be recom\-puted.  This method calls bounds>viewRect: self and childrenMoved: self.\par \pard\plain \s252\li720\sb120\keepn \f21 object creation\par \pard\plain \s7\qj\sb120 \f20 Note that addview: must be called at run time, since a view\rquote s address is passed in.  new: is called at run time, once this view\rquote s parent view already exists.  However, new: is normally called automatically, when new: is sent to the owning Window+ object.  The Window+ calls new: on its contView, and everything continues from there, since new: on a view calls new: on all its child views.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 setJust:  ( lj tj rj bj -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets the justification values for the four sides in the usual order.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 setBounds:  ( l t r b -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets the bounds for the four sides in the usual order.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 measureFrom:  ( b -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets the MeasureFromMe? ivar.  If set True, this view will be used as a reference if any of its siblings use sibling-relative justification.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 addview:  ( ^view -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Adds the passed-in view to this view\rquote s list of child views.  This method can only be called at run time.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 new:  ( ^view -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Fires up the view at run time, and calls new: on all its child views.  The passed-in view is the containing view of this view, or nilP if there is none (i.e. this is the ContView of a window).  Note that new: is normally called automatically via a new: on the owning Window+.\par \pard\plain \s252\li720\sb120\keepn \f21 manipulation\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 release:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Releases this view and all its child views.  This too is normally called automatically via a release: on the owning Window+.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 classinit:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets the initial defaults.  SetClip? and WantsClicks? are set True.  The justification values are set to parLeft, parTop, parLeft, parTop.\par \pard\plain \s252\li720\sb120\keepn \f21 display\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 draw:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Draws the view (and all its child views).  The setting up and wind\-ing up is done via the callFirst/callLast mechanism, and here in class View itself the only other action that draw: takes is to execute the Draw handler.  Please see the comments in the source code for more detail.\par \pard\plain \s252\li720\sb120\keepn \f21 event handling\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 idle:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Called when idle: is sent to the owning window.  Does nothing in class View itself, except to call idle: on all the child views.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 click:  ( -- b )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Called when a click has occurred in the owning window\rquote s content area.  Returns True if the click was actually in this view (or one of its child views), otherwise returns False.  If the click was in this view itself (not in a child view), the Click handler is executed.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 key:  ( c -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Called when a key event has occured and this view\rquote s window is in front.  Does nothing in class View itself, except to call key: on all the child views.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 enable:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Enables the view.  Called from Window+ when the window is enabled.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 disable:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Disables the view.  Called from Window+ when the window is disabled.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 drawX:  ( ??? )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Can be useful in debugging, when you want to see the view but don\rquote t have \ldblquote real\rdblquote  drawing code yet.  It just draws a big X across the view area, joining the diagonally opposite corners.\par \pard\plain \s11\sb120\keepn \b\f21 Error messages\par \pard\plain \s5\qj\li720\sb120 \f20 None\par \pard\plain \s253\ri5760\sb360\sa240\keepn\brdrt\brsp240\brdrth \brdrb\brsp120\brdrs \b\f21 Control\par \pard\plain \s6\qj\sb120\sa240 \f20 Control is a generic superclass for controls.\par \pard\plain \s4\tx3600 \f20 Superclass\tab View\par Source file\tab Ctl\par Status\tab Optional\par \pard\plain \f20 instance variables \par \pard\plain \s3\fi-3240\li3960\tx1800\tx3600 \f20\fs20 int\tab procID\tab The control definition ID for the Toolbox.\par int\tab resID\tab The control\rquote s resource ID.\par handle\tab CtlHndl\tab Handle to the control record.\par int\tab myValue\tab Contains a copy of the numeric value of the control.\par int\tab titleLen\tab Length of the control\rquote s title.\par 32 bytes\tab title\tab The text of the title.\par \pard\plain \s4\tx3600 \f20 Indexed data\tab None \par System objects\tab None\par \pard\plain \s250\fi-360\li360\phpg\posx20161\dxfrtext180 \f20 View, Object\par \pard\plain \s11\sb120\keepn \b\f21 Methods\par \pard\plain \s252\li720\sb120\keepn \f21 accessing\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 putResID:  ( resID -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Stores the resource ID for the control.  Used if the control is defined via a resource.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 get:  ( -- val )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the value of the control.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 put:  ( val -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets the value of the  control.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 handle:  ( -- hndl )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the control handle.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 setTitle:  ( addr len -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets title of control.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 getTitle:  (  -- addr len )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Gets title of control.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 exec:  ( part# -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Executes the control\rquote s action handler. \par \pard\plain \s252\li720\sb120\keepn \f21 manipulation\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 moved:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 As for moved: on the superclass View, but also contains a call to MoveControl to inform the system of the control\rquote s new position.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 hilite:  ( hiliteState -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Hilights, disables, or enables  the entire control. \par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 enable:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Enables the control.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 disable:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Disables the control.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 hide:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Calls Toolbox HideControl. \par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 show:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Calls Toolbox ShowControl.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 click:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 As for click: on the superclass View, but contains some necessary toolbox calls as described above in the introduction to this class.\par \pard\plain \s252\li720\sb120\keepn \f21 object creation \par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 new:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 As for new: on the superclass View, but contains a call to NewControl to create a new control in the Toolbox for this control object.  The initial value is 0, and the range is 0 to 1.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 getnew:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 As for new:, but uses a resource.  The resource ID must already have been set via putResID:.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 release:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Releases the control handle, then calls release: super to do the nor\-mal View releasing action.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 classinit:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets default control to type \ldblquote button\rdblquote  with null click action, and a zero length title.\par \pard\plain \s252\li720\sb120\keepn \f21 display\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 draw:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 As for draw: on the superclass View, but contains a call to Draw1Control so that the system will do the actual drawing of the control.\par \pard\plain \s11\sb120\keepn \b\f21 Error messages\par \pard\plain \s5\qj\li720\sb120 \f20 None\par \pard\plain \s253\ri5760\sb360\sa240\keepn\brdrt\brsp240\brdrth \brdrb\brsp120\brdrs \b\f21 TitledCtl\par \pard\plain \s6\qj\sb120\sa240 \f20 TitledCtl just adds a convenient init: method for setting up a control with a title, where the width of the con\-trol\rquote s rect is determined by what the title is.  We assume the font will be Chicago and the height of the control is 20.  This may be overridden in subclasses as necessary.\par \pard\plain \s4\tx3600 \f20 Superclass\tab Control\par Source file\tab Ctl\par Status\tab Optional\par Instance variables\tab None (see Ctl)\par \pard \s4\tx3600 Indexed data\tab None\par System objects\tab None\par \pard\plain \s250\fi-360\li360\phpg\posx20161\dxfrtext180 \f20 Control, View, Object\par \pard\plain \s11\sb120\keepn \b\f21 Methods\par \pard\plain \s252\li720\sb120\keepn \f21 object creation\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 init:  ( x y addr len -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Initializes the control (may be done at compile time).  Sets up the control with a title.  x and y are the initial top left Bounds values (using whatever justification is in effect).  (addr len) gives the title.\par \pard\plain \s11\sb120\keepn \b\f21 Error messages\par \pard\plain \s5\qj\li720\sb120 \f20 None\par \pard\plain \s253\ri5760\sb360\sa240\keepn\brdrt\brsp240\brdrth \brdrb\brsp120\brdrs \b\f21 Button, RadioButton, CheckBox\par \pard\plain \s6\qj\sb120\sa240 \f20 Button, RadioButton and CheckBox provide support for those types of control.  The only change to TitledCtl is the customization of classinit: to set the appropriate proc ID so that the system will draw the right kind of control.\par \pard\plain \s4\tx3600 \f20 Superclass\tab TitledCtl\par Source file\tab Ctl\par Status\tab Optional\par Instance variables\tab None\par indexed data\tab None\par \pard\plain \s250\fi-360\li360\phpg\posx20161\dxfrtext180 \f20 TitledCtl, Control, View, Object\par \pard\plain \s11\sb120\keepn \b\f21 Methods\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 classinit:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Initializes the control with the appropriate proc ID.\par \pard\plain \s11\sb120\keepn \b\f21 Error messages\par \pard\plain \s5\qj\li720\sb120 \f20 None\par \pard\plain \s253\ri5760\sb360\sa240\keepn\brdrt\brsp240\brdrth \brdrb\brsp120\brdrs \b\f21 Vscroll, Hscroll\par \pard\plain \s6\qj\sb120\sa240 \f20 Vscroll and Hscroll provide support for vertical and horizontal scroll bars.  Class Hscroll is set up as a sub\-class of Vscroll, and just overrides classinit: to set the ivar horiz? to true.  It takes no other special action.\tab Several methods interrogate this ivar and do the appropriate thing.\par \pard\plain \s4\tx3600 \f20 Superclass\tab Control\par Source file\tab Ctl\par Status\tab Optional\par Instance variables\par \pard\plain \s3\fi-3240\li3960\tx1800\tx3600 \f20\fs20 int\tab min\tab The current minimum value for the control.\par int\tab max\tab The current maximum value.\par  5  ordered-col\tab parts\tab Give the part IDs for the various parts of a scroll bar.\par  5  x-array\tab actions\tab The corresponding action handlers.\par bool\tab horiz?\tab True if this is a horizontal scroll bar; false if vertical scroll bar.\par \pard\plain \s4\tx3600 \f20 Indexed data\tab None\par System objects\tab None\par \pard\plain \s250\fi-360\li360\phpg\posx20161\dxfrtext180 \f20 Control, View, Object\par \pard\plain \s11\sb120\keepn \b\f21 Methods\par \pard\plain \s252\li720\sb120\keepn \f21 accessing\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 actions:  ( up dn pgUp pgDn thumb 5 -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets up the action handlers for the 5 parts.  up etc. are xts, and we require a 5 on top of the stack as an xt count, as for all actions: methods.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 put:  ( val -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets the value of the scroll bar.  The value is coerced to not fall outside the current minimum and maximum.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 putMax:  ( val -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets the maximum value.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 putMin:  ( val -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets the minimum value.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 putRange:  ( lo hi -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets the minimum and maximum.\par \pard\plain \s252\li720\sb120\keepn \f21 object creation\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 init:  ( top left len -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Initializes the scroll bar (may be done at compile time).\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 new:  ( ^view -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Creates a new control in the Toolbox for this scroll bar object.  ^view is the address of the owning view, within which the control will appear.  new: will normally be called automatically when new: is done on the view.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 getNew:  ( resID ^view -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Creates a new control in the Toolbox for this scroll bar object, using a resource.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 classinit:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets action handlers to null and selects scrollbar type control.\par Class Hscroll is set up as a subclass of Vscroll, and overrides classinit: to set the ivar horiz? to true.  It takes no other special action.\par \pard\plain \s252\li720\sb120\keepn \f21 display\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 disable:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets entire control to 255 hiliting (disabled).\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 enable:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets entire control to enabled hiliting.\par \pard\plain \s252\li720\sb120\keepn \f21 execution\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 exec:  ( part# -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Called from the event handling code when there is a mouse-down in the given part of the scroll bar.  Executes the corresponding action handler.\par \pard\plain \s11\sb120\keepn \b\f21 Error messages\par \pard\plain \s5\qj\li720\sb120 \f20 None\par \pard\plain \s253\ri5760\sb360\sa240\keepn\brdrt\brsp240\brdrth \brdrb\brsp120\brdrs \b\f21 Scroller\par \pard\plain \s7\qj\sb120 \f20 Scroller is a view which has support for a vertical and horizontal scroll bar along the right hand and bottom edge respectively.  We implement it with three child views: mainView, which is the display area, and the two scroll bars themselves.  These child views are ivars of Scroller.  MainView is an instance of a one-off class, Mview.  This class has a rectangle, PanRect, which normally ought to enclose all the child views of the Mview.  The usual scenario is that PanRect is larger than the viewRect, and scrolling amounts to shifting the child views (and PanRect) around within the viewRect\emdash which, from another point of view, can be thought of as \ldblquote panning\rdblquote  the viewRect over the PanRect area.  Mview has appropriate methods for returning the dis\-tances by which PanRect falls outside the viewRect area, so that the parent Scroller can set the scroll bar val\-ues appropriately.  One unusual thing we do here is to override addView: on Scroller so that it becomes an addView: on MainView, since this is usually what we really mean.  In the case where you want to really addView: on the Scroller, such as to add another child view alongside one of the scroll bars, you should sub\-class Scroller with the extra views as ivars, and at run time do addView: super as we do for the scroll bars (see the new: method).  Another approach we could have taken to implementing MainView would have been as a pointer, with late binding.  That way MainView could have been any view subclass.  That would have been more flexible, but possibly overkill for what we usually want to do\emdash it would have required a more complex setting-up process, with the MainView address having to be passed in after new: has been done.  But if you need the extra flexibility, feel free to clone Scroller and make the changes!\par \pard\plain \s6\qj\sb120\sa240 \f20 PanRect can obviously be very big, so we don\rquote t implement it as a regular rect, but define a new class, BigRect, which uses vars rather than ints for the coordinates.\par \pard\plain \s4\tx3600 \f20 Superclass\tab View\par Source file\tab Scroller\par Status\tab Optional\par \pard\plain \f20 Instance variables\par \pard\plain \s3\fi-3240\li3960\tx1800\tx3600 \f20\fs20 Mview\tab mainView\par vscroll\tab theVscroll\par hscroll\tab theHscroll\par bool\tab vscroll?\tab True if v scroll bar to be used\par bool\tab hscroll?\tab True if h scroll bar to be used\par bool\tab usePanRect?\tab True if we\rquote re to use PanRect\par var\tab Hpan\tab Horizontal panning range\par var\tab Hpos\tab Current vertical posn\par var\tab Vpan\tab Vertical ditto\par var\tab Vpos\par int\tab Hunit\tab # pixels for one horizontal arrow click\par int\tab Vunit\tab # pixels for one vertical arrow click\par \pard\plain \s4\tx3600 \f20 Indexed data\tab None\par System objects\tab None\par \pard\plain \s250\fi-360\li360\phpg\posx20161\dxfrtext180 \f20 View, Object\par \pard\plain \s11\sb120\keepn \b\f21 Methods\par \pard\plain \s252\li720\sb120\keepn \f21 accessing\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 Vscroll:  ( b -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Passed-in boolean is true if this Scroller is to have a vertical scroll bar.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 Hscroll:  ( b -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Passed-in boolean is true if this Scroller is to have a horizontal scroll bar.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 putPanRect:  ( l t r b -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets the PanRect directly.  The default, however, is to use the rect\-angle bounding all the child views.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 >Hunit:  ( n -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets the Hunit\emdash the number of pixels for one horizontal arrow click.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 >Vunit:  ( n -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets the Vunit.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 >Hrange:  ( lo hi -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets the lower and upper limits for the horizontal scroll bar.  This will normally be done automatically whenever the size of the PanRect is set.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 >Vrange:  ( lo hi -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets the lower and upper limits for the vertical scroll bar.\par \pard\plain \s252\li720\sb120\keepn \f21 object creation\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 new:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Fires up the Scroller at run time.  Calls addView: self with mainView and the two scroll bars, since as they are child views as well as ivars.  Note that new: is normally called automatically via a new: on the owning Window+.\par \pard\plain \s252\li720\sb120\keepn \f21 manipulation\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 ?Venable:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Enables the vertical scroll bar, if there is one and there is a scrolling range  (that is, if the PanRect extends beyond the ViewRect in the vertical direction).\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 ?Henable:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Enables the horizontal scroll bar, if there is one and there is a scrolling range.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 enable:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Enables the Scroller.  The above two methods are called to set the enabled/disabled status of the scroll bars appropriately.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 disable:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Disables the Scroller.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 moved:  ( left top -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 As for moved: on a View, but includes handling of the scroll bars.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 pan:  ( dx dy -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Pans the view over the child views by the given distance.  The scroll bars aren\rquote t altered\emdash use panRight: etc. for this, since they adjust the appropriate scroll bar and then call pan:.\par Note that panning doesn\rquote t actually move the view within its parent view, but the panning is accomplised by shifting the child views in the opposite direction.  Our convention is that positive dx and dy correspond to a pan to the right and down, which means that the child views are being shifted to the left and up, which is a \ldblquote negative\rdblquote  shift.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 panRight:  ( dx -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Pans the view to the right by dx pixels, or until the scroll limit is reached.  Adjusts the horizontal scroll bar appropriately.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 panLeft:  ( dx -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Pans the view to the left by dx pixels likewise.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 panUp:  ( dy -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Pans the view up by dy pixels likewise.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 panDown  ( dy -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Pans the view down by dy pixels likewise.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 Hpage:  ( -- #pixels )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the number of pixels corresponding to a \ldblquote page\rdblquote  in the hori\-zontal direction.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 Vpage:  ( -- #pixels )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the number of pixels corresponding to a \ldblquote page\rdblquote  in the ver\-tical direction.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 1right:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Handles a click in the right arrow of the horizontal scroll bar.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 1left:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Handles a click in the left arrow of the horizontal scroll bar.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 1up:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Handles a click in the up arrow of the vertical scroll bar.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 1down:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Handles a click in the down arrow of the vertical scroll bar.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 pgRight:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Handles a click in the \ldblquote page right\rdblquote  region of the horizontal scroll bar.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 pgLeft:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Handles a click in the \ldblquote page left\rdblquote  region of the horizontal scroll bar.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 pgUp:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Handles a click in the \ldblquote page up\rdblquote  region of the vertical scroll bar.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 pgDown:  ( ??? )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Handles a click in the \ldblquote page down\rdblquote  region of the vertical scroll bar.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 Hdrag:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Handles a drag of the horizontal scroll bar thumb.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 Vdrag:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Handles a drag of the vertical scroll bar thumb.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 classinit:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Initializes the Scroller to the default configuration\emdash with both scroll bars, and both Hunit and Vunit set to 4.  The justifications of the scroll bars are set so that they will be placed along the right and bottom edge of the Scroller.  The action handlers of both bars are set to call the appropriate methods above.\par \pard\plain \s11\sb120\keepn \b\f21 Error messages\par \pard\plain \s5\qj\li720\sb120 \f20 None\par \pard\plain \s253\ri5760\sb360\sa240\keepn\brdrt\brsp240\brdrth \brdrb\brsp120\brdrs \b\f21 TEScroller\par \pard\plain \s6\qj\sb120\sa240 \f20 TEScroller is a view which displays a TextEdit record in mainView (the main display area).  All the customary text editing operations are supported, including (of course) scrolling.  The main part of the Mops window (excluding the stack display) is a TEScroller.  The TextEdit record is handled via an ivar theTE, which is an instance of the class TextEdit.  Class TextEdit is probably not much use in isolation, (it would normally be used via this TEScroller class), so we won\rquote t document it in detail here in the manual.  However the source code (in file TextEdit) should be reasonably self-explanatory.\par \pard\plain \s4\tx3600 \f20 Superclass\tab Scroller\par Source file\tab TEScroller\par Status\tab Optional\par Instance variables\par \pard\plain \s3\fi-3240\li3960\tx1800\tx3600 \f20\fs20 TextEdit\tab theTE \par rect\tab rPanRect\tab TE needs a rect, not a bigRect.  So we mirror our PanRect here.\par \pard\plain \s4\tx3600 \f20 Indexed data\tab None\par \pard\plain \s250\fi-360\li360\phpg\posx20161\dxfrtext180 \f20 Scroller, View, Object\par \pard\plain \s11\sb120\keepn \b\f21 Methods\par \pard\plain \s7\qj\sb120 \f20 Note: Many of the methods are just overridden versions of the methods of the superclass Scroller, where there is an additional action to perform to the TextEdit object, but where the behavior of the method is really the same.  We won\rquote t list these individually, but concentrate on the methods that are new in this class.\par \pard\plain \s252\li720\sb120\keepn \f21 accessing\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 textHandle:  ( -- hndl )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns a handle to the text in the TextEdit object.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 handle:  ( -- TEhndl )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the TEHandle.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 size:  ( -- n )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the number of characters in the text.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 getSelect:  ( -- start end )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the selection range.  Start and end are character offsets in the text.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 selStart:  ( -- n )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the offset of the start of the selected range.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 selEnd:  ( -- n )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the offset of the end of the selected range.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 getLine:  ( -- start end )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the offset of the start and end of the line with the cursor.  No text need be selected.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 lineEnd:  ( -- n )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the offset of the end of the line with the cursor.\par editing\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 ?scroll:  ( x y -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 If necessary, does a scroll so that the point (x, y) is in view.  X and y are relative to the window, not the view.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 setSelect:  ( start end -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets the selection range.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 caretLoc:  ( -- x y )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the (window-relative) coordinates of the caret position.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 caretIntoView: ( ??? )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Scrolls if necessary so that the caret is in view.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 key:  ( c -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Handles a typed key, by passing it to the TextEdit object which will call TEKey.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 insert:  ( addr len -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Inserts the passed-in string into the text.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 $insert:  ( ^str -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Inserts the active part of the passed-in string+ object.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 cut:  ( ??? )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Handles a cut operation.  The TextEdit object will call TECut.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 copy:  ( ??? )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Handles a copy operation.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 paste:  ( ??? )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Handles a paste operation.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 clear:  ( ??? )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Handles a clear operation.\par \pard\plain \s255\qc\sb240\keepn \b\f21\fs36 \sect \sectd \sbkodd\linemod0\linex0\cols1\endnhere\titlepg {\headerl \pard\plain \s244\brdrb\brsp80\brdrhair \tqc\tx4680\tqr\tx9360 \f20 III-\chpgn \~Mops Predefined Classes\par }{\headerr \pard\plain \s244\brdrb\brsp80\brdrhair \tqc\tx4680\tqr\tx9360 \f20 \tab \tab Chapter 7\emdash Menus\~III-\chpgn \par }\pard\plain \s255\qc\sb240\keepn \b\f21\fs36 Chapter 7\emdash Menus\par \pard\plain \s254\sb240\keepn \b\f21 About This Chapter\par \pard\plain \s7\qj\sb120 \f20 This chapter describes the Mops classes and words that allow you to build your application\rquote s menus.\par \pard\plain \s254\sb240\keepn \b\f21 Recommended Reading \par \pard\plain \f20 IM -  Event Manager\par IM -  Menu Manager\par Mops - Events\par \pard\plain \s254\sb240\keepn \b\f21 Source Files\par \pard\plain \f20 Menu\par MenuMod.txt\par \pard\plain \s254\sb240\keepn \b\f21 Using Menus\par \pard\plain \s7\qj\sb120 \f20 Mops menus integrate the Toolbox concept of a menu within an object that stores Mops words to be exe\-cuted when the user makes a particular choice.  The Mops event object, fEvent, takes care of actually pulling down the menus by tracking the mouse and calling the menu manager whenever there is a click in the menu bar.  FEvent also handles key-equivalents for you automatically if you declare the key equivalents in your item text.  If the user makes a choice, a message is sent to the Mops menuBar object telling it to find the menu affected and execute the cell indexed by the item number chosen.  Menus are a subclass of X-Array, which provides the ability to execute one of a list of xts by index.\par There are two steps to defining the menus for your application.  You must first create an object of class Menu for each menu in the application, and allocate as many indexed cells to each menu object as there are items to be selected.  For example: \par \pard\plain \s10\keep\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 \f22\fs18 \tab 7 menu  FileMen\tab \tab \\  FileMen can have at most 7 items.\par \pard\plain \s7\qj\sb120 \f20 However, if you have many menu items with similar behavior, such as in a font menu, you only need to pro\-vide one indexed cell for that behavior, provided it is the last.  This is because if a menu item is selected whose number is beyond the last indexed cell of the menu object, no error occurs, but the last indexed cell is executed.  This feature is useful for the Apple menu as well.\par Then, in ResEdit, you create menu resources for your menus.  This is quite easy to do.  You will need to assign a resource ID for your menus in ResEdit\emdash it is quite satisfactory to give the Apple menu ID 1, the Edit menu ID 2 and so on.  Then when you initialize each menu object in Mops with the init: method, you will pass the corresponding resource ID, along with an xt list giving the word to be executed corresponding to each menu item.  Then at run time you send getnew: to each menu object to cause the menu to appear.\par Menu items which call hierarchical menus need to have a special character appended to the name of the menu item.  See IM-IV for more info.\par After your menus are set up, various methods are available to change their characteristics.  getitem: and setitem: fetch and store the item string for a given item.  Note that while the Menu Manager numbers items from 1 to N instead of starting from 0, in Mops we follow our normal convention of starting from 0.  This means that the xt for the word to be executed when item N is selected (using our numbering) will be item number N in the xt list.  The Toolbox automatically highlights (turns black) any menu title for which an item is chosen,  and the normal: method can be used to unhighlight any menu.  Class Menu automatically does a normal: after a handler returns, but some never return if they do a BECOME or an ABORT.  Class Menu\rquote s enableItem: and disableItem: methods are useful during activate events, when you should ensure that only those menu items are enabled that are appropriate for the current window and the current state.  If you want to enable or disable an entire menu, use enable: and disable:.  To enable or disable the entire menu bar, use MBar\rquote s enable: and disable: methods.  Finally, check: and unCheck: (in Menu) control the display of a checkmark next to an item.\par Mops defines a single instance of class MBar, called menuBar.  Because forward references to this object were necessary, menuBar is vectored through a Value.  As a result, any messages that you send to the menuBar object will be late-bound.  You should rarely need to communicate with MenuBar directly, because most of the methods important to an application are in class Menu.\par \pard\plain \s253\ri5760\sb360\sa240\keepn\brdrt\brsp240\brdrth \brdrb\brsp120\brdrs \b\f21 Menu\par \pard\plain \s6\qj\sb120\sa240 \f20 Class menu creates objects that associate Mops words with each of the items in a Macintosh menu.  The Mops word associated with an item is executed when that item is chosen by the user.\par \pard\plain \s4\tx3600 \f20 Superclass\tab X-Array\par Source file\tab Menu, MenuMod.txt\par Status\tab Core\par Instance variables\par \pard\plain \s3\fi-3240\li3960\tx1800\tx3600 \f20\fs20 int\tab resID\tab Resource ID of this menu\par var\tab Mhndl\tab \\Handle to the menu\rquote s heap storage\par \pard\plain \s4\tx3600 \f20 Indexed data\tab 4-byte cells (must be xts of valid Mops words) \par System objects\tab None\par \pard\plain \s250\fi-360\li360\phpg\posx20161\dxfrtext180 \f20 X-Array, Array, Indexed-Obj, Object\par \pard\plain \s11\sb120\keepn \b\f21 Methods\par \pard\plain \s252\li720\sb120\keepn \f21 object creation/deletion\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 putResID:  ( resID -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets the resource ID for this menu.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 init:  ( xt1 ... xtN N resID -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets the xt list and resource ID for this menu.  This may be done at compile time.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 new:  ( addr len -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Calls the toolbox to create a new menu using this object\rquote s data as the menu record.  Not resource based.  The title is passed in.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 getNew:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Calls the toolbox to create a new resource-based menu.  We rec\-ommend that you use init: and getNew: as the normal means of creating a menu.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 insert:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Inserts this menu into the menu bar.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 addRes:  ( type -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Adds all resources of a type to this menu.  Use this to append fonts or Apple menu items to a menu.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 release:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Releases the menu\rquote s heap storage.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 normal:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Removes the highlighting from all titles across the menu bar (regardless of which menu is the subject of this selector).\par \pard\plain \s252\li720\sb120\keepn \f21 operations on individual items\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 getItem:  ( item# -- addr len )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the text string for an item.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 putItem:  ( item# addr len -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Replaces the text string for the item by the passed-in text.  The \ldblquote meta-characters\rdblquote  described in IM don\rquote t apply.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 insertItem:  ( item# addr len -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Inserts a new item after the item given by item#.  The \ldblquote meta-charac\-ters\rdblquote  described in IM apply\emdash for example, if the text begins with a hyphen, the item will be a dividing line across the width of the menu.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 deleteItem:  ( item# -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Deletes the given item.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 addItem:  ( addr len -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Adds a new item to the end of this menu, with the passed-in text.  The text may be blank but should not be the null string. The \ldblquote meta-characters\rdblquote  described in IM apply.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 add:  ( addr len -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 An alias for addItem:.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 enableItem:  ( item# -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Makes an item eligible for selection by the user (black).\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 disableItem:  ( item# -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Makes an item ineligible for selection by the user (gray).\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 openDesk:  ( item# -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Runs the desk accessory/Apple menu item named by the specified item.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 exec:  ( item# -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Executes the handler for this item.\\ Menu handlers will have item# on the stack when they execute, and they should leave it there.  This way, they can ignore it if they want to, which will be the most common situation.  If the item# is too great for this menu, we actually execute the last item rather than give an error.  This allows us to save memory when a menu may have dozens of identical items.  But of course we don\rquote t alter the item# on the stack.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 check:  ( item# -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Shows a check mark by the item.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 unCheck:  ( item# -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Removes a check mark from an item.\par \pard\plain \s252\li720\sb120\keepn \f21 accessing\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 ID:  ( -- resID )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the resource ID of this menu.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 handle:  ( -- hndl )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the menu handle.\par \pard\plain \s11\sb120\keepn \b\f21 Error messages\par \pard\plain \s12\qj\sb120\keepn \i\f20 "You must send me a new: message first\rdblquote \par \pard\plain \s5\qj\li720\sb120 \f20 An operation was attempted before the menu was created with the Toolbox.\par \pard\plain \s253\ri5760\sb360\sa240\keepn\brdrt\brsp240\brdrth \brdrb\brsp120\brdrs \b\f21 AppleMenu\par \pard\plain \s6\qj\sb120\sa240 \f20 Subclass AppleMenu facilitates standard Apple Menu support, by filling the menu with all the DAs/Apple Menu items at getNew: time.\par \pard\plain \s4\tx3600 \f20 Superclass\tab Menu\par Source file\tab MenuMod.txt\par Status\tab Core\par Instance variables\tab none\par Indexed data\tab 4-byte cells (must be xts of valid Mops words)\par System objects\par \pard\plain \s9\fi-2880\li3600\tx3600 \f20 AppleMen\tab Apple menu usable by any application.  The first item executes AboutVec, a vector which can be set to your \ldblquote About...\rdblquote  handler word.\par \pard\plain \s250\fi-360\li360\phpg\posx20161\dxfrtext180 \f20 Menu, X-Array, Array, Indexed-Obj, Object\par \pard\plain \s11\sb120\keepn \b\f21 Methods\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 getNew:  ( item# -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 As for getNew: in Menu, but also adds all the DAs/ Apple Menu items via addRes: self.\par \pard\plain \s11\sb120\keepn \b\f21 Error messages\par \pard\plain \s12\qj\sb120\keepn \i\f20 "You must send me a new: message first\rdblquote \par \pard\plain \s5\qj\li720\sb120 \f20 An operation was attempted before the menu was created with the Toolbox.\par \pard\plain \s253\ri5760\sb360\sa240\keepn\brdrt\brsp240\brdrth \brdrb\brsp120\brdrs \b\f21 EditMenu\par \pard\plain \s6\qj\sb120\sa240 \f20 Subclass EditMenu facilitates standard DA support.  The exec: method first calls SystemEdit so any active DA gets a go at it.\par \pard\plain \s4\tx3600 \f20 Superclass\tab Menu\par Source file\tab MenuMod.txt\par Status\tab Core\par Instance variables\tab none\par Indexed data\tab 4-byte cells (must be xts of valid Mops words) \par System objects\tab None\par \pard\plain \s250\fi-360\li360\phpg\posx20161\dxfrtext180 \f20 Menu, X-Array, Array, Indexed-Obj, Object\par \pard\plain \s11\sb120\keepn \b\f21 Methods\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 exec:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 As for exec: on Menu, but includes a SystemEdit call.\par \pard\plain \s11\sb120\keepn \b\f21 Error messages\par \pard\plain \s12\qj\sb120\keepn \i\f20 "You must send me a new: message first\rdblquote \par \pard\plain \s5\qj\li720\sb120 \f20 An operation was attempted before the menu was created with the Toolbox.\par \pard\plain \s253\ri5760\sb360\sa240\keepn\brdrt\brsp240\brdrth \brdrb\brsp120\brdrs \b\f21 PopupMenu\par \pard\plain \s6\qj\sb120\sa240 \f20 Class PopupMenu provides support for popUp menus in dialogs.  (If you need one somewhere else, you will have to define a subclass with different init: and normal: methods.)  The sequence for setting up a pop-up menu is first to initialize the menu and dialog objects via init: methods\emdash this may be done at compile time.  At run time, send getnew: to the dialog and menu, then send a link: to the menu, passing the address of the dia\-log object.  See the example code at the end of the file PopupMenu.  The handling of pop-up menus is notori\-ously tricky, but we handle most of the mundane details for you.\par \pard\plain \s4\tx3600 \f20 Superclass\tab Menu\par Source file\tab PopupMenuMod.txt, PopupMenu\par Status\tab Optional   \par Instance variables\par \pard\plain \s3\fi-3240\li3960\tx1800\tx3600 \f20\fs20 string+\tab ITEMTEXT\tab Current text displayed in pop-up box\par int\tab ITEM#\tab Current item # displayed in pop-up box\par int\tab BOX#\tab Dialog item# of pop-up box\par int\tab TITLE#\tab Dialog item# of pop-up title\par rect\tab TITLERECT\par rect\tab POPUPBOX\par dicAddr\tab ^DLG\tab Points to owning dialog\par ptr\tab F-LINK\tab Forward link for chain of pop-up menus belonging to the one dialog.\par \pard\plain \s4\tx3600 \f20 Indexed data\tab 4-byte cells (must be xts of valid Mops words)\par System objects\tab None\par \pard\plain \s250\fi-360\li360\phpg\posx20161\dxfrtext180 \f20 Menu, X-Array, Array, Indexed-Obj, Object\par \pard\plain \s11\sb120\keepn \b\f21 Methods\par \pard\plain \s252\li720\sb120\keepn \f21 accessing\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 getText:  ( -- addr len )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the text to be displayed in the pop-up box.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 putText:  ( addr len -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets the text to be displayed in the pop-up box.  Doesn\rquote t attempt to actually display it, since the dialog may not be initialized.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 item#:  ( -- item# )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the number of the menu item displayed in the pop-up box.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 putItem#:  ( item# -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets the number of the menu item to be displayed in the pop-up box.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 putTitle#:  ( title# -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets the dialog item number of the pop-up title (note\emdash not the pop-up box!).\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 put^dlg:  ( ^dlg -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Stores the passed-in pointer to the owning dialog object.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 f-link:  ( -- ptr )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the address of the next popUpMenu object belonging to the same dialog.  Returns nilP if none.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 set-f-link:  ( ptr -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets the link to the next popUpMenu object belonging to the same dialog.  This link (a pointer to a popUpMenu object) is passed in.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 box#:  ( -- n )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the dialog item number of the pop-up box.\par \pard\plain \s252\li720\sb120\keepn \f21 object creation\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 init:  ( xt-list resID box# title# -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Initializes the menu.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 getNew:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 As for getNew: on Menu.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 link:  ( ^dlg -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Call this at run-time, after you have sent getnew: to both the dialog and the menu.  This method handles all the housekeeping for asso\-ciating the menu with the dialog.  For example, it installs a userItem handler for the pop-up box (PUBoxProc in file PopupMenu).  This word is called from the dialog whenever the pop-up box needs to be redrawn.  (Don\rquote t confuse this with the action handler for the pop-up box, which handles a click on the box, and which you have to specify when you send init: to the dialog.)\par \pard\plain \s252\li720\sb120\keepn \f21 operations\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 normal:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Unhilites the pop-up title.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 drawText:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Draws the text in the pop-up box.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 drawBox:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Draws the pop-up box, with the required drop shadow and down-pointing arrow symbol.  This method will be called automatically when the dialog box is updated, via our userItem handler PUBoxProc.  (The pop-up box is a userItem in the dialog, and at link: time we automatically install PUBoxProc as the userItem handler.)\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 hit:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Handles a click on the pop-up box.  Your action handler for the pop-up box (which is an item in the dialog) should include sending hit: to the menu.  As well as handling details such as the hiliting of the pop-up box, hit: sends exec: super, to execute your handler for the selected menu item.  When your handler gets called, the previ\-ously selected item# (whose text was in the pop-up box before) will still be in the item# ivar, while the new one will be on the stack.  This will be useful if you need to know if the item# is being changed or not.\par \pard\plain \s11\sb120\keepn \b\f21 Error messages\par \pard\plain \s12\qj\sb120\keepn \i\f20 "You must send me a new: message first\rdblquote \par \pard\plain \s5\qj\li720\sb120 \f20 An operation was attempted before the menu was created with the Toolbox.\par \pard\plain \s253\ri5760\sb360\sa240\keepn\brdrt\brsp240\brdrth \brdrb\brsp120\brdrs \b\f21 Mbar\par \pard\plain \s6\qj\sb120\sa240 \f20 MBar is used to create a single system object, MenuBar.  It maintains the list of menu objects and their IDs, and is chiefly useful at startup to build and draw the menu bar via messages sent by the menu text loader.  \par \pard\plain \s4\tx3600 \f20 Superclass\tab Object\par Source file\tab Menu\par Status\tab Core\par Instance variables\par \pard\plain \s3\fi-3240\li3960\tx1800\tx3600 \f20\fs20 24  WordCol\tab IDs\tab The list of menu IDs.\par 24  Array \tab Menus\tab An array of menu objects.\par \pard\plain \s4\tx3600 \f20 Indexed data\tab None\par \pard\plain \f20 System objects\par \pard\plain \s9\fi-2880\li3600\tx3600 \f20 menuBar \tab System-wide menu bar (vectored).\par \pard\plain \s250\fi-360\li360\phpg\posx20161\dxfrtext180 \f20 Object\par \pard\plain \s11\sb120\keepn \b\f21 Methods\par \pard\plain \s252\li720\sb120\keepn \f21 accessing\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 clear:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Clears all menus out of the menu bar.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 add:  ( men0 \'c9 menN #menus -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Specifies the menu objects to be added to the menu bar.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 new:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Calls the toolbox to insert each menu from add: into the menu bar and draws the menu bar.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 init:  ( men0 \'c9 menN #menus -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Combines the actions of clear:, add: and new:.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 draw:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Draws the menu bar.  (Primarily used by new:).\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 enable:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Enables all menus in menu bar.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 disable:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Disables all menus in menu bar.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 exec:  ( item# menuID -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Executes the handler for the given item in the given menu.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 click:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Handles a click in the menu bar, calling the toolbox to track menu selection until the mouse button is released.  Then executes the handler for the selected item (if any).\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 key:  ( chr -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Executes the handler of an item selected by a command key combi\-nation, if any.\par \pard\plain \s11\sb120\keepn \b\f21 Error messages\par \pard\plain \s5\qj\li720\sb120 \f20 None\par \pard\plain \s255\qc\sb240\keepn \b\f21\fs36 \sect \sectd \sbkodd\linemod0\linex0\cols1\endnhere\titlepg {\headerl \pard\plain \s244\brdrb\brsp80\brdrhair \tqc\tx4680\tqr\tx9360 \f20 III-\chpgn \~Mops Predefined Classes\par }{\headerr \pard\plain \s244\brdrb\brsp80\brdrhair \tqc\tx4680\tqr\tx9360 \f20 \tab \tab Chapter 8\emdash Graphics\~III-\chpgn \par }\pard\plain \s255\qc\sb240\keepn \b\f21\fs36 Chapter 8\emdash Graphics\par \pard\plain \s254\sb240\keepn \b\f21 About This Chapter\par \pard\plain \s7\qj\sb120 \f20 This chapter describes the Mops classes and words that provide an interface to the Macintosh QuickDraw graphics package.  This part of the Toolbox is responsible for all of the basic graphics management under\-ly\-ing windows, controls, dialogs and menus, and can also be called directly to accomplish various drawing tasks.  Because QuickDraw is so pervasive in the Macintosh, you should read the Inside Macintosh chapter on QuickDraw as a first step in learning how to use the rest of the User Interface Toolbox.  While Mops provides an easy interface to much of the QuickDraw package, it is very useful to try and get an under\-standing of the basic philosophy behind QuickDraw graphics by reading Inside Macintosh before you attempt to do any sophisticated graphics programming.  Other Toolbox modules, such as the Window Manager and the Control Manager, rely heavily upon QuickDraw to do much of their actual work.\par \pard\plain \s254\sb240\keepn \b\f21 Recommended Reading\par \pard\plain \f20 IM -  QuickDraw\par IM - Window Manager\par IM - Toolbox Utilities\par \pard\plain \s254\sb240\keepn \b\f21 Source Files\par \pard\plain \f20 QD\par \pard\plain \s254\sb240\keepn \b\f21 Using the Graphics Classes\par \pard\plain \s7\qj\sb120 \f20 Class Rect is the most widely used QuickDraw class, describing an extensive set of behaviors appropriate to basic rectangles.  Rectangles are used for a variety of operations in the Toolbox, such as sizing windows, controls and dialogs,  drawing rectangular frames, filling with a pattern, and clipping.  Class GrafPort is the superclass of window, and describes the graphics structure that QuickDraw uses as its foundation for win\-dowed behavior.\par The Mops word Cursor serves as a defining word to associate names with cursor resource definitions.  For instance:\par \pard\plain \s10\keep\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 \f22\fs18 \tab 1 cursor  IBeamCurs\par \pard\plain \s7\qj\sb120 \f20 associates the name IBeamCurs with the cursor data whose resource ID in the system is 1.  This happens to be the cursor used for editing text.  After this declaration, you can change the current cursor to this image by simply executing the word IBeamCurs.  Mops predefines four cursor images for you: IBeamCurs, crossCurs, plusCurs, and watchCurs.\par Mops provides access to the system pattern list via the word sysPat.   For instance, the phrase:\par \pard\plain \s10\keep\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 \f22\fs18 \tab 3 SysPat\par \pard\plain \s7\qj\sb120 \f20 leaves  a pointer to the system pattern with ID 3.  This can be used to send a Fill: message to various graph\-ics objects.\par \pard\plain \s253\ri5760\sb360\sa240\keepn\brdrt\brsp240\brdrth \brdrb\brsp120\brdrs \b\f21 Point\par \pard\plain \s6\qj\sb120\sa240 \f20 Point provides a building block for Rect.  A Rect is composed of two Points, each consisting of two Ints, Y and X.  Point\rquote s methods are useful in providing more advantageous access to a rectangle\rquote s data.  QuickDraw stores Y before X in Rectangles, but Mops always represents Points on the stack as ( X Y -- ).\par \pard\plain \s4\tx3600 \f20 Superclass\tab Object\par Source file\tab QD\par Status\tab Core\par Instance variables\par \pard\plain \s3\fi-3240\li3960\tx1800\tx3600 \f20\fs20 int\tab Y\tab The Point\rquote s Y coordinate.\par int\tab X\tab The Point\rquote s X coordinate.\par \pard\plain \s4\tx3600 \f20 Indexed data\tab None\par System objects\tab None\par \pard\plain \s250\fi-360\li360\phpg\posx20161\dxfrtext180 \f20 Object\par \pard\plain \s11\sb120\keepn \b\f21 Methods\par \pard\plain \s252\li720\sb120\keepn \f21 accessing\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 get:  ( --  x  y  )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the values in Y and X. \par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 getX:  ( --  x  )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the value in X. \par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 getY:  ( --  y  )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the value in Y. \par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 int:  ( -- x:y )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns a single longword with x and y packed into the high and low words, as required for a number of Toolbox calls.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 put:  ( x  y  --  )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Stores new values in Y and X. \par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 putX:  ( x -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Stores a new value in  X. \par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 putY:  ( y -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Stores a new value in Y. \par \pard\plain \s11\sb120\keepn \b\f21 Error messages\par \pard\plain \s5\qj\li720\sb120 \f20 None\par \pard\plain \s253\ri5760\sb360\sa240\keepn\brdrt\brsp240\brdrth \brdrb\brsp120\brdrs \b\f21 Rect\par \pard\plain \s6\qj\sb120\sa240 \f20 Rect is a widely used class that describes various properties of Rectangles.\par \pard\plain \s4\tx3600 \f20 Superclass\tab Object\par Source file\tab QD\par Status\tab Core\par Instance variables\par \pard\plain \s3\fi-3240\li3960\tx1800\tx3600 \f20\fs20 Point\tab TopL\tab Point describing top left corner.\par Point\tab BotR\tab Point describing bottom right corner.\par \pard\plain \s4\tx3600 \f20 Indexed data\tab None\par System objects\par \pard\plain \s9\fi-2880\li3600\tx3600 \f20 tempRect \tab A scratch rectangle.\par fpRect\tab Used for scrolling within fWind.\par \pard\plain \s250\fi-360\li360\phpg\posx20161\dxfrtext180 \f20 Object\par \pard\plain \s11\sb120\keepn \b\f21 Methods\par \pard\plain \s252\li720\sb120\keepn \f21 accessing\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 get:  ( -- l t r b )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the values in the Rect\rquote s two Points in (X  Y  X  Y) format.   The first  pair is the topLeft Point, and the pair on top of the stack is the bottomRight Point.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 getTop:  ( --  x y )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 \par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 topInt:  ( -- x:y )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the point TopL with x and y packed into a longword.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 getTopX:  ( --  x )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 \par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 getTopY:  ( --  y )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 \par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 getBot:  ( --  x y )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 \par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 botInt:  ( -- x:y )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 \par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 getBotX:  ( --  x )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 \par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 getBotY:  ( --  y )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 \par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 put:  ( l t r b -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Stores new coordinates in the Rectangle. \par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 putTop:  ( x y -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 \par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 putTopX:  ( x -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 \par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 putTopY:  ( y -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 \par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 putBot:  ( x y -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 \par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 putBotX:  ( x -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 \par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 putBotY:  ( y -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 \par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 size:  ( -- w h )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the size of the rectangle in pixels as width and height.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 setSize:  ( w h -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets the width and height of the rectangle according to w and h, by setting the BotR point.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 getCenter:  ( --  x y )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the center point of the rectangle in the local coordinates of the current GrafPort.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 inset:  ( dx dy -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Causes the rectangle to be grown or shrunk around the center point.  The left and right sides are moved in by the amount specified by dx; the top and bottom are moved towards the center by the amount specified by dy. If dh or dv is negative, the appropriate pair of sides is moved outwards instead of inwards.  Does not redraw the Rect.  If either the width or height would become negative, the rect\-angle is reset to the empty rectangle (0 0 0 0).\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 shift:  ( dx dy -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Moves the rectangle the given distance.  Does not redraw the Rect.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 offset:  ( dx dy -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 A synonym for shift:.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 stretch:  ( dx dy -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Shifts the BotR point by the given distance.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 ->:  ( ^rect -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Copies the Rect whose address is passed in, to this Rect.\par \pard\plain \s252\li720\sb120\keepn \f21 drawing\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 draw:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Draws the rectangle\rquote s frame.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 dropShadow:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 As for draw:, but adds a standard Mac drop shadow.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 disp:  ( l t r b -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Combines the actions of put: and draw:.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 clear:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Fills the rectangle\rquote s frame with the current GrafPort\rquote s background pattern.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 paint:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Fills the rectangle\rquote s frame with the current GrafPort\rquote s foreground pattern.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 fill:  ( pattern -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Given a pointer to a QuickDraw Pattern, fills the Rect\rquote s frame with the Pattern.  For example,  3 sysPat fill: myRect would fill the rect\-angle with the system pattern #3.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 invert:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Inverts the pixels bounded by the rectangle.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 clip:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Clips all subsequent drawing to the area bounded by the rectangle.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 update:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Causes an update event to occur for the current window that will redraw everything inside the rectangle.\par \pard\plain \s11\sb120\keepn \b\f21 Error messages\par \pard\plain \s5\qj\li720\sb120 \f20 None\par \pard\plain \s253\ri5760\sb360\sa240\keepn\brdrt\brsp240\brdrth \brdrb\brsp120\brdrs \b\f21 GrafPort\par \pard\plain \s6\qj\sb120\sa240 \f20 This class maps the record structure for a GrafPort.  A QuickDraw GrafPort defines a local drawing environ\-ment with its own coordinate system and pen characteristics, and provides the basic functionality necessary for windowing.  A Window record incorporates a GrafPort as the first part of its data.\par \pard\plain \s4\tx3600 \f20 Superclass\tab Object\par Source file\tab QD\par Status\tab Core\par Instance variables\par \pard\plain \s3\fi-3240\li3960\tx1800\tx3600 \f20\fs20 16 bytes \tab graf1\tab Allocates the first 16 bytes of the GrafPort.\par rect\tab PortRect\tab The port rectangle defining the GrafPort\rquote s limits.\par 44 bytes \tab graf2\tab Allocates the last 84 bytes of the GrafPort.\par var\tab Text1\tab font, face, mode, size\par var\tab Text2\par 32 bytes\tab graf3\par \pard\plain \s4\tx3600 \f20 Indexed data\tab None\par System objects\tab None\par \pard\plain \s250\fi-360\li360\phpg\posx20161\dxfrtext180 \f20 Object\par \pard\plain \s11\sb120\keepn \b\f21 Methods\par \pard\plain \s252\li720\sb120\keepn \f21 accessing\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 getRect:  ( -- l t r b )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the coordinates of the GrafPort\rquote s PortRect.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 putRect:  ( l t r b -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets the coordinates of the GrafPort\rquote s PortRect.\par \pard\plain \s252\li720\sb120\keepn \f21 drawing\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 set:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Causes this to be the current GrafPort for subsequent drawing.\par \pard\plain \s11\sb120\keepn \b\f21 Error messages\par \pard\plain \s5\qj\li720\sb120 \f20 None\par \pard\plain \s255\qc\sb240\keepn \b\f21\fs36 \sect \sectd \sbkodd\linemod0\linex0\cols1\endnhere\titlepg {\headerl \pard\plain \s244\brdrb\brsp80\brdrhair \tqc\tx4680\tqr\tx9360 \f20 III-\chpgn \~Mops Predefined Classes\par }{\headerr \pard\plain \s244\brdrb\brsp80\brdrhair \tqc\tx4680\tqr\tx9360 \f20 \tab \tab Chapter 9\emdash Dialogs\~III-\chpgn \par }\pard\plain \s255\qc\sb240\keepn \b\f21\fs36 Chapter 9\emdash Dialogs\par \pard\plain \s254\sb240\keepn \b\f21 About This Chapter\par \pard\plain \s7\qj\sb120 \f20 This chapter describes the Mops classes and words that manage dialogs and alerts for the application.  Dialogs are special-purpose windows that allow the user to modify parameters that affect the operation of your pro\-gram.  Alerts tell the user of exception conditions,  and verify that certain critical operations are appropriate before executing them.\par \pard\plain \s254\sb240\keepn \b\f21 Recommended Reading \par \pard\plain \f20 IM -  Window Manager\par IM -  Dialog Manager\par IM -  Control Manager\par Mops - Windows\par Mops - Controls\par \pard\plain \s254\sb240\keepn \b\f21 Source Files\par \pard\plain \f20 Alert\par Dialog\par DialogMod.txt\par Dialog+\par \pard\plain \s254\sb240\keepn \b\f21 Using Dialogs\par \pard\plain \s7\qj\sb120 \f20 Class Dialog is, like Menu, a subclass of X-Array.  Dialogs are similar to menus in that they  have items asso\-ciated with them that can be selected by the user.  Dialog items can be controls, static (non-editable) text, or editable text.  A dialog item is selected by pressing the mouse button in the region assigned to the item; if an item is enabled, it will cause the Dialog Manager to return immediately to the caller.  Text-edit items do not return immediately, but wait for keyboard input to be terminated by a carriage return.  \par Macintosh dialogs can be modal or modeless.  Mops\rquote s basic Dialog class supports modal dialogs, which do not allow the user to activate a different window while the dialog is active.  Subclass Dialog+ adds the neces\-sary support for modeless dialogs, which allow the user to activate a different window, select a menu or do anything else while they are active.\par Note that Apple recommend that you use modeless dialogs by preference, since they are more user-friendly.  They recommend you reserve modal dialogs for unusual situations where a user response must be obtained before the program can proceed (although in this situation an Alert box may well be more appropriate). \par Dialogs are heavily dependent upon resource definitions for the window and the item list.  You can use ResEdit to create resources of type DLOG and DITL, and then store the resource ID in a Mops object of class Dialog (see IM - Dialog Manager).  The items in a dialog\rquote s item list are not defined as control objects in Mops, because they can more easily be accessed via methods in class Dialog itself.  A Dialog object\rquote s indexed cells are loaded with the xts of Mops words, one per item.  For example, the handler for a Control of type CheckBox might be to get: the value of the control, XOR it with itself, and put: the result back in the control.  This would result in toggling  the value of the control between 0 and 1, turning the check mark off and on.  The value of the checkBox could be used to set a program parameter when the user leaves the dialog.\par For modal dialogs, once getNew: has been sent to fire up the dialog, you should send a modal: method to the dialog.  This calls the Toolbox routine ModalDialog, which initiates the Dialog Manager\rquote s event loop, which handles events until the user clicks on a dialog item.  Then, your handler for that item will be executed.  Each handler must end in one of two ways.  If the item chosen indicates that the user wants to leave the dialog, and the data provided by the user is acceptable, the handler should send a close: message to its dialog, which will make the window disappear and release the heap storage for the Toolbox data.  Otherwise, the handler should use the word ReturnToModal before it returns.  This will signal the modal: method, which is still active, to loop and call ModalDialog again.  Otherwise the modal: method will return to its caller.\par Modeless dialogs don\rquote t require modal:, of course.  Before you send getNew: to a modeless dialog to fire it up, you should execute the word +MODELESS, which modifies Mops\rquote  event handling so that it recognizes events relating to modeless dialogs.  When you are finished with all your modeless dialogs, you may execute -MODELESS to restore the original event handling, but there is really no need to do so as the additional over\-head is minimal.\par Item data can be accessed via get: and put: messages to the dialog, which assume that the item is a control; for text-edit items, use getText: and putText:.  SetSelect: will set the selection range for a text-edit item.  If you need to perform operations not provided in class Dialog, you can either get the handle for the item via the Handle: method, and call the Toolbox directly, or you can define a subclass of Dialog that has additional item methods.\par Alerts are very similar to Dialogs in implementation, with the exception that loading the Alert and entering the modal event loop are accomplished in a single operation via the show: message.  You must have a resource definition of type ALRT in your resource file with an associated item list.  The init: method of class Alert accepts both a resource ID and a type code; the type determines which icon will be printed in the upper-left corner of the alert:\par \pard\plain \tqc\tx1440 \f20 Type =\tab 0\tab Caution Alert\par \tab 1\tab Note  Alert\par \tab 2\tab Stop  Alert\par \tab >2\tab no icon \par \pard\plain \s7\qj\sb120 \f20 Because it is loaded and executed in a single operation, you cannot modify the item list for an Alert in mem\-ory.  Therefore, you should create item lists containing the exact information for each alert in your application.  You could, of course, also define a subclass of Alert that separates the loading and event-handling operations.\par Also provided is Alert" which gives you a predefined alert box without having to define any resources.  You can use Alert" in place of Abort" in your application to better comply with the Mac user interface guidelines.  However, Alert" is still rather \ldblquote quick and dirty"; it is best of all to create custom alert boxes.\par \pard\plain \s253\ri5760\sb360\sa240\keepn\brdrt\brsp240\brdrth \brdrb\brsp120\brdrs \b\f21 Dialog\par \pard\plain \s6\qj\sb120\sa240 \f20 Dialog implements a modal dialog object by associating the Toolbox dialog data with an X-Array contain\-ing the dialog\rquote s item handlers.\par \pard\plain \s4\tx3600 \f20 Superclass\tab X-Array\par Source file\tab Dialog, DialogMod.txt\par Status\tab Optional\par Instance variables\par \pard\plain \s3\fi-3240\li3960\tx1800\tx3600 \f20\fs20 int\tab resID\tab The resource ID of a DLOG resource.\par ptr\tab dlgPtr\tab Pointer to the dialog\rquote s non-relocatable heap.\par var\tab procPtr\tab Pointer to the PROC definition for ModalDialog.\par int\tab boldItem\tab item# to be drawn with a bold outline.\par \pard\plain \s4\tx3600 \f20 Indexed data\tab 4-byte cells (must be xts)\par System objects\tab None\par \pard\plain \s250\fi-360\li360\phpg\posx20161\dxfrtext180 \f20 X-Array, Array, Indexed-Obj, Object\par \pard\plain \s11\sb120\keepn \b\f21 Methods\par \pard\plain \s252\li720\sb120\keepn \f21 object creation\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 init:  ( <xt list> resID -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets the dialog\rquote s item handlers and resource ID of the dialog\rquote s DLOG resource.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 setBold:  ( item# -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets the item to be boldly outlined when the dialog is drawn.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 setProc:  ( xt -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets the filterProc to be used by modal.  This must be a :PROC definition.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 putResID:  ( resID -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets the resource ID for the dialog.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 getNew:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Loads the resource template for the dialog and displays its window as the frontmost window.  No key event can be processed after getNew: is issued and before modal: is issued.  (This means a getNew:, modal: sequence must be typed on one line if executed from the Mops prompt.)\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 show:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 If the dialog resource is set to be initially invisible, you will want to show: it when all the items are drawn.  It makes for a nicer build creation appearance.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 hide:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Makes the dialog invisible.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 modal:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Enters the Dialog Manager\rquote s modal event handler, which will beep whenever the user tries to click the mouse outside of the dialog window.  If a click occurs inside an enabled item, the dialog will execute the handler corresponding to that item, which should either send a close: to close the dialog or use ReturnToModal.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 close:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Closes the dialog window and disposes of the associated heap.\par \pard\plain \s252\li720\sb120\keepn \f21 accessing items\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 getItem:  ( item# -- val )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Gets the value of a control item (numbered from 1 to N).\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 putItem:  ( val item# -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets the value of a control item.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 getText:  ( item# -- addr len )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the text string for an item.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 putText:  ( addr len item# -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets the text string for an item.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 setSelect:  ( start end item# -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets the selection range for an editable text item.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 dlgPtr:  ( -- ^dlg )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the pointer to the dialog (after getNew: has been called).\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 itemHandle:  ( item# -- hndl )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the handle to the given item.  TempRect is also set to the item\rquote s rectangle.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 open?:  ( -- b )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns true if the dialog is open.\par \pard\plain \s252\li720\sb120\keepn \f21 drawing\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 draw:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Forces drawing of the dialog without (or before) executing modal:.  Useful in non-modal (or pre-modal ) situations.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 set:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Same as set: for class Window. Any text will be output to the dia\-log object.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 drawBold:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Draw the frame around the boldened OK button.  Normally called automatically\emdash from getNew:, and also, if this is a modeless dia\-log, in response to an update event.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 setUserProc:  ( ^proc item# -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets the :proc routine for a user item.\par \pard\plain \s252\li720\sb120\keepn \f21 manipulating individual items\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 hideItem:  ( item# -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Hides the item.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 showItem:  ( item# -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Shows the item.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 disableItem:  ( item# -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Disables the item.  It will be dimmed and not respond to clicks.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 enableItem:  ( item# -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Enables the item.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 hitBold:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Acts as if the bold item has been clicked, and executes the corre\-sponding item handler.  Call this if Return or Enter is typed while the dialog is active.  Does nothing if there isn\rquote t a bold item.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 key:  ( -- b )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Called when a key down event occurs with this dialog\rquote s window active.  Returns false if we\rquote ve handled the key here, so no further action is required.  Subclasses can have customized key: methods; here we just provide a hopefully sensible default action\emdash namely, we treat a Return or Enter as a click on the bold item, and ignore all other keys.\par \pard\plain \s252\li720\sb120\keepn \f21 manipulating the dialog\rquote s window\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 title:  ( addr len -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets the title of the dialog.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 maxX:  ( -- x )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sends maxX: to the dialog\rquote s window.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 maxY:  ( -- y )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 \par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 move:  ( x y -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Moves the dialog so that its top left corner is at the given coordinates.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 center:  ( ???) \par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Centers the dialog on the screen, by sending center: to the dialog\rquote s window.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 select:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Makes this dialog the frontmost window.\par \pard\plain \s252\li720\sb120\keepn \f21 global parameters\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 ParamText  ( addr0 len0 addr1 len1 addr2 len2 addr3 len3 -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 This is a word, not a method.  Calls the Dialog Manager routine ParamText which defines dialog text substitution strings.  All sub\-sequent static or editable text in dialogs will automatically substitute strings 0 through 3 for occurrences of \ldblquote ^0\rdblquote , \ldblquote ^1\rdblquote , \ldblquote ^2\rdblquote , and \ldblquote ^3\rdblquote , respectively.  NOTE: the combined length of the four strings must be less than or equal to 252 bytes.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 theItem, itemHandle, itemType\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 objects (see source file Dialog) holding parameters for selected items.\par \pard\plain \s11\sb120\keepn \b\f21 Error messages\par \pard\plain \s5\qj\li720\sb120 \f20 None\par \pard\plain \s253\ri5760\sb360\sa240\keepn\brdrt\brsp240\brdrth \brdrb\brsp120\brdrs \b\f21  Dialog+\par \pard\plain \s6\qj\sb120\sa240 \f20 Dialog+ adds support for modeless dialogs and pop-up menu dialog items.\par \pard\plain \s4\tx3600 \f20 Superclass\tab Dialog\par Source file\tab Dialog+\par Status\tab Optional\par Instance variables\par \pard\plain \s3\fi-3240\li3960\tx1800\tx3600 \f20\fs20 ptr\tab F-link\tab Forward link in chain of dialogs\par ptr\tab B-link\tab Backward link ditto\par bool\tab enabled?\par ptr\tab PUM-link\tab Link to any pop-up menus\par \pard\plain \s4\tx3600 \f20 Indexed data\tab 4-byte cells  (must be xts)\par System objects\tab None\par \pard\plain \s250\fi-360\li360\phpg\posx20161\dxfrtext180 \f20 Dialog, X-Array, Array, Indexed-Obj, Object\par \pard\plain \s11\sb120\keepn \b\f21 Methods\par \pard\plain \s252\li720\sb120\keepn \f21 object creation\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 getNew:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Loads the resource template for the dialog and displays its window as the frontmost window.  It will be a modeless dialog.  Provided +MODELESS has been executed, all dialog events such as updates or clicks on the dialog\rquote s items will be handled automatically.\par \pard\plain \s252\li720\sb120\keepn \f21 manipulation\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 close:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Closes the dialog and releases its storage.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 disable:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Disables the dialog.  It will still respond to update events, but not to clicks.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 enable:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Enables the dialog.  It will respond to all events as normal.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 exec:  ( item# -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 If the dialog is enabled, executes the handler for the given item.  Otherwise does nothing.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 enabled?:  ( -- b )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns true if the dialog is enabled.\par \pard\plain \s11\sb120\keepn \b\f21 Error messages\par \pard\plain \s5\qj\li720\sb120 \f20 None\par \pard\plain \s253\ri5760\sb360\sa240\keepn\brdrt\brsp240\brdrth \brdrb\brsp120\brdrs \b\f21  Alert\par \pard\plain \s6\qj\sb120\sa240 \f20 Alert loads and displays alerts defined in a resource file.\par \pard\plain \s4\tx3600 \f20 Superclass\tab X-Array\par Source file\tab Alert\par Status\tab Optional\par Instance variables\par \pard\plain \s3\fi-3240\li3960\tx1800\tx3600 \f20\fs20 Int\tab resID\tab Resource ID of an ALRT resource.\par Int \tab type\tab Icon type to display (see above).\par \pard\plain \s4\tx3600 \f20 Indexed data\tab 4-byte cells  (must be xts)\par System objects\tab None\par \pard\plain \s250\fi-360\li360\phpg\posx20161\dxfrtext180 \f20 X-Array, Array, Indexed-Obj, Object\par \pard\plain \s11\sb120\keepn \b\f21 Methods\par \pard\plain \s252\li720\sb120\keepn \f21 object creation\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 init:  ( resID type -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets the icon type and resource ID of the Alert.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 show:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Loads the Alert from a resource file, and enters the Dialog Manager\rquote s modal event loop.  Item handlers are executed as in Dialog, above.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 disp:  ( resId type -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Combines the actions of init: and show:.\par \pard\plain \s11\sb120\keepn \b\f21 Error messages\par \pard\plain \s5\qj\li720\sb120 \f20 None\par \pard\plain \s255\qc\sb240\keepn \b\f21\fs36 \sect \sectd \sbkodd\linemod0\linex0\cols1\endnhere\titlepg {\headerl \pard\plain \s244\brdrb\brsp80\brdrhair \tqc\tx4680\tqr\tx9360 \f20 III-\chpgn \~Mops Predefined Classes\par }{\headerr \pard\plain \s244\brdrb\brsp80\brdrhair \tqc\tx4680\tqr\tx9360 \f20 \tab \tab Chapter 10\emdash Floating Point\~III-\chpgn \par }\pard\plain \s255\qc\sb240\keepn \b\f21\fs36 Chapter 10\emdash Floating Point\par \pard\plain \s254\sb240\keepn \b\f21 About This Chapter\par \pard\plain \s7\qj\sb120 \f20 This chapter describes the Mops classes and words that manage floating point.  A floating point number is a 12 byte data value which is stored in a block in the heap and is accessed through its pointer.\par \pard\plain \s254\sb240\keepn \b\f21 Recommended Reading \par \pard\plain \f20 SANE manual\par \pard\plain \s254\sb240\keepn \b\f21 Source Files\par \pard\plain \f20 Floatint point\par \pard\plain \s254\sb240\keepn \b\f21 Using Floating Point\par \pard\plain \s7\qj\sb120 \f20 Floating point (FP) operations are implemented in different ways on different Macs.  Some have a coproces\-sor, in some cases FP operations are available on the main processor, and some Macs have no hardware FP at all, and must use the software package Standard Apple Numerics Environment, (SANE).  FP computa\-tions are handled by Mops in the appropriate way for the machine Mops is running on.  Many but not all FP func\-tions are implemented as methods of class Float.  Other functions are available as Mops words, (e.g., ln1, exp1, x**y, compound, annuity, etc\'c9). See the Glossary for these words.\par To access the Mops FP facilities, you must load the file \ldblquote Floating point\rdblquote  and save the dictionary.  Once \ldblquote Floating point\rdblquote  is loaded, Mops uses a slightly modified interpreter which converts numbers with decimal points to floating point format.\par It is important to note that Mops inherits certain behaviors from the Forth language concerning decimal points when running the standard integer interpreter.  Particularly, the decimal point is ignored except that DPL marks its position during input.  In the Mops FP interpreter the occurrence of a decimal point causes con\-ver\-sion to a 12 byte FP number (a \ldblquote float") which is stored in a block of storage in the floating heap.  The appli\-cation retains a pointer to the storage and is responsible to use the prescribed operations so as not to drop the last copy of a pointer before freeing the float, nor to free the float while still using a working copy of the pointer.\par So, a float is created when a decimal point is used on input:\par \pard\plain \s10\keep\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 \f22\fs18 \tab 1.2\tab \\ this creates the float and puts its pointer on the stack\par \pard\plain \s7\qj\sb120 \f20 You can use the normal stack operations to alter the position of a float on the stack:\par \pard\plain \s10\keep\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 \f22\fs18 \tab 1.2  3.4\tab \\ creates two floats\line \tab swap e. e.\tab \\ swaps and prints them, (deallocating their blocks)\par \pard\plain \s7\qj\sb120 \f20 To dup or drop a float, however, you must use special operators that take the float heap into account:\par \pard\plain \s10\keep\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 \f22\fs18 \tab 1.2  3.4 fdup e.\tab \\ creates 2 floats, dups the top one and prints it\par \pard\plain \s7\qj\sb120 \f20 There might be special cases in which you want to use regular DUP to make a copy of the pointer, which is faster than FDUP.  There are two dangers to avoid: 1) leaving yourself with a pointer to a deallocated heap block, or 2) dropping all copies of a pointer before the corresponding block is deallocated.  The following example is a safe use of DUP:\par \pard\plain \s10\keep\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 \f22\fs18 \tab 1.22  dup .h fdrop\tab \\ creates a float, prints its pointer,\line \tab \tab \tab \tab \tab \\ then drops it\par \pard\plain \s7\qj\sb120 \f20 The following are examples of floating arithmetic:\par \pard\plain \s10\keep\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 \f22\fs18 \tab 10.3  3.0  f*  e.\tab \tab \\ multiply two floats and print the product\line \tab 3.4 \tab 5.5  f+  e.\tab \tab \\ add two floats and print the sum\line \tab 1.0 sin  e.\tab \tab \tab \\ compute the sin of the float and print the\line \tab \tab \tab \tab \tab \\ result\par \pard\plain \s7\qj\sb120 \f20 fValue is the analog to Value for floating point numbers:\par \pard\plain \s10\keep\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 \f22\fs18 \tab .211 fValue  stuart\tab \tab \\ create a float value with an initial\line \tab \tab \tab \tab \tab \tab \\  value\line \tab stuart e.\tab \tab \tab \tab \\ print the value\line \tab 1.234 -> stuart  stuart e.\tab \\ store a new value and print it\line \tab 2.2 ++> stuart  stuart e.\tab \\ increment the value and print it\par \pard\plain \s7\qj\sb120 \f20 Class Float creates an object with a variety of computational methods:\par \pard\plain \s10\keep\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 \f22\fs18 \tab Float fred\tab \tab \tab \tab \\ create a float object\line \tab print: fred\tab \tab \tab \tab \\ print its value\line \tab 1.34  put: fred  print: fred\tab \\ change its value and print it\line \tab 3.4 +: fred  print: fred\tab \\ increment the value and print it\line \tab sin: fred  e.\tab \tab \tab \\ find the sine; doesn't change fred's\line \tab \tab \tab \tab \tab \tab \\  value\par \pard\plain \s7\qj\sb120 \f20 Class fArray creates a floating point array:\par \pard\plain \s10\keep\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 \f22\fs18 \tab 3 fArray  harold\tab \tab \tab \\ create a 3 element float array\line \tab 3.9 1  to: harold\tab \tab \tab \\ set 1st element to 3.9\line \tab 2.145 2  to: harold\tab \tab \\ set 2nd element to 2.145\line \tab print: harold\tab \tab \tab \\ print all elements of harold\line \tab 2 at: harold  e.\tab \tab \tab \\ print 2nd element of harold\par \pard\plain \s7\qj\sb120 \f20 You can define a floating point local variable by preceding the name with \lquote %\rquote .  The usual operations are used:\par \pard\plain \s10\keep\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 \f22\fs18 \tab : tst \{ int1 %flt1 -- \}\tab \\ declare 1 integer and 1 float parameter\line \tab int1 .  %flt1 e.\tab \tab \\ print both values, each in their own format\line \tab 3.445 ++> %flt1  %flt1 e.\tab \\ increment the float and print it\line \tab 1.22 -> %flt1  %flt1 e. ;\tab \\ change the value of the float and\line \tab \tab \tab \tab \tab \tab \\  print it\par \pard\plain \s7\qj\sb120 \f20 Conversion between Mops integers and floats are accomplished as follows:\par \pard\plain \s10\keep\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640 \f22\fs18 \tab 123 >float  e.\tab \\ convert  the integer to a float and print it\line \tab 3.545 float> .\tab \\ convert the float to an integer and print it\par \pard\plain \s7\qj\sb120 \f20 It should not be necessary to create objects of class FltHeap.  Mops provides fltMem which will accommo\-date up to 100 Float numbers.  In certain cases you may want to use method new:, which returns a pointer to a new float block in the heap, and dispose:, which frees a float block, although the printing words and methods au\-tomatically dispose of float heap blocks.  Also, room: returns the number of free float blocks remaining in the float heap.\par Here are some more technical details.  You don\rquote t need to read this section to use floating point, but there are some details here which can help you to get the best performance out of your FP code.\par The 12-byte FP format is the 96-bit \ldblquote extended\rdblquote  format defined for the harware floatint point unit (FPU)\emdash the MC68881 or MC68882, or the integrated FPU on the 68040 chip.  SANE defines an 80-bit extended format which is basically the same, except that the FPU carries 16 unused bits (for quad-word alignment) which are not present in the SANE format.  Mops uses the 96-bit format in order to make it easer to call the FPU directly, which Mops does if there is an FPU installed.  The value FPU? is set non-zero by the startup code if an FPU is present, and this value is tested \ldblquote on the fly\rdblquote  by the most common FP words.  If the FPU is pres\-ent, these FP words use it directly without calling SANE, which saves a lot of overhead.  If the FPU isn\rquote t present, of course, SANE is called.\par This method produces code which gives reasonably good performance, and will run on any Mac.  For exam\-ple it can be compiled on a Mac with an FPU, and run on one without.  If, however, you know your code will always be running on a Mac with an FPU, you can set the value  UseFPU?  to true, and Mops will compile FPU instructions in line.  Also, up to 6 FP parms/locals will be kept in the FPU\rquote s registers (which more than doubles the access speed), and some optimization is done on the code.  This produces some very fast code indeed.  To get the best results from this feature, it is best to use FP locals for temporary values, rather than the stack, which requires data to be moved over to the integer unit and back again.\par The forthcoming PowerPC Macs have their own FP instructions, handled within the chip.  Until Mops can compile native PPC code, it will have to run under emulation.  However, the emulator does NOT emulate an MC68881/2.  This means that for now, if you\rquote re running FP operations in Mops on a PowerPC, you\rquote ll have to use SANE.  This should happen automatically, since FPU? will always be set to false on a PowerPC.\par But it should now be clear that on a PowerPC, you should never set UseFPU? to true.  This would cause Mops to generate 68881/2 instructions, which would be invalid.  Later, when Mops can compile native PowerPC code, it will use the native PPC FP instructions, because they will always be present.  In this case it will ignore UseFPU?.  So the simple rule for PowerPC compatibility is, leave UseFPU? alone!\par The file \ldblquote FP test\rdblquote  in the \ldblquote Float source\rdblquote  folder has a timing test and the results I obtained on my IIsi.  To sum\-marize briefly, the test has two floating adds, two multiplies and a divide.  With UseFPU? false, that is compiling code which will run on all Macs, changing the FP words to use the FPU directly made the loop run about three times faster than when they had called SANE.  Setting UseFPU? true made it run about 14 times faster than originally.  The code ran at about 50% of the speed of the best I could do in hand-coded assembly.  I doubt that many other languages for the Mac can do as well as this.\par A note about accuracy.  Apple have warned (Mac Tech Note # 146) that SANE is more accurate than the FPU in computing the functions Sin, Cos, ArcTan, Exp, Ln, Tan, Exp1, Exp2, Ln1 and Log2.  Currently, in Mops, we use the FPU, if present, for Sin, Cos, Tan and ArcTan.  We may extend use of the FPU to the other functions in future.  I think the loss in accuracy is in the last 7 bits of the 64-bit mantissa.  If you can live with this, the code will certainly be much faster than a SANE call.  If you need the extra accuracy, you can either (i) call SANE yourself or (ii) before calling the Mops word for the function, put  false -> FPU? in your code.  This will tell Mops there is no FPU, and fool it into calling SANE.  Remember to leave UseFPU? false, as otherwise inline FPU code will be generated that never looks at  FPU?.\par Finally, heed Apple\rquote s warning, and don\rquote t assume the machine you\rquote re running on will always have an FPU if it is a 68020 or better.  The IIsi has a 68030 but the FPU is optional.  If in doubt, your code should check the FPU? flag which we provide in Mops.  It\rquote s always best to play safe.\par \pard\plain \s253\ri5760\sb360\sa240\keepn\brdrt\brsp240\brdrth \brdrb\brsp120\brdrs \b\f21 fArray\par \pard\plain \s6\qj\sb120\sa240 \f20 fArray provides an array construct for floating point numbers.\par \pard\plain \s4\tx3600 \f20 Superclass\tab Indexed-obj\par Source file\tab Floating point\par Status\tab Optional\par Instance variables\tab None\par Indexed data\tab 12-byte cells\par System objects\tab None\par \pard\plain \s250\fi-360\li360\phpg\posx20161\dxfrtext180 \f20 Indexed-Obj, Object\par \pard\plain \s11\sb120\keepn \b\f21 Methods\par \pard\plain \s252\li720\sb120\keepn \f21 accessing\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 ^elem:  ( index -- addr )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the address of the indexed cell.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 at:  ( index --  fval )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the data at the given indexed cell.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 to:  ( fval index -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Stores data at a given indexed cell.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 fill:  ( fval -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Stores fval in each cell of the array.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 print:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Prints the elements of the array with their respective index number.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 classinit:  ( -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Stores the value \ldblquote undefined\rdblquote  in each cell.\par \pard\plain \s11\sb120\keepn \b\f21 Error messages\par \pard\plain \s5\qj\li720\sb120 \f20 None\par \pard\plain \s253\ri5760\sb360\sa240\keepn\brdrt\brsp240\brdrth \brdrb\brsp120\brdrs \b\f21 FltHeap\par \pard\plain \s6\qj\sb120\sa240 \f20 This class defines the floating heap.\par \pard\plain \s4\tx3600 \f20 Superclass\tab Object\par Source file\tab Floating point\par Status\tab Optional\par Instance variables\par \pard\plain \s3\fi-3240\li3960\tx1800\tx3600 \f20\fs20 int\tab FreeHead\tab Offset of first free block \par \pard\plain \s4\tx3600 \f20 Indexed data\tab 14-byte cells\par System objects\par \pard\plain \s9\fi-2880\li3600\tx3600 \f20 fltMem\tab The system supplied float heap provides 100 blocks.\par \pard\plain \s250\fi-360\li360\phpg\posx20161\dxfrtext180 \f20 Object\par \pard\plain \s11\sb120\keepn \b\f21 Methods\par \pard\plain \s252\li720\sb120\keepn \f21 object creation\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 init:  ( --  )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Sets all blocks to free and links them together.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 new:  ( -- fPtr )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns a pointer to a new block.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 release:  ( fPtr -- )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Frees the block pointed at by fPtr.\par \pard\plain \s251\fi-360\li360\ri5940\sb120\sbys \f20 room:  ( -- #free )\par \pard\plain \s2\qj\li3600\sb120\sbys \f20 Returns the number of free float blocks remaining in float heap.\par \pard\plain \s11\sb120\keepn \b\f21 Error messages\par \pard\plain \s5\qj\li720\sb120 \f20 None\par }